!(function (e, t) {
  'object' == typeof exports && 'object' == typeof module
    ? (module.exports = t())
    : 'function' == typeof define && define.amd
    ? define([], t)
    : 'object' == typeof exports
    ? (exports.explosion = t())
    : (e.explosion = t());
})(window, function () {
  return (function (e) {
    var t = {};
    function r(n) {
      if (t[n]) return t[n].exports;
      var i = (t[n] = { i: n, l: !1, exports: {} });
      return e[n].call(i.exports, i, i.exports, r), (i.l = !0), i.exports;
    }
    return (
      (r.m = e),
      (r.c = t),
      (r.d = function (e, t, n) {
        r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n });
      }),
      (r.r = function (e) {
        'undefined' != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }),
          Object.defineProperty(e, '__esModule', { value: !0 });
      }),
      (r.t = function (e, t) {
        if ((1 & t && (e = r(e)), 8 & t)) return e;
        if (4 & t && 'object' == typeof e && e && e.__esModule) return e;
        var n = Object.create(null);
        if (
          (r.r(n),
          Object.defineProperty(n, 'default', { enumerable: !0, value: e }),
          2 & t && 'string' != typeof e)
        )
          for (var i in e)
            r.d(
              n,
              i,
              function (t) {
                return e[t];
              }.bind(null, i),
            );
        return n;
      }),
      (r.n = function (e) {
        var t =
          e && e.__esModule
            ? function () {
                return e.default;
              }
            : function () {
                return e;
              };
        return r.d(t, 'a', t), t;
      }),
      (r.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
      }),
      (r.p = 'js/'),
      r((r.s = 12))
    );
  })([
    function (e, t, r) {
      'use strict';
      function n() {}
      r.r(t),
        r.d(t, 'WebGLMultisampleRenderTarget', function () {
          return pr;
        }),
        r.d(t, 'WebGLRenderTargetCube', function () {
          return fr;
        }),
        r.d(t, 'WebGLRenderTarget', function () {
          return dr;
        }),
        r.d(t, 'WebGLRenderer', function () {
          return Ma;
        }),
        r.d(t, 'ShaderLib', function () {
          return Pr;
        }),
        r.d(t, 'UniformsLib', function () {
          return Cr;
        }),
        r.d(t, 'UniformsUtils', function () {
          return Tr;
        }),
        r.d(t, 'ShaderChunk', function () {
          return br;
        }),
        r.d(t, 'FogExp2', function () {
          return Sa;
        }),
        r.d(t, 'Fog', function () {
          return Ea;
        }),
        r.d(t, 'Scene', function () {
          return Ta;
        }),
        r.d(t, 'Sprite', function () {
          return Ca;
        }),
        r.d(t, 'LOD', function () {
          return Pa;
        }),
        r.d(t, 'SkinnedMesh', function () {
          return Oa;
        }),
        r.d(t, 'Skeleton', function () {
          return Ia;
        }),
        r.d(t, 'Bone', function () {
          return Da;
        }),
        r.d(t, 'Mesh', function () {
          return Cn;
        }),
        r.d(t, 'LineSegments', function () {
          return Ua;
        }),
        r.d(t, 'LineLoop', function () {
          return Ga;
        }),
        r.d(t, 'Line', function () {
          return Na;
        }),
        r.d(t, 'Points', function () {
          return za;
        }),
        r.d(t, 'Group', function () {
          return ca;
        }),
        r.d(t, 'VideoTexture', function () {
          return Ha;
        }),
        r.d(t, 'DataTexture', function () {
          return mr;
        }),
        r.d(t, 'DataTexture3D', function () {
          return Vn;
        }),
        r.d(t, 'CompressedTexture', function () {
          return ka;
        }),
        r.d(t, 'CubeTexture', function () {
          return kn;
        }),
        r.d(t, 'CanvasTexture', function () {
          return Va;
        }),
        r.d(t, 'DepthTexture', function () {
          return ja;
        }),
        r.d(t, 'Texture', function () {
          return lr;
        }),
        r.d(t, 'AnimationLoader', function () {
          return Ns;
        }),
        r.d(t, 'CompressedTextureLoader', function () {
          return Us;
        }),
        r.d(t, 'DataTextureLoader', function () {
          return Gs;
        }),
        r.d(t, 'CubeTextureLoader', function () {
          return zs;
        }),
        r.d(t, 'TextureLoader', function () {
          return Hs;
        }),
        r.d(t, 'ObjectLoader', function () {
          return Tc;
        }),
        r.d(t, 'MaterialLoader', function () {
          return _c;
        }),
        r.d(t, 'BufferGeometryLoader', function () {
          return Sc;
        }),
        r.d(t, 'DefaultLoadingManager', function () {
          return Is;
        }),
        r.d(t, 'LoadingManager', function () {
          return Os;
        }),
        r.d(t, 'ImageLoader', function () {
          return Fs;
        }),
        r.d(t, 'ImageBitmapLoader', function () {
          return Bc;
        }),
        r.d(t, 'FontLoader', function () {
          return Fc;
        }),
        r.d(t, 'FileLoader', function () {
          return Bs;
        }),
        r.d(t, 'Loader', function () {
          return zc;
        }),
        r.d(t, 'LoaderUtils', function () {
          return Mc;
        }),
        r.d(t, 'Cache', function () {
          return Ps;
        }),
        r.d(t, 'AudioLoader', function () {
          return Qc;
        }),
        r.d(t, 'SpotLightShadow', function () {
          return fc;
        }),
        r.d(t, 'SpotLight', function () {
          return mc;
        }),
        r.d(t, 'PointLight', function () {
          return vc;
        }),
        r.d(t, 'RectAreaLight', function () {
          return wc;
        }),
        r.d(t, 'HemisphereLight', function () {
          return dc;
        }),
        r.d(t, 'DirectionalLightShadow', function () {
          return yc;
        }),
        r.d(t, 'DirectionalLight', function () {
          return xc;
        }),
        r.d(t, 'AmbientLight', function () {
          return bc;
        }),
        r.d(t, 'LightShadow', function () {
          return pc;
        }),
        r.d(t, 'Light', function () {
          return hc;
        }),
        r.d(t, 'StereoCamera', function () {
          return $c;
        }),
        r.d(t, 'PerspectiveCamera', function () {
          return la;
        }),
        r.d(t, 'OrthographicCamera', function () {
          return gc;
        }),
        r.d(t, 'CubeCamera', function () {
          return eu;
        }),
        r.d(t, 'ArrayCamera', function () {
          return ha;
        }),
        r.d(t, 'Camera', function () {
          return ua;
        }),
        r.d(t, 'AudioListener', function () {
          return ru;
        }),
        r.d(t, 'PositionalAudio', function () {
          return iu;
        }),
        r.d(t, 'AudioContext', function () {
          return Kc;
        }),
        r.d(t, 'AudioAnalyser', function () {
          return au;
        }),
        r.d(t, 'Audio', function () {
          return nu;
        }),
        r.d(t, 'VectorKeyframeTrack', function () {
          return Ls;
        }),
        r.d(t, 'StringKeyframeTrack', function () {
          return As;
        }),
        r.d(t, 'QuaternionKeyframeTrack', function () {
          return Ts;
        }),
        r.d(t, 'NumberKeyframeTrack', function () {
          return Ss;
        }),
        r.d(t, 'ColorKeyframeTrack', function () {
          return Ms;
        }),
        r.d(t, 'BooleanKeyframeTrack', function () {
          return _s;
        }),
        r.d(t, 'PropertyMixer', function () {
          return ou;
        }),
        r.d(t, 'PropertyBinding', function () {
          return Mu;
        }),
        r.d(t, 'KeyframeTrack', function () {
          return ws;
        }),
        r.d(t, 'AnimationUtils', function () {
          return vs;
        }),
        r.d(t, 'AnimationObjectGroup', function () {
          return Su;
        }),
        r.d(t, 'AnimationMixer', function () {
          return Tu;
        }),
        r.d(t, 'AnimationClip', function () {
          return Rs;
        }),
        r.d(t, 'Uniform', function () {
          return Au;
        }),
        r.d(t, 'InstancedBufferGeometry', function () {
          return Lu;
        }),
        r.d(t, 'BufferGeometry', function () {
          return sn;
        }),
        r.d(t, 'Geometry', function () {
          return qr;
        }),
        r.d(t, 'InterleavedBufferAttribute', function () {
          return La;
        }),
        r.d(t, 'InstancedInterleavedBuffer', function () {
          return Ru;
        }),
        r.d(t, 'InterleavedBuffer', function () {
          return Aa;
        }),
        r.d(t, 'InstancedBufferAttribute', function () {
          return Cu;
        }),
        r.d(t, 'Face3', function () {
          return Dr;
        }),
        r.d(t, 'Object3D', function () {
          return kr;
        }),
        r.d(t, 'Raycaster', function () {
          return Pu;
        }),
        r.d(t, 'Layers', function () {
          return Nr;
        }),
        r.d(t, 'EventDispatcher', function () {
          return n;
        }),
        r.d(t, 'Clock', function () {
          return tu;
        }),
        r.d(t, 'QuaternionLinearInterpolant', function () {
          return Es;
        }),
        r.d(t, 'LinearInterpolant', function () {
          return xs;
        }),
        r.d(t, 'DiscreteInterpolant', function () {
          return bs;
        }),
        r.d(t, 'CubicInterpolant', function () {
          return ys;
        }),
        r.d(t, 'Interpolant', function () {
          return gs;
        }),
        r.d(t, 'Triangle', function () {
          return Ln;
        }),
        r.d(t, 'Math', function () {
          return Kt;
        }),
        r.d(t, 'Spherical', function () {
          return Du;
        }),
        r.d(t, 'Cylindrical', function () {
          return Bu;
        }),
        r.d(t, 'Plane', function () {
          return yr;
        }),
        r.d(t, 'Frustum', function () {
          return xr;
        }),
        r.d(t, 'Sphere', function () {
          return gr;
        }),
        r.d(t, 'Ray', function () {
          return An;
        }),
        r.d(t, 'Matrix4', function () {
          return $t;
        }),
        r.d(t, 'Matrix3', function () {
          return rr;
        }),
        r.d(t, 'Box3', function () {
          return vr;
        }),
        r.d(t, 'Box2', function () {
          return Nu;
        }),
        r.d(t, 'Line3', function () {
          return Uu;
        }),
        r.d(t, 'Euler', function () {
          return Br;
        }),
        r.d(t, 'Vector4', function () {
          return hr;
        }),
        r.d(t, 'Vector3', function () {
          return tr;
        }),
        r.d(t, 'Vector2', function () {
          return Qt;
        }),
        r.d(t, 'Quaternion', function () {
          return er;
        }),
        r.d(t, 'Color', function () {
          return Lr;
        }),
        r.d(t, 'ImmediateRenderObject', function () {
          return Gu;
        }),
        r.d(t, 'VertexNormalsHelper', function () {
          return Fu;
        }),
        r.d(t, 'SpotLightHelper', function () {
          return zu;
        }),
        r.d(t, 'SkeletonHelper', function () {
          return Hu;
        }),
        r.d(t, 'PointLightHelper', function () {
          return ku;
        }),
        r.d(t, 'RectAreaLightHelper', function () {
          return Vu;
        }),
        r.d(t, 'HemisphereLightHelper', function () {
          return ju;
        }),
        r.d(t, 'GridHelper', function () {
          return Wu;
        }),
        r.d(t, 'PolarGridHelper', function () {
          return qu;
        }),
        r.d(t, 'FaceNormalsHelper', function () {
          return Xu;
        }),
        r.d(t, 'DirectionalLightHelper', function () {
          return Yu;
        }),
        r.d(t, 'CameraHelper', function () {
          return Ju;
        }),
        r.d(t, 'BoxHelper', function () {
          return Zu;
        }),
        r.d(t, 'Box3Helper', function () {
          return Ku;
        }),
        r.d(t, 'PlaneHelper', function () {
          return Qu;
        }),
        r.d(t, 'ArrowHelper', function () {
          return $u;
        }),
        r.d(t, 'AxesHelper', function () {
          return el;
        }),
        r.d(t, 'Shape', function () {
          return lc;
        }),
        r.d(t, 'Path', function () {
          return uc;
        }),
        r.d(t, 'ShapePath', function () {
          return Nc;
        }),
        r.d(t, 'Font', function () {
          return Uc;
        }),
        r.d(t, 'CurvePath', function () {
          return cc;
        }),
        r.d(t, 'Curve', function () {
          return ks;
        }),
        r.d(t, 'ImageUtils', function () {
          return cr;
        }),
        r.d(t, 'ShapeUtils', function () {
          return Io;
        }),
        r.d(t, 'WebGLUtils', function () {
          return sa;
        }),
        r.d(t, 'WireframeGeometry', function () {
          return Wa;
        }),
        r.d(t, 'ParametricGeometry', function () {
          return qa;
        }),
        r.d(t, 'ParametricBufferGeometry', function () {
          return Xa;
        }),
        r.d(t, 'TetrahedronGeometry', function () {
          return Za;
        }),
        r.d(t, 'TetrahedronBufferGeometry', function () {
          return Ka;
        }),
        r.d(t, 'OctahedronGeometry', function () {
          return Qa;
        }),
        r.d(t, 'OctahedronBufferGeometry', function () {
          return $a;
        }),
        r.d(t, 'IcosahedronGeometry', function () {
          return eo;
        }),
        r.d(t, 'IcosahedronBufferGeometry', function () {
          return to;
        }),
        r.d(t, 'DodecahedronGeometry', function () {
          return ro;
        }),
        r.d(t, 'DodecahedronBufferGeometry', function () {
          return no;
        }),
        r.d(t, 'PolyhedronGeometry', function () {
          return Ya;
        }),
        r.d(t, 'PolyhedronBufferGeometry', function () {
          return Ja;
        }),
        r.d(t, 'TubeGeometry', function () {
          return io;
        }),
        r.d(t, 'TubeBufferGeometry', function () {
          return ao;
        }),
        r.d(t, 'TorusKnotGeometry', function () {
          return oo;
        }),
        r.d(t, 'TorusKnotBufferGeometry', function () {
          return so;
        }),
        r.d(t, 'TorusGeometry', function () {
          return co;
        }),
        r.d(t, 'TorusBufferGeometry', function () {
          return uo;
        }),
        r.d(t, 'TextGeometry', function () {
          return zo;
        }),
        r.d(t, 'TextBufferGeometry', function () {
          return Ho;
        }),
        r.d(t, 'SphereGeometry', function () {
          return ko;
        }),
        r.d(t, 'SphereBufferGeometry', function () {
          return Vo;
        }),
        r.d(t, 'RingGeometry', function () {
          return jo;
        }),
        r.d(t, 'RingBufferGeometry', function () {
          return Wo;
        }),
        r.d(t, 'PlaneGeometry', function () {
          return ln;
        }),
        r.d(t, 'PlaneBufferGeometry', function () {
          return hn;
        }),
        r.d(t, 'LatheGeometry', function () {
          return qo;
        }),
        r.d(t, 'LatheBufferGeometry', function () {
          return Xo;
        }),
        r.d(t, 'ShapeGeometry', function () {
          return Yo;
        }),
        r.d(t, 'ShapeBufferGeometry', function () {
          return Jo;
        }),
        r.d(t, 'ExtrudeGeometry', function () {
          return No;
        }),
        r.d(t, 'ExtrudeBufferGeometry', function () {
          return Uo;
        }),
        r.d(t, 'EdgesGeometry', function () {
          return Ko;
        }),
        r.d(t, 'ConeGeometry', function () {
          return es;
        }),
        r.d(t, 'ConeBufferGeometry', function () {
          return ts;
        }),
        r.d(t, 'CylinderGeometry', function () {
          return Qo;
        }),
        r.d(t, 'CylinderBufferGeometry', function () {
          return $o;
        }),
        r.d(t, 'CircleGeometry', function () {
          return rs;
        }),
        r.d(t, 'CircleBufferGeometry', function () {
          return ns;
        }),
        r.d(t, 'BoxGeometry', function () {
          return cn;
        }),
        r.d(t, 'CubeGeometry', function () {
          return cn;
        }),
        r.d(t, 'BoxBufferGeometry', function () {
          return un;
        }),
        r.d(t, 'ShadowMaterial', function () {
          return as;
        }),
        r.d(t, 'SpriteMaterial', function () {
          return Ra;
        }),
        r.d(t, 'RawShaderMaterial', function () {
          return os;
        }),
        r.d(t, 'ShaderMaterial', function () {
          return Tn;
        }),
        r.d(t, 'PointsMaterial', function () {
          return Fa;
        }),
        r.d(t, 'MeshPhysicalMaterial', function () {
          return cs;
        }),
        r.d(t, 'MeshStandardMaterial', function () {
          return ss;
        }),
        r.d(t, 'MeshPhongMaterial', function () {
          return us;
        }),
        r.d(t, 'MeshToonMaterial', function () {
          return ls;
        }),
        r.d(t, 'MeshNormalMaterial', function () {
          return hs;
        }),
        r.d(t, 'MeshLambertMaterial', function () {
          return ds;
        }),
        r.d(t, 'MeshDepthMaterial', function () {
          return ra;
        }),
        r.d(t, 'MeshDistanceMaterial', function () {
          return na;
        }),
        r.d(t, 'MeshBasicMaterial', function () {
          return Rn;
        }),
        r.d(t, 'MeshMatcapMaterial', function () {
          return ps;
        }),
        r.d(t, 'LineDashedMaterial', function () {
          return fs;
        }),
        r.d(t, 'LineBasicMaterial', function () {
          return Ba;
        }),
        r.d(t, 'Material', function () {
          return En;
        }),
        r.d(t, 'Float64BufferAttribute', function () {
          return rn;
        }),
        r.d(t, 'Float32BufferAttribute', function () {
          return tn;
        }),
        r.d(t, 'Uint32BufferAttribute', function () {
          return en;
        }),
        r.d(t, 'Int32BufferAttribute', function () {
          return $r;
        }),
        r.d(t, 'Uint16BufferAttribute', function () {
          return Qr;
        }),
        r.d(t, 'Int16BufferAttribute', function () {
          return Kr;
        }),
        r.d(t, 'Uint8ClampedBufferAttribute', function () {
          return Zr;
        }),
        r.d(t, 'Uint8BufferAttribute', function () {
          return Jr;
        }),
        r.d(t, 'Int8BufferAttribute', function () {
          return Yr;
        }),
        r.d(t, 'BufferAttribute', function () {
          return Xr;
        }),
        r.d(t, 'ArcCurve', function () {
          return js;
        }),
        r.d(t, 'CatmullRomCurve3', function () {
          return Zs;
        }),
        r.d(t, 'CubicBezierCurve', function () {
          return ec;
        }),
        r.d(t, 'CubicBezierCurve3', function () {
          return tc;
        }),
        r.d(t, 'EllipseCurve', function () {
          return Vs;
        }),
        r.d(t, 'LineCurve', function () {
          return rc;
        }),
        r.d(t, 'LineCurve3', function () {
          return nc;
        }),
        r.d(t, 'QuadraticBezierCurve', function () {
          return ic;
        }),
        r.d(t, 'QuadraticBezierCurve3', function () {
          return ac;
        }),
        r.d(t, 'SplineCurve', function () {
          return oc;
        }),
        r.d(t, 'REVISION', function () {
          return v;
        }),
        r.d(t, 'MOUSE', function () {
          return g;
        }),
        r.d(t, 'CullFaceNone', function () {
          return y;
        }),
        r.d(t, 'CullFaceBack', function () {
          return x;
        }),
        r.d(t, 'CullFaceFront', function () {
          return b;
        }),
        r.d(t, 'CullFaceFrontBack', function () {
          return w;
        }),
        r.d(t, 'FrontFaceDirectionCW', function () {
          return _;
        }),
        r.d(t, 'FrontFaceDirectionCCW', function () {
          return M;
        }),
        r.d(t, 'BasicShadowMap', function () {
          return S;
        }),
        r.d(t, 'PCFShadowMap', function () {
          return E;
        }),
        r.d(t, 'PCFSoftShadowMap', function () {
          return T;
        }),
        r.d(t, 'FrontSide', function () {
          return A;
        }),
        r.d(t, 'BackSide', function () {
          return L;
        }),
        r.d(t, 'DoubleSide', function () {
          return R;
        }),
        r.d(t, 'FlatShading', function () {
          return C;
        }),
        r.d(t, 'SmoothShading', function () {
          return P;
        }),
        r.d(t, 'NoColors', function () {
          return O;
        }),
        r.d(t, 'FaceColors', function () {
          return I;
        }),
        r.d(t, 'VertexColors', function () {
          return D;
        }),
        r.d(t, 'NoBlending', function () {
          return B;
        }),
        r.d(t, 'NormalBlending', function () {
          return N;
        }),
        r.d(t, 'AdditiveBlending', function () {
          return U;
        }),
        r.d(t, 'SubtractiveBlending', function () {
          return G;
        }),
        r.d(t, 'MultiplyBlending', function () {
          return F;
        }),
        r.d(t, 'CustomBlending', function () {
          return z;
        }),
        r.d(t, 'AddEquation', function () {
          return H;
        }),
        r.d(t, 'SubtractEquation', function () {
          return k;
        }),
        r.d(t, 'ReverseSubtractEquation', function () {
          return V;
        }),
        r.d(t, 'MinEquation', function () {
          return j;
        }),
        r.d(t, 'MaxEquation', function () {
          return W;
        }),
        r.d(t, 'ZeroFactor', function () {
          return q;
        }),
        r.d(t, 'OneFactor', function () {
          return X;
        }),
        r.d(t, 'SrcColorFactor', function () {
          return Y;
        }),
        r.d(t, 'OneMinusSrcColorFactor', function () {
          return J;
        }),
        r.d(t, 'SrcAlphaFactor', function () {
          return Z;
        }),
        r.d(t, 'OneMinusSrcAlphaFactor', function () {
          return K;
        }),
        r.d(t, 'DstAlphaFactor', function () {
          return Q;
        }),
        r.d(t, 'OneMinusDstAlphaFactor', function () {
          return $;
        }),
        r.d(t, 'DstColorFactor', function () {
          return ee;
        }),
        r.d(t, 'OneMinusDstColorFactor', function () {
          return te;
        }),
        r.d(t, 'SrcAlphaSaturateFactor', function () {
          return re;
        }),
        r.d(t, 'NeverDepth', function () {
          return ne;
        }),
        r.d(t, 'AlwaysDepth', function () {
          return ie;
        }),
        r.d(t, 'LessDepth', function () {
          return ae;
        }),
        r.d(t, 'LessEqualDepth', function () {
          return oe;
        }),
        r.d(t, 'EqualDepth', function () {
          return se;
        }),
        r.d(t, 'GreaterEqualDepth', function () {
          return ce;
        }),
        r.d(t, 'GreaterDepth', function () {
          return ue;
        }),
        r.d(t, 'NotEqualDepth', function () {
          return le;
        }),
        r.d(t, 'MultiplyOperation', function () {
          return he;
        }),
        r.d(t, 'MixOperation', function () {
          return de;
        }),
        r.d(t, 'AddOperation', function () {
          return pe;
        }),
        r.d(t, 'NoToneMapping', function () {
          return fe;
        }),
        r.d(t, 'LinearToneMapping', function () {
          return me;
        }),
        r.d(t, 'ReinhardToneMapping', function () {
          return ve;
        }),
        r.d(t, 'Uncharted2ToneMapping', function () {
          return ge;
        }),
        r.d(t, 'CineonToneMapping', function () {
          return ye;
        }),
        r.d(t, 'ACESFilmicToneMapping', function () {
          return xe;
        }),
        r.d(t, 'UVMapping', function () {
          return be;
        }),
        r.d(t, 'CubeReflectionMapping', function () {
          return we;
        }),
        r.d(t, 'CubeRefractionMapping', function () {
          return _e;
        }),
        r.d(t, 'EquirectangularReflectionMapping', function () {
          return Me;
        }),
        r.d(t, 'EquirectangularRefractionMapping', function () {
          return Se;
        }),
        r.d(t, 'SphericalReflectionMapping', function () {
          return Ee;
        }),
        r.d(t, 'CubeUVReflectionMapping', function () {
          return Te;
        }),
        r.d(t, 'CubeUVRefractionMapping', function () {
          return Ae;
        }),
        r.d(t, 'RepeatWrapping', function () {
          return Le;
        }),
        r.d(t, 'ClampToEdgeWrapping', function () {
          return Re;
        }),
        r.d(t, 'MirroredRepeatWrapping', function () {
          return Ce;
        }),
        r.d(t, 'NearestFilter', function () {
          return Pe;
        }),
        r.d(t, 'NearestMipMapNearestFilter', function () {
          return Oe;
        }),
        r.d(t, 'NearestMipMapLinearFilter', function () {
          return Ie;
        }),
        r.d(t, 'LinearFilter', function () {
          return De;
        }),
        r.d(t, 'LinearMipMapNearestFilter', function () {
          return Be;
        }),
        r.d(t, 'LinearMipMapLinearFilter', function () {
          return Ne;
        }),
        r.d(t, 'UnsignedByteType', function () {
          return Ue;
        }),
        r.d(t, 'ByteType', function () {
          return Ge;
        }),
        r.d(t, 'ShortType', function () {
          return Fe;
        }),
        r.d(t, 'UnsignedShortType', function () {
          return ze;
        }),
        r.d(t, 'IntType', function () {
          return He;
        }),
        r.d(t, 'UnsignedIntType', function () {
          return ke;
        }),
        r.d(t, 'FloatType', function () {
          return Ve;
        }),
        r.d(t, 'HalfFloatType', function () {
          return je;
        }),
        r.d(t, 'UnsignedShort4444Type', function () {
          return We;
        }),
        r.d(t, 'UnsignedShort5551Type', function () {
          return qe;
        }),
        r.d(t, 'UnsignedShort565Type', function () {
          return Xe;
        }),
        r.d(t, 'UnsignedInt248Type', function () {
          return Ye;
        }),
        r.d(t, 'AlphaFormat', function () {
          return Je;
        }),
        r.d(t, 'RGBFormat', function () {
          return Ze;
        }),
        r.d(t, 'RGBAFormat', function () {
          return Ke;
        }),
        r.d(t, 'LuminanceFormat', function () {
          return Qe;
        }),
        r.d(t, 'LuminanceAlphaFormat', function () {
          return $e;
        }),
        r.d(t, 'RGBEFormat', function () {
          return et;
        }),
        r.d(t, 'DepthFormat', function () {
          return tt;
        }),
        r.d(t, 'DepthStencilFormat', function () {
          return rt;
        }),
        r.d(t, 'RedFormat', function () {
          return nt;
        }),
        r.d(t, 'RGB_S3TC_DXT1_Format', function () {
          return it;
        }),
        r.d(t, 'RGBA_S3TC_DXT1_Format', function () {
          return at;
        }),
        r.d(t, 'RGBA_S3TC_DXT3_Format', function () {
          return ot;
        }),
        r.d(t, 'RGBA_S3TC_DXT5_Format', function () {
          return st;
        }),
        r.d(t, 'RGB_PVRTC_4BPPV1_Format', function () {
          return ct;
        }),
        r.d(t, 'RGB_PVRTC_2BPPV1_Format', function () {
          return ut;
        }),
        r.d(t, 'RGBA_PVRTC_4BPPV1_Format', function () {
          return lt;
        }),
        r.d(t, 'RGBA_PVRTC_2BPPV1_Format', function () {
          return ht;
        }),
        r.d(t, 'RGB_ETC1_Format', function () {
          return dt;
        }),
        r.d(t, 'RGBA_ASTC_4x4_Format', function () {
          return pt;
        }),
        r.d(t, 'RGBA_ASTC_5x4_Format', function () {
          return ft;
        }),
        r.d(t, 'RGBA_ASTC_5x5_Format', function () {
          return mt;
        }),
        r.d(t, 'RGBA_ASTC_6x5_Format', function () {
          return vt;
        }),
        r.d(t, 'RGBA_ASTC_6x6_Format', function () {
          return gt;
        }),
        r.d(t, 'RGBA_ASTC_8x5_Format', function () {
          return yt;
        }),
        r.d(t, 'RGBA_ASTC_8x6_Format', function () {
          return xt;
        }),
        r.d(t, 'RGBA_ASTC_8x8_Format', function () {
          return bt;
        }),
        r.d(t, 'RGBA_ASTC_10x5_Format', function () {
          return wt;
        }),
        r.d(t, 'RGBA_ASTC_10x6_Format', function () {
          return _t;
        }),
        r.d(t, 'RGBA_ASTC_10x8_Format', function () {
          return Mt;
        }),
        r.d(t, 'RGBA_ASTC_10x10_Format', function () {
          return St;
        }),
        r.d(t, 'RGBA_ASTC_12x10_Format', function () {
          return Et;
        }),
        r.d(t, 'RGBA_ASTC_12x12_Format', function () {
          return Tt;
        }),
        r.d(t, 'LoopOnce', function () {
          return At;
        }),
        r.d(t, 'LoopRepeat', function () {
          return Lt;
        }),
        r.d(t, 'LoopPingPong', function () {
          return Rt;
        }),
        r.d(t, 'InterpolateDiscrete', function () {
          return Ct;
        }),
        r.d(t, 'InterpolateLinear', function () {
          return Pt;
        }),
        r.d(t, 'InterpolateSmooth', function () {
          return Ot;
        }),
        r.d(t, 'ZeroCurvatureEnding', function () {
          return It;
        }),
        r.d(t, 'ZeroSlopeEnding', function () {
          return Dt;
        }),
        r.d(t, 'WrapAroundEnding', function () {
          return Bt;
        }),
        r.d(t, 'TrianglesDrawMode', function () {
          return Nt;
        }),
        r.d(t, 'TriangleStripDrawMode', function () {
          return Ut;
        }),
        r.d(t, 'TriangleFanDrawMode', function () {
          return Gt;
        }),
        r.d(t, 'LinearEncoding', function () {
          return Ft;
        }),
        r.d(t, 'sRGBEncoding', function () {
          return zt;
        }),
        r.d(t, 'GammaEncoding', function () {
          return Ht;
        }),
        r.d(t, 'RGBEEncoding', function () {
          return kt;
        }),
        r.d(t, 'LogLuvEncoding', function () {
          return Vt;
        }),
        r.d(t, 'RGBM7Encoding', function () {
          return jt;
        }),
        r.d(t, 'RGBM16Encoding', function () {
          return Wt;
        }),
        r.d(t, 'RGBDEncoding', function () {
          return qt;
        }),
        r.d(t, 'BasicDepthPacking', function () {
          return Xt;
        }),
        r.d(t, 'RGBADepthPacking', function () {
          return Yt;
        }),
        r.d(t, 'TangentSpaceNormalMap', function () {
          return Jt;
        }),
        r.d(t, 'ObjectSpaceNormalMap', function () {
          return Zt;
        }),
        r.d(t, 'Face4', function () {
          return tl;
        }),
        r.d(t, 'LineStrip', function () {
          return rl;
        }),
        r.d(t, 'LinePieces', function () {
          return nl;
        }),
        r.d(t, 'MeshFaceMaterial', function () {
          return il;
        }),
        r.d(t, 'MultiMaterial', function () {
          return al;
        }),
        r.d(t, 'PointCloud', function () {
          return ol;
        }),
        r.d(t, 'Particle', function () {
          return sl;
        }),
        r.d(t, 'ParticleSystem', function () {
          return cl;
        }),
        r.d(t, 'PointCloudMaterial', function () {
          return ul;
        }),
        r.d(t, 'ParticleBasicMaterial', function () {
          return ll;
        }),
        r.d(t, 'ParticleSystemMaterial', function () {
          return hl;
        }),
        r.d(t, 'Vertex', function () {
          return dl;
        }),
        r.d(t, 'DynamicBufferAttribute', function () {
          return pl;
        }),
        r.d(t, 'Int8Attribute', function () {
          return fl;
        }),
        r.d(t, 'Uint8Attribute', function () {
          return ml;
        }),
        r.d(t, 'Uint8ClampedAttribute', function () {
          return vl;
        }),
        r.d(t, 'Int16Attribute', function () {
          return gl;
        }),
        r.d(t, 'Uint16Attribute', function () {
          return yl;
        }),
        r.d(t, 'Int32Attribute', function () {
          return xl;
        }),
        r.d(t, 'Uint32Attribute', function () {
          return bl;
        }),
        r.d(t, 'Float32Attribute', function () {
          return wl;
        }),
        r.d(t, 'Float64Attribute', function () {
          return _l;
        }),
        r.d(t, 'ClosedSplineCurve3', function () {
          return Ml;
        }),
        r.d(t, 'SplineCurve3', function () {
          return Sl;
        }),
        r.d(t, 'Spline', function () {
          return El;
        }),
        r.d(t, 'AxisHelper', function () {
          return Tl;
        }),
        r.d(t, 'BoundingBoxHelper', function () {
          return Al;
        }),
        r.d(t, 'EdgesHelper', function () {
          return Ll;
        }),
        r.d(t, 'WireframeHelper', function () {
          return Rl;
        }),
        r.d(t, 'XHRLoader', function () {
          return Cl;
        }),
        r.d(t, 'BinaryTextureLoader', function () {
          return Pl;
        }),
        r.d(t, 'GeometryUtils', function () {
          return Ol;
        }),
        r.d(t, 'Projector', function () {
          return Il;
        }),
        r.d(t, 'CanvasRenderer', function () {
          return Dl;
        }),
        r.d(t, 'JSONLoader', function () {
          return Bl;
        }),
        r.d(t, 'SceneUtils', function () {
          return Nl;
        }),
        r.d(t, 'LensFlare', function () {
          return Ul;
        }),
        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
        void 0 === Number.isInteger &&
          (Number.isInteger = function (e) {
            return 'number' == typeof e && isFinite(e) && Math.floor(e) === e;
          }),
        void 0 === Math.sign &&
          (Math.sign = function (e) {
            return e < 0 ? -1 : e > 0 ? 1 : +e;
          }),
        'name' in Function.prototype == !1 &&
          Object.defineProperty(Function.prototype, 'name', {
            get: function () {
              return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
            },
          }),
        void 0 === Object.assign &&
          (Object.assign = function (e) {
            if (null == e) throw new TypeError('Cannot convert undefined or null to object');
            for (var t = Object(e), r = 1; r < arguments.length; r++) {
              var n = arguments[r];
              if (null != n)
                for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
            }
            return t;
          }),
        Object.assign(n.prototype, {
          addEventListener: function (e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var r = this._listeners;
            void 0 === r[e] && (r[e] = []), -1 === r[e].indexOf(t) && r[e].push(t);
          },
          hasEventListener: function (e, t) {
            if (void 0 === this._listeners) return !1;
            var r = this._listeners;
            return void 0 !== r[e] && -1 !== r[e].indexOf(t);
          },
          removeEventListener: function (e, t) {
            if (void 0 !== this._listeners) {
              var r = this._listeners[e];
              if (void 0 !== r) {
                var n = r.indexOf(t);
                -1 !== n && r.splice(n, 1);
              }
            }
          },
          dispatchEvent: function (e) {
            if (void 0 !== this._listeners) {
              var t = this._listeners[e.type];
              if (void 0 !== t) {
                e.target = this;
                for (var r = t.slice(0), n = 0, i = r.length; n < i; n++) r[n].call(this, e);
              }
            }
          },
        });
      var i,
        a,
        o,
        s,
        c,
        u,
        l,
        h,
        d,
        p,
        f,
        m,
        v = '101',
        g = { LEFT: 0, MIDDLE: 1, RIGHT: 2 },
        y = 0,
        x = 1,
        b = 2,
        w = 3,
        _ = 0,
        M = 1,
        S = 0,
        E = 1,
        T = 2,
        A = 0,
        L = 1,
        R = 2,
        C = 1,
        P = 2,
        O = 0,
        I = 1,
        D = 2,
        B = 0,
        N = 1,
        U = 2,
        G = 3,
        F = 4,
        z = 5,
        H = 100,
        k = 101,
        V = 102,
        j = 103,
        W = 104,
        q = 200,
        X = 201,
        Y = 202,
        J = 203,
        Z = 204,
        K = 205,
        Q = 206,
        $ = 207,
        ee = 208,
        te = 209,
        re = 210,
        ne = 0,
        ie = 1,
        ae = 2,
        oe = 3,
        se = 4,
        ce = 5,
        ue = 6,
        le = 7,
        he = 0,
        de = 1,
        pe = 2,
        fe = 0,
        me = 1,
        ve = 2,
        ge = 3,
        ye = 4,
        xe = 5,
        be = 300,
        we = 301,
        _e = 302,
        Me = 303,
        Se = 304,
        Ee = 305,
        Te = 306,
        Ae = 307,
        Le = 1e3,
        Re = 1001,
        Ce = 1002,
        Pe = 1003,
        Oe = 1004,
        Ie = 1005,
        De = 1006,
        Be = 1007,
        Ne = 1008,
        Ue = 1009,
        Ge = 1010,
        Fe = 1011,
        ze = 1012,
        He = 1013,
        ke = 1014,
        Ve = 1015,
        je = 1016,
        We = 1017,
        qe = 1018,
        Xe = 1019,
        Ye = 1020,
        Je = 1021,
        Ze = 1022,
        Ke = 1023,
        Qe = 1024,
        $e = 1025,
        et = Ke,
        tt = 1026,
        rt = 1027,
        nt = 1028,
        it = 33776,
        at = 33777,
        ot = 33778,
        st = 33779,
        ct = 35840,
        ut = 35841,
        lt = 35842,
        ht = 35843,
        dt = 36196,
        pt = 37808,
        ft = 37809,
        mt = 37810,
        vt = 37811,
        gt = 37812,
        yt = 37813,
        xt = 37814,
        bt = 37815,
        wt = 37816,
        _t = 37817,
        Mt = 37818,
        St = 37819,
        Et = 37820,
        Tt = 37821,
        At = 2200,
        Lt = 2201,
        Rt = 2202,
        Ct = 2300,
        Pt = 2301,
        Ot = 2302,
        It = 2400,
        Dt = 2401,
        Bt = 2402,
        Nt = 0,
        Ut = 1,
        Gt = 2,
        Ft = 3e3,
        zt = 3001,
        Ht = 3007,
        kt = 3002,
        Vt = 3003,
        jt = 3004,
        Wt = 3005,
        qt = 3006,
        Xt = 3200,
        Yt = 3201,
        Jt = 0,
        Zt = 1,
        Kt = {
          DEG2RAD: Math.PI / 180,
          RAD2DEG: 180 / Math.PI,
          generateUUID: (function () {
            for (var e = [], t = 0; t < 256; t++) e[t] = (t < 16 ? '0' : '') + t.toString(16);
            return function () {
              var t = (4294967295 * Math.random()) | 0,
                r = (4294967295 * Math.random()) | 0,
                n = (4294967295 * Math.random()) | 0,
                i = (4294967295 * Math.random()) | 0;
              return (
                e[255 & t] +
                e[(t >> 8) & 255] +
                e[(t >> 16) & 255] +
                e[(t >> 24) & 255] +
                '-' +
                e[255 & r] +
                e[(r >> 8) & 255] +
                '-' +
                e[((r >> 16) & 15) | 64] +
                e[(r >> 24) & 255] +
                '-' +
                e[(63 & n) | 128] +
                e[(n >> 8) & 255] +
                '-' +
                e[(n >> 16) & 255] +
                e[(n >> 24) & 255] +
                e[255 & i] +
                e[(i >> 8) & 255] +
                e[(i >> 16) & 255] +
                e[(i >> 24) & 255]
              ).toUpperCase();
            };
          })(),
          clamp: function (e, t, r) {
            return Math.max(t, Math.min(r, e));
          },
          euclideanModulo: function (e, t) {
            return ((e % t) + t) % t;
          },
          mapLinear: function (e, t, r, n, i) {
            return n + ((e - t) * (i - n)) / (r - t);
          },
          lerp: function (e, t, r) {
            return (1 - r) * e + r * t;
          },
          smoothstep: function (e, t, r) {
            return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t)) * e * (3 - 2 * e);
          },
          smootherstep: function (e, t, r) {
            return e <= t
              ? 0
              : e >= r
              ? 1
              : (e = (e - t) / (r - t)) * e * e * (e * (6 * e - 15) + 10);
          },
          randInt: function (e, t) {
            return e + Math.floor(Math.random() * (t - e + 1));
          },
          randFloat: function (e, t) {
            return e + Math.random() * (t - e);
          },
          randFloatSpread: function (e) {
            return e * (0.5 - Math.random());
          },
          degToRad: function (e) {
            return e * Kt.DEG2RAD;
          },
          radToDeg: function (e) {
            return e * Kt.RAD2DEG;
          },
          isPowerOfTwo: function (e) {
            return 0 == (e & (e - 1)) && 0 !== e;
          },
          ceilPowerOfTwo: function (e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
          },
          floorPowerOfTwo: function (e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
          },
        };
      function Qt(e, t) {
        (this.x = e || 0), (this.y = t || 0);
      }
      function $t() {
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.',
            );
      }
      function er(e, t, r, n) {
        (this._x = e || 0),
          (this._y = t || 0),
          (this._z = r || 0),
          (this._w = void 0 !== n ? n : 1);
      }
      function tr(e, t, r) {
        (this.x = e || 0), (this.y = t || 0), (this.z = r || 0);
      }
      function rr() {
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.',
            );
      }
      Object.defineProperties(Qt.prototype, {
        width: {
          get: function () {
            return this.x;
          },
          set: function (e) {
            this.x = e;
          },
        },
        height: {
          get: function () {
            return this.y;
          },
          set: function (e) {
            this.y = e;
          },
        },
      }),
        Object.assign(Qt.prototype, {
          isVector2: !0,
          set: function (e, t) {
            return (this.x = e), (this.y = t), this;
          },
          setScalar: function (e) {
            return (this.x = e), (this.y = e), this;
          },
          setX: function (e) {
            return (this.x = e), this;
          },
          setY: function (e) {
            return (this.y = e), this;
          },
          setComponent: function (e, t) {
            switch (e) {
              case 0:
                this.x = t;
                break;
              case 1:
                this.y = t;
                break;
              default:
                throw new Error('index is out of range: ' + e);
            }
            return this;
          },
          getComponent: function (e) {
            switch (e) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw new Error('index is out of range: ' + e);
            }
          },
          clone: function () {
            return new this.constructor(this.x, this.y);
          },
          copy: function (e) {
            return (this.x = e.x), (this.y = e.y), this;
          },
          add: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                ),
                this.addVectors(e, t))
              : ((this.x += e.x), (this.y += e.y), this);
          },
          addScalar: function (e) {
            return (this.x += e), (this.y += e), this;
          },
          addVectors: function (e, t) {
            return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
          },
          addScaledVector: function (e, t) {
            return (this.x += e.x * t), (this.y += e.y * t), this;
          },
          sub: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                ),
                this.subVectors(e, t))
              : ((this.x -= e.x), (this.y -= e.y), this);
          },
          subScalar: function (e) {
            return (this.x -= e), (this.y -= e), this;
          },
          subVectors: function (e, t) {
            return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
          },
          multiply: function (e) {
            return (this.x *= e.x), (this.y *= e.y), this;
          },
          multiplyScalar: function (e) {
            return (this.x *= e), (this.y *= e), this;
          },
          divide: function (e) {
            return (this.x /= e.x), (this.y /= e.y), this;
          },
          divideScalar: function (e) {
            return this.multiplyScalar(1 / e);
          },
          applyMatrix3: function (e) {
            var t = this.x,
              r = this.y,
              n = e.elements;
            return (
              (this.x = n[0] * t + n[3] * r + n[6]), (this.y = n[1] * t + n[4] * r + n[7]), this
            );
          },
          min: function (e) {
            return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this;
          },
          max: function (e) {
            return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this;
          },
          clamp: function (e, t) {
            return (
              (this.x = Math.max(e.x, Math.min(t.x, this.x))),
              (this.y = Math.max(e.y, Math.min(t.y, this.y))),
              this
            );
          },
          clampScalar:
            ((i = new Qt()),
            (a = new Qt()),
            function (e, t) {
              return i.set(e, e), a.set(t, t), this.clamp(i, a);
            }),
          clampLength: function (e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
          },
          floor: function () {
            return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
          },
          ceil: function () {
            return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
          },
          round: function () {
            return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
          },
          roundToZero: function () {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              this
            );
          },
          negate: function () {
            return (this.x = -this.x), (this.y = -this.y), this;
          },
          dot: function (e) {
            return this.x * e.x + this.y * e.y;
          },
          cross: function (e) {
            return this.x * e.y - this.y * e.x;
          },
          lengthSq: function () {
            return this.x * this.x + this.y * this.y;
          },
          length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          },
          manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y);
          },
          normalize: function () {
            return this.divideScalar(this.length() || 1);
          },
          angle: function () {
            var e = Math.atan2(this.y, this.x);
            return e < 0 && (e += 2 * Math.PI), e;
          },
          distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e));
          },
          distanceToSquared: function (e) {
            var t = this.x - e.x,
              r = this.y - e.y;
            return t * t + r * r;
          },
          manhattanDistanceTo: function (e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
          },
          setLength: function (e) {
            return this.normalize().multiplyScalar(e);
          },
          lerp: function (e, t) {
            return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
          },
          lerpVectors: function (e, t, r) {
            return this.subVectors(t, e).multiplyScalar(r).add(e);
          },
          equals: function (e) {
            return e.x === this.x && e.y === this.y;
          },
          fromArray: function (e, t) {
            return void 0 === t && (t = 0), (this.x = e[t]), (this.y = e[t + 1]), this;
          },
          toArray: function (e, t) {
            return (
              void 0 === e && (e = []),
              void 0 === t && (t = 0),
              (e[t] = this.x),
              (e[t + 1] = this.y),
              e
            );
          },
          fromBufferAttribute: function (e, t, r) {
            return (
              void 0 !== r &&
                console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().'),
              (this.x = e.getX(t)),
              (this.y = e.getY(t)),
              this
            );
          },
          rotateAround: function (e, t) {
            var r = Math.cos(t),
              n = Math.sin(t),
              i = this.x - e.x,
              a = this.y - e.y;
            return (this.x = i * r - a * n + e.x), (this.y = i * n + a * r + e.y), this;
          },
        }),
        Object.assign($t.prototype, {
          isMatrix4: !0,
          set: function (e, t, r, n, i, a, o, s, c, u, l, h, d, p, f, m) {
            var v = this.elements;
            return (
              (v[0] = e),
              (v[4] = t),
              (v[8] = r),
              (v[12] = n),
              (v[1] = i),
              (v[5] = a),
              (v[9] = o),
              (v[13] = s),
              (v[2] = c),
              (v[6] = u),
              (v[10] = l),
              (v[14] = h),
              (v[3] = d),
              (v[7] = p),
              (v[11] = f),
              (v[15] = m),
              this
            );
          },
          identity: function () {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
          },
          clone: function () {
            return new $t().fromArray(this.elements);
          },
          copy: function (e) {
            var t = this.elements,
              r = e.elements;
            return (
              (t[0] = r[0]),
              (t[1] = r[1]),
              (t[2] = r[2]),
              (t[3] = r[3]),
              (t[4] = r[4]),
              (t[5] = r[5]),
              (t[6] = r[6]),
              (t[7] = r[7]),
              (t[8] = r[8]),
              (t[9] = r[9]),
              (t[10] = r[10]),
              (t[11] = r[11]),
              (t[12] = r[12]),
              (t[13] = r[13]),
              (t[14] = r[14]),
              (t[15] = r[15]),
              this
            );
          },
          copyPosition: function (e) {
            var t = this.elements,
              r = e.elements;
            return (t[12] = r[12]), (t[13] = r[13]), (t[14] = r[14]), this;
          },
          extractBasis: function (e, t, r) {
            return (
              e.setFromMatrixColumn(this, 0),
              t.setFromMatrixColumn(this, 1),
              r.setFromMatrixColumn(this, 2),
              this
            );
          },
          makeBasis: function (e, t, r) {
            return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1), this;
          },
          extractRotation:
            ((p = new tr()),
            function (e) {
              var t = this.elements,
                r = e.elements,
                n = 1 / p.setFromMatrixColumn(e, 0).length(),
                i = 1 / p.setFromMatrixColumn(e, 1).length(),
                a = 1 / p.setFromMatrixColumn(e, 2).length();
              return (
                (t[0] = r[0] * n),
                (t[1] = r[1] * n),
                (t[2] = r[2] * n),
                (t[3] = 0),
                (t[4] = r[4] * i),
                (t[5] = r[5] * i),
                (t[6] = r[6] * i),
                (t[7] = 0),
                (t[8] = r[8] * a),
                (t[9] = r[9] * a),
                (t[10] = r[10] * a),
                (t[11] = 0),
                (t[12] = 0),
                (t[13] = 0),
                (t[14] = 0),
                (t[15] = 1),
                this
              );
            }),
          makeRotationFromEuler: function (e) {
            (e && e.isEuler) ||
              console.error(
                'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.',
              );
            var t = this.elements,
              r = e.x,
              n = e.y,
              i = e.z,
              a = Math.cos(r),
              o = Math.sin(r),
              s = Math.cos(n),
              c = Math.sin(n),
              u = Math.cos(i),
              l = Math.sin(i);
            if ('XYZ' === e.order) {
              var h = a * u,
                d = a * l,
                p = o * u,
                f = o * l;
              (t[0] = s * u),
                (t[4] = -s * l),
                (t[8] = c),
                (t[1] = d + p * c),
                (t[5] = h - f * c),
                (t[9] = -o * s),
                (t[2] = f - h * c),
                (t[6] = p + d * c),
                (t[10] = a * s);
            } else if ('YXZ' === e.order) {
              var m = s * u,
                v = s * l,
                g = c * u,
                y = c * l;
              (t[0] = m + y * o),
                (t[4] = g * o - v),
                (t[8] = a * c),
                (t[1] = a * l),
                (t[5] = a * u),
                (t[9] = -o),
                (t[2] = v * o - g),
                (t[6] = y + m * o),
                (t[10] = a * s);
            } else if ('ZXY' === e.order) {
              (m = s * u), (v = s * l), (g = c * u), (y = c * l);
              (t[0] = m - y * o),
                (t[4] = -a * l),
                (t[8] = g + v * o),
                (t[1] = v + g * o),
                (t[5] = a * u),
                (t[9] = y - m * o),
                (t[2] = -a * c),
                (t[6] = o),
                (t[10] = a * s);
            } else if ('ZYX' === e.order) {
              (h = a * u), (d = a * l), (p = o * u), (f = o * l);
              (t[0] = s * u),
                (t[4] = p * c - d),
                (t[8] = h * c + f),
                (t[1] = s * l),
                (t[5] = f * c + h),
                (t[9] = d * c - p),
                (t[2] = -c),
                (t[6] = o * s),
                (t[10] = a * s);
            } else if ('YZX' === e.order) {
              var x = a * s,
                b = a * c,
                w = o * s,
                _ = o * c;
              (t[0] = s * u),
                (t[4] = _ - x * l),
                (t[8] = w * l + b),
                (t[1] = l),
                (t[5] = a * u),
                (t[9] = -o * u),
                (t[2] = -c * u),
                (t[6] = b * l + w),
                (t[10] = x - _ * l);
            } else if ('XZY' === e.order) {
              (x = a * s), (b = a * c), (w = o * s), (_ = o * c);
              (t[0] = s * u),
                (t[4] = -l),
                (t[8] = c * u),
                (t[1] = x * l + _),
                (t[5] = a * u),
                (t[9] = b * l - w),
                (t[2] = w * l - b),
                (t[6] = o * u),
                (t[10] = _ * l + x);
            }
            return (
              (t[3] = 0),
              (t[7] = 0),
              (t[11] = 0),
              (t[12] = 0),
              (t[13] = 0),
              (t[14] = 0),
              (t[15] = 1),
              this
            );
          },
          makeRotationFromQuaternion:
            ((h = new tr(0, 0, 0)),
            (d = new tr(1, 1, 1)),
            function (e) {
              return this.compose(h, e, d);
            }),
          lookAt:
            ((c = new tr()),
            (u = new tr()),
            (l = new tr()),
            function (e, t, r) {
              var n = this.elements;
              return (
                l.subVectors(e, t),
                0 === l.lengthSq() && (l.z = 1),
                l.normalize(),
                c.crossVectors(r, l),
                0 === c.lengthSq() &&
                  (1 === Math.abs(r.z) ? (l.x += 1e-4) : (l.z += 1e-4),
                  l.normalize(),
                  c.crossVectors(r, l)),
                c.normalize(),
                u.crossVectors(l, c),
                (n[0] = c.x),
                (n[4] = u.x),
                (n[8] = l.x),
                (n[1] = c.y),
                (n[5] = u.y),
                (n[9] = l.y),
                (n[2] = c.z),
                (n[6] = u.z),
                (n[10] = l.z),
                this
              );
            }),
          multiply: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.',
                ),
                this.multiplyMatrices(e, t))
              : this.multiplyMatrices(this, e);
          },
          premultiply: function (e) {
            return this.multiplyMatrices(e, this);
          },
          multiplyMatrices: function (e, t) {
            var r = e.elements,
              n = t.elements,
              i = this.elements,
              a = r[0],
              o = r[4],
              s = r[8],
              c = r[12],
              u = r[1],
              l = r[5],
              h = r[9],
              d = r[13],
              p = r[2],
              f = r[6],
              m = r[10],
              v = r[14],
              g = r[3],
              y = r[7],
              x = r[11],
              b = r[15],
              w = n[0],
              _ = n[4],
              M = n[8],
              S = n[12],
              E = n[1],
              T = n[5],
              A = n[9],
              L = n[13],
              R = n[2],
              C = n[6],
              P = n[10],
              O = n[14],
              I = n[3],
              D = n[7],
              B = n[11],
              N = n[15];
            return (
              (i[0] = a * w + o * E + s * R + c * I),
              (i[4] = a * _ + o * T + s * C + c * D),
              (i[8] = a * M + o * A + s * P + c * B),
              (i[12] = a * S + o * L + s * O + c * N),
              (i[1] = u * w + l * E + h * R + d * I),
              (i[5] = u * _ + l * T + h * C + d * D),
              (i[9] = u * M + l * A + h * P + d * B),
              (i[13] = u * S + l * L + h * O + d * N),
              (i[2] = p * w + f * E + m * R + v * I),
              (i[6] = p * _ + f * T + m * C + v * D),
              (i[10] = p * M + f * A + m * P + v * B),
              (i[14] = p * S + f * L + m * O + v * N),
              (i[3] = g * w + y * E + x * R + b * I),
              (i[7] = g * _ + y * T + x * C + b * D),
              (i[11] = g * M + y * A + x * P + b * B),
              (i[15] = g * S + y * L + x * O + b * N),
              this
            );
          },
          multiplyScalar: function (e) {
            var t = this.elements;
            return (
              (t[0] *= e),
              (t[4] *= e),
              (t[8] *= e),
              (t[12] *= e),
              (t[1] *= e),
              (t[5] *= e),
              (t[9] *= e),
              (t[13] *= e),
              (t[2] *= e),
              (t[6] *= e),
              (t[10] *= e),
              (t[14] *= e),
              (t[3] *= e),
              (t[7] *= e),
              (t[11] *= e),
              (t[15] *= e),
              this
            );
          },
          applyToBufferAttribute: (function () {
            var e = new tr();
            return function (t) {
              for (var r = 0, n = t.count; r < n; r++)
                (e.x = t.getX(r)),
                  (e.y = t.getY(r)),
                  (e.z = t.getZ(r)),
                  e.applyMatrix4(this),
                  t.setXYZ(r, e.x, e.y, e.z);
              return t;
            };
          })(),
          determinant: function () {
            var e = this.elements,
              t = e[0],
              r = e[4],
              n = e[8],
              i = e[12],
              a = e[1],
              o = e[5],
              s = e[9],
              c = e[13],
              u = e[2],
              l = e[6],
              h = e[10],
              d = e[14];
            return (
              e[3] * (+i * s * l - n * c * l - i * o * h + r * c * h + n * o * d - r * s * d) +
              e[7] * (+t * s * d - t * c * h + i * a * h - n * a * d + n * c * u - i * s * u) +
              e[11] * (+t * c * l - t * o * d - i * a * l + r * a * d + i * o * u - r * c * u) +
              e[15] * (-n * o * u - t * s * l + t * o * h + n * a * l - r * a * h + r * s * u)
            );
          },
          transpose: function () {
            var e,
              t = this.elements;
            return (
              (e = t[1]),
              (t[1] = t[4]),
              (t[4] = e),
              (e = t[2]),
              (t[2] = t[8]),
              (t[8] = e),
              (e = t[6]),
              (t[6] = t[9]),
              (t[9] = e),
              (e = t[3]),
              (t[3] = t[12]),
              (t[12] = e),
              (e = t[7]),
              (t[7] = t[13]),
              (t[13] = e),
              (e = t[11]),
              (t[11] = t[14]),
              (t[14] = e),
              this
            );
          },
          setPosition: function (e) {
            var t = this.elements;
            return (t[12] = e.x), (t[13] = e.y), (t[14] = e.z), this;
          },
          getInverse: function (e, t) {
            var r = this.elements,
              n = e.elements,
              i = n[0],
              a = n[1],
              o = n[2],
              s = n[3],
              c = n[4],
              u = n[5],
              l = n[6],
              h = n[7],
              d = n[8],
              p = n[9],
              f = n[10],
              m = n[11],
              v = n[12],
              g = n[13],
              y = n[14],
              x = n[15],
              b = p * y * h - g * f * h + g * l * m - u * y * m - p * l * x + u * f * x,
              w = v * f * h - d * y * h - v * l * m + c * y * m + d * l * x - c * f * x,
              _ = d * g * h - v * p * h + v * u * m - c * g * m - d * u * x + c * p * x,
              M = v * p * l - d * g * l - v * u * f + c * g * f + d * u * y - c * p * y,
              S = i * b + a * w + o * _ + s * M;
            if (0 === S) {
              var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
              if (!0 === t) throw new Error(E);
              return console.warn(E), this.identity();
            }
            var T = 1 / S;
            return (
              (r[0] = b * T),
              (r[1] = (g * f * s - p * y * s - g * o * m + a * y * m + p * o * x - a * f * x) * T),
              (r[2] = (u * y * s - g * l * s + g * o * h - a * y * h - u * o * x + a * l * x) * T),
              (r[3] = (p * l * s - u * f * s - p * o * h + a * f * h + u * o * m - a * l * m) * T),
              (r[4] = w * T),
              (r[5] = (d * y * s - v * f * s + v * o * m - i * y * m - d * o * x + i * f * x) * T),
              (r[6] = (v * l * s - c * y * s - v * o * h + i * y * h + c * o * x - i * l * x) * T),
              (r[7] = (c * f * s - d * l * s + d * o * h - i * f * h - c * o * m + i * l * m) * T),
              (r[8] = _ * T),
              (r[9] = (v * p * s - d * g * s - v * a * m + i * g * m + d * a * x - i * p * x) * T),
              (r[10] = (c * g * s - v * u * s + v * a * h - i * g * h - c * a * x + i * u * x) * T),
              (r[11] = (d * u * s - c * p * s - d * a * h + i * p * h + c * a * m - i * u * m) * T),
              (r[12] = M * T),
              (r[13] = (d * g * o - v * p * o + v * a * f - i * g * f - d * a * y + i * p * y) * T),
              (r[14] = (v * u * o - c * g * o - v * a * l + i * g * l + c * a * y - i * u * y) * T),
              (r[15] = (c * p * o - d * u * o + d * a * l - i * p * l - c * a * f + i * u * f) * T),
              this
            );
          },
          scale: function (e) {
            var t = this.elements,
              r = e.x,
              n = e.y,
              i = e.z;
            return (
              (t[0] *= r),
              (t[4] *= n),
              (t[8] *= i),
              (t[1] *= r),
              (t[5] *= n),
              (t[9] *= i),
              (t[2] *= r),
              (t[6] *= n),
              (t[10] *= i),
              (t[3] *= r),
              (t[7] *= n),
              (t[11] *= i),
              this
            );
          },
          getMaxScaleOnAxis: function () {
            var e = this.elements,
              t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
              r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
              n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, r, n));
          },
          makeTranslation: function (e, t, r) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1), this;
          },
          makeRotationX: function (e) {
            var t = Math.cos(e),
              r = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
          },
          makeRotationY: function (e) {
            var t = Math.cos(e),
              r = Math.sin(e);
            return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
          },
          makeRotationZ: function (e) {
            var t = Math.cos(e),
              r = Math.sin(e);
            return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
          },
          makeRotationAxis: function (e, t) {
            var r = Math.cos(t),
              n = Math.sin(t),
              i = 1 - r,
              a = e.x,
              o = e.y,
              s = e.z,
              c = i * a,
              u = i * o;
            return (
              this.set(
                c * a + r,
                c * o - n * s,
                c * s + n * o,
                0,
                c * o + n * s,
                u * o + r,
                u * s - n * a,
                0,
                c * s - n * o,
                u * s + n * a,
                i * s * s + r,
                0,
                0,
                0,
                0,
                1,
              ),
              this
            );
          },
          makeScale: function (e, t, r) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
          },
          makeShear: function (e, t, r) {
            return this.set(1, t, r, 0, e, 1, r, 0, e, t, 1, 0, 0, 0, 0, 1), this;
          },
          compose: function (e, t, r) {
            var n = this.elements,
              i = t._x,
              a = t._y,
              o = t._z,
              s = t._w,
              c = i + i,
              u = a + a,
              l = o + o,
              h = i * c,
              d = i * u,
              p = i * l,
              f = a * u,
              m = a * l,
              v = o * l,
              g = s * c,
              y = s * u,
              x = s * l,
              b = r.x,
              w = r.y,
              _ = r.z;
            return (
              (n[0] = (1 - (f + v)) * b),
              (n[1] = (d + x) * b),
              (n[2] = (p - y) * b),
              (n[3] = 0),
              (n[4] = (d - x) * w),
              (n[5] = (1 - (h + v)) * w),
              (n[6] = (m + g) * w),
              (n[7] = 0),
              (n[8] = (p + y) * _),
              (n[9] = (m - g) * _),
              (n[10] = (1 - (h + f)) * _),
              (n[11] = 0),
              (n[12] = e.x),
              (n[13] = e.y),
              (n[14] = e.z),
              (n[15] = 1),
              this
            );
          },
          decompose:
            ((o = new tr()),
            (s = new $t()),
            function (e, t, r) {
              var n = this.elements,
                i = o.set(n[0], n[1], n[2]).length(),
                a = o.set(n[4], n[5], n[6]).length(),
                c = o.set(n[8], n[9], n[10]).length();
              this.determinant() < 0 && (i = -i),
                (e.x = n[12]),
                (e.y = n[13]),
                (e.z = n[14]),
                s.copy(this);
              var u = 1 / i,
                l = 1 / a,
                h = 1 / c;
              return (
                (s.elements[0] *= u),
                (s.elements[1] *= u),
                (s.elements[2] *= u),
                (s.elements[4] *= l),
                (s.elements[5] *= l),
                (s.elements[6] *= l),
                (s.elements[8] *= h),
                (s.elements[9] *= h),
                (s.elements[10] *= h),
                t.setFromRotationMatrix(s),
                (r.x = i),
                (r.y = a),
                (r.z = c),
                this
              );
            }),
          makePerspective: function (e, t, r, n, i, a) {
            void 0 === a &&
              console.warn(
                'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.',
              );
            var o = this.elements,
              s = (2 * i) / (t - e),
              c = (2 * i) / (r - n),
              u = (t + e) / (t - e),
              l = (r + n) / (r - n),
              h = -(a + i) / (a - i),
              d = (-2 * a * i) / (a - i);
            return (
              (o[0] = s),
              (o[4] = 0),
              (o[8] = u),
              (o[12] = 0),
              (o[1] = 0),
              (o[5] = c),
              (o[9] = l),
              (o[13] = 0),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = h),
              (o[14] = d),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = -1),
              (o[15] = 0),
              this
            );
          },
          makeOrthographic: function (e, t, r, n, i, a) {
            var o = this.elements,
              s = 1 / (t - e),
              c = 1 / (r - n),
              u = 1 / (a - i),
              l = (t + e) * s,
              h = (r + n) * c,
              d = (a + i) * u;
            return (
              (o[0] = 2 * s),
              (o[4] = 0),
              (o[8] = 0),
              (o[12] = -l),
              (o[1] = 0),
              (o[5] = 2 * c),
              (o[9] = 0),
              (o[13] = -h),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = -2 * u),
              (o[14] = -d),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = 0),
              (o[15] = 1),
              this
            );
          },
          equals: function (e) {
            for (var t = this.elements, r = e.elements, n = 0; n < 16; n++)
              if (t[n] !== r[n]) return !1;
            return !0;
          },
          fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var r = 0; r < 16; r++) this.elements[r] = e[r + t];
            return this;
          },
          toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var r = this.elements;
            return (
              (e[t] = r[0]),
              (e[t + 1] = r[1]),
              (e[t + 2] = r[2]),
              (e[t + 3] = r[3]),
              (e[t + 4] = r[4]),
              (e[t + 5] = r[5]),
              (e[t + 6] = r[6]),
              (e[t + 7] = r[7]),
              (e[t + 8] = r[8]),
              (e[t + 9] = r[9]),
              (e[t + 10] = r[10]),
              (e[t + 11] = r[11]),
              (e[t + 12] = r[12]),
              (e[t + 13] = r[13]),
              (e[t + 14] = r[14]),
              (e[t + 15] = r[15]),
              e
            );
          },
        }),
        Object.assign(er, {
          slerp: function (e, t, r, n) {
            return r.copy(e).slerp(t, n);
          },
          slerpFlat: function (e, t, r, n, i, a, o) {
            var s = r[n + 0],
              c = r[n + 1],
              u = r[n + 2],
              l = r[n + 3],
              h = i[a + 0],
              d = i[a + 1],
              p = i[a + 2],
              f = i[a + 3];
            if (l !== f || s !== h || c !== d || u !== p) {
              var m = 1 - o,
                v = s * h + c * d + u * p + l * f,
                g = v >= 0 ? 1 : -1,
                y = 1 - v * v;
              if (y > Number.EPSILON) {
                var x = Math.sqrt(y),
                  b = Math.atan2(x, v * g);
                (m = Math.sin(m * b) / x), (o = Math.sin(o * b) / x);
              }
              var w = o * g;
              if (
                ((s = s * m + h * w),
                (c = c * m + d * w),
                (u = u * m + p * w),
                (l = l * m + f * w),
                m === 1 - o)
              ) {
                var _ = 1 / Math.sqrt(s * s + c * c + u * u + l * l);
                (s *= _), (c *= _), (u *= _), (l *= _);
              }
            }
            (e[t] = s), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = l);
          },
        }),
        Object.defineProperties(er.prototype, {
          x: {
            get: function () {
              return this._x;
            },
            set: function (e) {
              (this._x = e), this.onChangeCallback();
            },
          },
          y: {
            get: function () {
              return this._y;
            },
            set: function (e) {
              (this._y = e), this.onChangeCallback();
            },
          },
          z: {
            get: function () {
              return this._z;
            },
            set: function (e) {
              (this._z = e), this.onChangeCallback();
            },
          },
          w: {
            get: function () {
              return this._w;
            },
            set: function (e) {
              (this._w = e), this.onChangeCallback();
            },
          },
        }),
        Object.assign(er.prototype, {
          isQuaternion: !0,
          set: function (e, t, r, n) {
            return (
              (this._x = e),
              (this._y = t),
              (this._z = r),
              (this._w = n),
              this.onChangeCallback(),
              this
            );
          },
          clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w);
          },
          copy: function (e) {
            return (
              (this._x = e.x),
              (this._y = e.y),
              (this._z = e.z),
              (this._w = e.w),
              this.onChangeCallback(),
              this
            );
          },
          setFromEuler: function (e, t) {
            if (!e || !e.isEuler)
              throw new Error(
                'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.',
              );
            var r = e._x,
              n = e._y,
              i = e._z,
              a = e.order,
              o = Math.cos,
              s = Math.sin,
              c = o(r / 2),
              u = o(n / 2),
              l = o(i / 2),
              h = s(r / 2),
              d = s(n / 2),
              p = s(i / 2);
            return (
              'XYZ' === a
                ? ((this._x = h * u * l + c * d * p),
                  (this._y = c * d * l - h * u * p),
                  (this._z = c * u * p + h * d * l),
                  (this._w = c * u * l - h * d * p))
                : 'YXZ' === a
                ? ((this._x = h * u * l + c * d * p),
                  (this._y = c * d * l - h * u * p),
                  (this._z = c * u * p - h * d * l),
                  (this._w = c * u * l + h * d * p))
                : 'ZXY' === a
                ? ((this._x = h * u * l - c * d * p),
                  (this._y = c * d * l + h * u * p),
                  (this._z = c * u * p + h * d * l),
                  (this._w = c * u * l - h * d * p))
                : 'ZYX' === a
                ? ((this._x = h * u * l - c * d * p),
                  (this._y = c * d * l + h * u * p),
                  (this._z = c * u * p - h * d * l),
                  (this._w = c * u * l + h * d * p))
                : 'YZX' === a
                ? ((this._x = h * u * l + c * d * p),
                  (this._y = c * d * l + h * u * p),
                  (this._z = c * u * p - h * d * l),
                  (this._w = c * u * l - h * d * p))
                : 'XZY' === a &&
                  ((this._x = h * u * l - c * d * p),
                  (this._y = c * d * l - h * u * p),
                  (this._z = c * u * p + h * d * l),
                  (this._w = c * u * l + h * d * p)),
              !1 !== t && this.onChangeCallback(),
              this
            );
          },
          setFromAxisAngle: function (e, t) {
            var r = t / 2,
              n = Math.sin(r);
            return (
              (this._x = e.x * n),
              (this._y = e.y * n),
              (this._z = e.z * n),
              (this._w = Math.cos(r)),
              this.onChangeCallback(),
              this
            );
          },
          setFromRotationMatrix: function (e) {
            var t,
              r = e.elements,
              n = r[0],
              i = r[4],
              a = r[8],
              o = r[1],
              s = r[5],
              c = r[9],
              u = r[2],
              l = r[6],
              h = r[10],
              d = n + s + h;
            return (
              d > 0
                ? ((t = 0.5 / Math.sqrt(d + 1)),
                  (this._w = 0.25 / t),
                  (this._x = (l - c) * t),
                  (this._y = (a - u) * t),
                  (this._z = (o - i) * t))
                : n > s && n > h
                ? ((t = 2 * Math.sqrt(1 + n - s - h)),
                  (this._w = (l - c) / t),
                  (this._x = 0.25 * t),
                  (this._y = (i + o) / t),
                  (this._z = (a + u) / t))
                : s > h
                ? ((t = 2 * Math.sqrt(1 + s - n - h)),
                  (this._w = (a - u) / t),
                  (this._x = (i + o) / t),
                  (this._y = 0.25 * t),
                  (this._z = (c + l) / t))
                : ((t = 2 * Math.sqrt(1 + h - n - s)),
                  (this._w = (o - i) / t),
                  (this._x = (a + u) / t),
                  (this._y = (c + l) / t),
                  (this._z = 0.25 * t)),
              this.onChangeCallback(),
              this
            );
          },
          setFromUnitVectors: (function () {
            var e,
              t = new tr();
            return function (r, n) {
              return (
                void 0 === t && (t = new tr()),
                (e = r.dot(n) + 1) < 1e-6
                  ? ((e = 0),
                    Math.abs(r.x) > Math.abs(r.z) ? t.set(-r.y, r.x, 0) : t.set(0, -r.z, r.y))
                  : t.crossVectors(r, n),
                (this._x = t.x),
                (this._y = t.y),
                (this._z = t.z),
                (this._w = e),
                this.normalize()
              );
            };
          })(),
          angleTo: function (e) {
            return 2 * Math.acos(Math.abs(Kt.clamp(this.dot(e), -1, 1)));
          },
          rotateTowards: function (e, t) {
            var r = this.angleTo(e);
            if (0 === r) return this;
            var n = Math.min(1, t / r);
            return this.slerp(e, n), this;
          },
          inverse: function () {
            return this.conjugate();
          },
          conjugate: function () {
            return (this._x *= -1), (this._y *= -1), (this._z *= -1), this.onChangeCallback(), this;
          },
          dot: function (e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
          },
          lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
          },
          length: function () {
            return Math.sqrt(
              this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w,
            );
          },
          normalize: function () {
            var e = this.length();
            return (
              0 === e
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((e = 1 / e),
                  (this._x = this._x * e),
                  (this._y = this._y * e),
                  (this._z = this._z * e),
                  (this._w = this._w * e)),
              this.onChangeCallback(),
              this
            );
          },
          multiply: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.',
                ),
                this.multiplyQuaternions(e, t))
              : this.multiplyQuaternions(this, e);
          },
          premultiply: function (e) {
            return this.multiplyQuaternions(e, this);
          },
          multiplyQuaternions: function (e, t) {
            var r = e._x,
              n = e._y,
              i = e._z,
              a = e._w,
              o = t._x,
              s = t._y,
              c = t._z,
              u = t._w;
            return (
              (this._x = r * u + a * o + n * c - i * s),
              (this._y = n * u + a * s + i * o - r * c),
              (this._z = i * u + a * c + r * s - n * o),
              (this._w = a * u - r * o - n * s - i * c),
              this.onChangeCallback(),
              this
            );
          },
          slerp: function (e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            var r = this._x,
              n = this._y,
              i = this._z,
              a = this._w,
              o = a * e._w + r * e._x + n * e._y + i * e._z;
            if (
              (o < 0
                ? ((this._w = -e._w),
                  (this._x = -e._x),
                  (this._y = -e._y),
                  (this._z = -e._z),
                  (o = -o))
                : this.copy(e),
              o >= 1)
            )
              return (this._w = a), (this._x = r), (this._y = n), (this._z = i), this;
            var s = 1 - o * o;
            if (s <= Number.EPSILON) {
              var c = 1 - t;
              return (
                (this._w = c * a + t * this._w),
                (this._x = c * r + t * this._x),
                (this._y = c * n + t * this._y),
                (this._z = c * i + t * this._z),
                this.normalize()
              );
            }
            var u = Math.sqrt(s),
              l = Math.atan2(u, o),
              h = Math.sin((1 - t) * l) / u,
              d = Math.sin(t * l) / u;
            return (
              (this._w = a * h + this._w * d),
              (this._x = r * h + this._x * d),
              (this._y = n * h + this._y * d),
              (this._z = i * h + this._z * d),
              this.onChangeCallback(),
              this
            );
          },
          equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
          },
          fromArray: function (e, t) {
            return (
              void 0 === t && (t = 0),
              (this._x = e[t]),
              (this._y = e[t + 1]),
              (this._z = e[t + 2]),
              (this._w = e[t + 3]),
              this.onChangeCallback(),
              this
            );
          },
          toArray: function (e, t) {
            return (
              void 0 === e && (e = []),
              void 0 === t && (t = 0),
              (e[t] = this._x),
              (e[t + 1] = this._y),
              (e[t + 2] = this._z),
              (e[t + 3] = this._w),
              e
            );
          },
          onChange: function (e) {
            return (this.onChangeCallback = e), this;
          },
          onChangeCallback: function () {},
        }),
        Object.assign(tr.prototype, {
          isVector3: !0,
          set: function (e, t, r) {
            return (this.x = e), (this.y = t), (this.z = r), this;
          },
          setScalar: function (e) {
            return (this.x = e), (this.y = e), (this.z = e), this;
          },
          setX: function (e) {
            return (this.x = e), this;
          },
          setY: function (e) {
            return (this.y = e), this;
          },
          setZ: function (e) {
            return (this.z = e), this;
          },
          setComponent: function (e, t) {
            switch (e) {
              case 0:
                this.x = t;
                break;
              case 1:
                this.y = t;
                break;
              case 2:
                this.z = t;
                break;
              default:
                throw new Error('index is out of range: ' + e);
            }
            return this;
          },
          getComponent: function (e) {
            switch (e) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw new Error('index is out of range: ' + e);
            }
          },
          clone: function () {
            return new this.constructor(this.x, this.y, this.z);
          },
          copy: function (e) {
            return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
          },
          add: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                ),
                this.addVectors(e, t))
              : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
          },
          addScalar: function (e) {
            return (this.x += e), (this.y += e), (this.z += e), this;
          },
          addVectors: function (e, t) {
            return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this;
          },
          addScaledVector: function (e, t) {
            return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
          },
          sub: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                ),
                this.subVectors(e, t))
              : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
          },
          subScalar: function (e) {
            return (this.x -= e), (this.y -= e), (this.z -= e), this;
          },
          subVectors: function (e, t) {
            return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this;
          },
          multiply: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.',
                ),
                this.multiplyVectors(e, t))
              : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
          },
          multiplyScalar: function (e) {
            return (this.x *= e), (this.y *= e), (this.z *= e), this;
          },
          multiplyVectors: function (e, t) {
            return (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this;
          },
          applyEuler:
            ((f = new er()),
            function (e) {
              return (
                (e && e.isEuler) ||
                  console.error(
                    'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.',
                  ),
                this.applyQuaternion(f.setFromEuler(e))
              );
            }),
          applyAxisAngle: (function () {
            var e = new er();
            return function (t, r) {
              return this.applyQuaternion(e.setFromAxisAngle(t, r));
            };
          })(),
          applyMatrix3: function (e) {
            var t = this.x,
              r = this.y,
              n = this.z,
              i = e.elements;
            return (
              (this.x = i[0] * t + i[3] * r + i[6] * n),
              (this.y = i[1] * t + i[4] * r + i[7] * n),
              (this.z = i[2] * t + i[5] * r + i[8] * n),
              this
            );
          },
          applyMatrix4: function (e) {
            var t = this.x,
              r = this.y,
              n = this.z,
              i = e.elements,
              a = 1 / (i[3] * t + i[7] * r + i[11] * n + i[15]);
            return (
              (this.x = (i[0] * t + i[4] * r + i[8] * n + i[12]) * a),
              (this.y = (i[1] * t + i[5] * r + i[9] * n + i[13]) * a),
              (this.z = (i[2] * t + i[6] * r + i[10] * n + i[14]) * a),
              this
            );
          },
          applyQuaternion: function (e) {
            var t = this.x,
              r = this.y,
              n = this.z,
              i = e.x,
              a = e.y,
              o = e.z,
              s = e.w,
              c = s * t + a * n - o * r,
              u = s * r + o * t - i * n,
              l = s * n + i * r - a * t,
              h = -i * t - a * r - o * n;
            return (
              (this.x = c * s + h * -i + u * -o - l * -a),
              (this.y = u * s + h * -a + l * -i - c * -o),
              (this.z = l * s + h * -o + c * -a - u * -i),
              this
            );
          },
          project: function (e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
          },
          unproject: (function () {
            var e = new $t();
            return function (t) {
              return this.applyMatrix4(e.getInverse(t.projectionMatrix)).applyMatrix4(
                t.matrixWorld,
              );
            };
          })(),
          transformDirection: function (e) {
            var t = this.x,
              r = this.y,
              n = this.z,
              i = e.elements;
            return (
              (this.x = i[0] * t + i[4] * r + i[8] * n),
              (this.y = i[1] * t + i[5] * r + i[9] * n),
              (this.z = i[2] * t + i[6] * r + i[10] * n),
              this.normalize()
            );
          },
          divide: function (e) {
            return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
          },
          divideScalar: function (e) {
            return this.multiplyScalar(1 / e);
          },
          min: function (e) {
            return (
              (this.x = Math.min(this.x, e.x)),
              (this.y = Math.min(this.y, e.y)),
              (this.z = Math.min(this.z, e.z)),
              this
            );
          },
          max: function (e) {
            return (
              (this.x = Math.max(this.x, e.x)),
              (this.y = Math.max(this.y, e.y)),
              (this.z = Math.max(this.z, e.z)),
              this
            );
          },
          clamp: function (e, t) {
            return (
              (this.x = Math.max(e.x, Math.min(t.x, this.x))),
              (this.y = Math.max(e.y, Math.min(t.y, this.y))),
              (this.z = Math.max(e.z, Math.min(t.z, this.z))),
              this
            );
          },
          clampScalar: (function () {
            var e = new tr(),
              t = new tr();
            return function (r, n) {
              return e.set(r, r, r), t.set(n, n, n), this.clamp(e, t);
            };
          })(),
          clampLength: function (e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
          },
          floor: function () {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              this
            );
          },
          ceil: function () {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              this
            );
          },
          round: function () {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              this
            );
          },
          roundToZero: function () {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              this
            );
          },
          negate: function () {
            return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
          },
          dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z;
          },
          lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          },
          length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
          },
          manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          },
          normalize: function () {
            return this.divideScalar(this.length() || 1);
          },
          setLength: function (e) {
            return this.normalize().multiplyScalar(e);
          },
          lerp: function (e, t) {
            return (
              (this.x += (e.x - this.x) * t),
              (this.y += (e.y - this.y) * t),
              (this.z += (e.z - this.z) * t),
              this
            );
          },
          lerpVectors: function (e, t, r) {
            return this.subVectors(t, e).multiplyScalar(r).add(e);
          },
          cross: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.',
                ),
                this.crossVectors(e, t))
              : this.crossVectors(this, e);
          },
          crossVectors: function (e, t) {
            var r = e.x,
              n = e.y,
              i = e.z,
              a = t.x,
              o = t.y,
              s = t.z;
            return (
              (this.x = n * s - i * o), (this.y = i * a - r * s), (this.z = r * o - n * a), this
            );
          },
          projectOnVector: function (e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t);
          },
          projectOnPlane: (function () {
            var e = new tr();
            return function (t) {
              return e.copy(this).projectOnVector(t), this.sub(e);
            };
          })(),
          reflect: (function () {
            var e = new tr();
            return function (t) {
              return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)));
            };
          })(),
          angleTo: function (e) {
            var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
            return Math.acos(Kt.clamp(t, -1, 1));
          },
          distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e));
          },
          distanceToSquared: function (e) {
            var t = this.x - e.x,
              r = this.y - e.y,
              n = this.z - e.z;
            return t * t + r * r + n * n;
          },
          manhattanDistanceTo: function (e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
          },
          setFromSpherical: function (e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
          },
          setFromSphericalCoords: function (e, t, r) {
            var n = Math.sin(t) * e;
            return (
              (this.x = n * Math.sin(r)),
              (this.y = Math.cos(t) * e),
              (this.z = n * Math.cos(r)),
              this
            );
          },
          setFromCylindrical: function (e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
          },
          setFromCylindricalCoords: function (e, t, r) {
            return (this.x = e * Math.sin(t)), (this.y = r), (this.z = e * Math.cos(t)), this;
          },
          setFromMatrixPosition: function (e) {
            var t = e.elements;
            return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
          },
          setFromMatrixScale: function (e) {
            var t = this.setFromMatrixColumn(e, 0).length(),
              r = this.setFromMatrixColumn(e, 1).length(),
              n = this.setFromMatrixColumn(e, 2).length();
            return (this.x = t), (this.y = r), (this.z = n), this;
          },
          setFromMatrixColumn: function (e, t) {
            return this.fromArray(e.elements, 4 * t);
          },
          equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z;
          },
          fromArray: function (e, t) {
            return (
              void 0 === t && (t = 0),
              (this.x = e[t]),
              (this.y = e[t + 1]),
              (this.z = e[t + 2]),
              this
            );
          },
          toArray: function (e, t) {
            return (
              void 0 === e && (e = []),
              void 0 === t && (t = 0),
              (e[t] = this.x),
              (e[t + 1] = this.y),
              (e[t + 2] = this.z),
              e
            );
          },
          fromBufferAttribute: function (e, t, r) {
            return (
              void 0 !== r &&
                console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().'),
              (this.x = e.getX(t)),
              (this.y = e.getY(t)),
              (this.z = e.getZ(t)),
              this
            );
          },
        }),
        Object.assign(rr.prototype, {
          isMatrix3: !0,
          set: function (e, t, r, n, i, a, o, s, c) {
            var u = this.elements;
            return (
              (u[0] = e),
              (u[1] = n),
              (u[2] = o),
              (u[3] = t),
              (u[4] = i),
              (u[5] = s),
              (u[6] = r),
              (u[7] = a),
              (u[8] = c),
              this
            );
          },
          identity: function () {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          },
          clone: function () {
            return new this.constructor().fromArray(this.elements);
          },
          copy: function (e) {
            var t = this.elements,
              r = e.elements;
            return (
              (t[0] = r[0]),
              (t[1] = r[1]),
              (t[2] = r[2]),
              (t[3] = r[3]),
              (t[4] = r[4]),
              (t[5] = r[5]),
              (t[6] = r[6]),
              (t[7] = r[7]),
              (t[8] = r[8]),
              this
            );
          },
          setFromMatrix4: function (e) {
            var t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
          },
          applyToBufferAttribute: (function () {
            var e = new tr();
            return function (t) {
              for (var r = 0, n = t.count; r < n; r++)
                (e.x = t.getX(r)),
                  (e.y = t.getY(r)),
                  (e.z = t.getZ(r)),
                  e.applyMatrix3(this),
                  t.setXYZ(r, e.x, e.y, e.z);
              return t;
            };
          })(),
          multiply: function (e) {
            return this.multiplyMatrices(this, e);
          },
          premultiply: function (e) {
            return this.multiplyMatrices(e, this);
          },
          multiplyMatrices: function (e, t) {
            var r = e.elements,
              n = t.elements,
              i = this.elements,
              a = r[0],
              o = r[3],
              s = r[6],
              c = r[1],
              u = r[4],
              l = r[7],
              h = r[2],
              d = r[5],
              p = r[8],
              f = n[0],
              m = n[3],
              v = n[6],
              g = n[1],
              y = n[4],
              x = n[7],
              b = n[2],
              w = n[5],
              _ = n[8];
            return (
              (i[0] = a * f + o * g + s * b),
              (i[3] = a * m + o * y + s * w),
              (i[6] = a * v + o * x + s * _),
              (i[1] = c * f + u * g + l * b),
              (i[4] = c * m + u * y + l * w),
              (i[7] = c * v + u * x + l * _),
              (i[2] = h * f + d * g + p * b),
              (i[5] = h * m + d * y + p * w),
              (i[8] = h * v + d * x + p * _),
              this
            );
          },
          multiplyScalar: function (e) {
            var t = this.elements;
            return (
              (t[0] *= e),
              (t[3] *= e),
              (t[6] *= e),
              (t[1] *= e),
              (t[4] *= e),
              (t[7] *= e),
              (t[2] *= e),
              (t[5] *= e),
              (t[8] *= e),
              this
            );
          },
          determinant: function () {
            var e = this.elements,
              t = e[0],
              r = e[1],
              n = e[2],
              i = e[3],
              a = e[4],
              o = e[5],
              s = e[6],
              c = e[7],
              u = e[8];
            return t * a * u - t * o * c - r * i * u + r * o * s + n * i * c - n * a * s;
          },
          getInverse: function (e, t) {
            e &&
              e.isMatrix4 &&
              console.error('THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.');
            var r = e.elements,
              n = this.elements,
              i = r[0],
              a = r[1],
              o = r[2],
              s = r[3],
              c = r[4],
              u = r[5],
              l = r[6],
              h = r[7],
              d = r[8],
              p = d * c - u * h,
              f = u * l - d * s,
              m = h * s - c * l,
              v = i * p + a * f + o * m;
            if (0 === v) {
              var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
              if (!0 === t) throw new Error(g);
              return console.warn(g), this.identity();
            }
            var y = 1 / v;
            return (
              (n[0] = p * y),
              (n[1] = (o * h - d * a) * y),
              (n[2] = (u * a - o * c) * y),
              (n[3] = f * y),
              (n[4] = (d * i - o * l) * y),
              (n[5] = (o * s - u * i) * y),
              (n[6] = m * y),
              (n[7] = (a * l - h * i) * y),
              (n[8] = (c * i - a * s) * y),
              this
            );
          },
          transpose: function () {
            var e,
              t = this.elements;
            return (
              (e = t[1]),
              (t[1] = t[3]),
              (t[3] = e),
              (e = t[2]),
              (t[2] = t[6]),
              (t[6] = e),
              (e = t[5]),
              (t[5] = t[7]),
              (t[7] = e),
              this
            );
          },
          getNormalMatrix: function (e) {
            return this.setFromMatrix4(e).getInverse(this).transpose();
          },
          transposeIntoArray: function (e) {
            var t = this.elements;
            return (
              (e[0] = t[0]),
              (e[1] = t[3]),
              (e[2] = t[6]),
              (e[3] = t[1]),
              (e[4] = t[4]),
              (e[5] = t[7]),
              (e[6] = t[2]),
              (e[7] = t[5]),
              (e[8] = t[8]),
              this
            );
          },
          setUvTransform: function (e, t, r, n, i, a, o) {
            var s = Math.cos(i),
              c = Math.sin(i);
            this.set(
              r * s,
              r * c,
              -r * (s * a + c * o) + a + e,
              -n * c,
              n * s,
              -n * (-c * a + s * o) + o + t,
              0,
              0,
              1,
            );
          },
          scale: function (e, t) {
            var r = this.elements;
            return (
              (r[0] *= e), (r[3] *= e), (r[6] *= e), (r[1] *= t), (r[4] *= t), (r[7] *= t), this
            );
          },
          rotate: function (e) {
            var t = Math.cos(e),
              r = Math.sin(e),
              n = this.elements,
              i = n[0],
              a = n[3],
              o = n[6],
              s = n[1],
              c = n[4],
              u = n[7];
            return (
              (n[0] = t * i + r * s),
              (n[3] = t * a + r * c),
              (n[6] = t * o + r * u),
              (n[1] = -r * i + t * s),
              (n[4] = -r * a + t * c),
              (n[7] = -r * o + t * u),
              this
            );
          },
          translate: function (e, t) {
            var r = this.elements;
            return (
              (r[0] += e * r[2]),
              (r[3] += e * r[5]),
              (r[6] += e * r[8]),
              (r[1] += t * r[2]),
              (r[4] += t * r[5]),
              (r[7] += t * r[8]),
              this
            );
          },
          equals: function (e) {
            for (var t = this.elements, r = e.elements, n = 0; n < 9; n++)
              if (t[n] !== r[n]) return !1;
            return !0;
          },
          fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var r = 0; r < 9; r++) this.elements[r] = e[r + t];
            return this;
          },
          toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var r = this.elements;
            return (
              (e[t] = r[0]),
              (e[t + 1] = r[1]),
              (e[t + 2] = r[2]),
              (e[t + 3] = r[3]),
              (e[t + 4] = r[4]),
              (e[t + 5] = r[5]),
              (e[t + 6] = r[6]),
              (e[t + 7] = r[7]),
              (e[t + 8] = r[8]),
              e
            );
          },
        });
      var nr,
        ir,
        ar,
        or,
        sr,
        cr = {
          getDataURL: function (e) {
            var t;
            if ('undefined' == typeof HTMLCanvasElement) return e.src;
            if (e instanceof HTMLCanvasElement) t = e;
            else {
              void 0 === m &&
                (m = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')),
                (m.width = e.width),
                (m.height = e.height);
              var r = m.getContext('2d');
              e instanceof ImageData
                ? r.putImageData(e, 0, 0)
                : r.drawImage(e, 0, 0, e.width, e.height),
                (t = m);
            }
            return t.width > 2048 || t.height > 2048
              ? t.toDataURL('image/jpeg', 0.6)
              : t.toDataURL('image/png');
          },
        },
        ur = 0;
      function lr(e, t, r, n, i, a, o, s, c, u) {
        Object.defineProperty(this, 'id', { value: ur++ }),
          (this.uuid = Kt.generateUUID()),
          (this.name = ''),
          (this.image = void 0 !== e ? e : lr.DEFAULT_IMAGE),
          (this.mipmaps = []),
          (this.mapping = void 0 !== t ? t : lr.DEFAULT_MAPPING),
          (this.wrapS = void 0 !== r ? r : Re),
          (this.wrapT = void 0 !== n ? n : Re),
          (this.magFilter = void 0 !== i ? i : De),
          (this.minFilter = void 0 !== a ? a : Ne),
          (this.anisotropy = void 0 !== c ? c : 1),
          (this.format = void 0 !== o ? o : Ke),
          (this.type = void 0 !== s ? s : Ue),
          (this.offset = new Qt(0, 0)),
          (this.repeat = new Qt(1, 1)),
          (this.center = new Qt(0, 0)),
          (this.rotation = 0),
          (this.matrixAutoUpdate = !0),
          (this.matrix = new rr()),
          (this.generateMipmaps = !0),
          (this.premultiplyAlpha = !1),
          (this.flipY = !0),
          (this.unpackAlignment = 4),
          (this.encoding = void 0 !== u ? u : Ft),
          (this.version = 0),
          (this.onUpdate = null);
      }
      function hr(e, t, r, n) {
        (this.x = e || 0), (this.y = t || 0), (this.z = r || 0), (this.w = void 0 !== n ? n : 1);
      }
      function dr(e, t, r) {
        (this.width = e),
          (this.height = t),
          (this.scissor = new hr(0, 0, e, t)),
          (this.scissorTest = !1),
          (this.viewport = new hr(0, 0, e, t)),
          (r = r || {}),
          (this.texture = new lr(
            void 0,
            void 0,
            r.wrapS,
            r.wrapT,
            r.magFilter,
            r.minFilter,
            r.format,
            r.type,
            r.anisotropy,
            r.encoding,
          )),
          (this.texture.generateMipmaps = void 0 !== r.generateMipmaps && r.generateMipmaps),
          (this.texture.minFilter = void 0 !== r.minFilter ? r.minFilter : De),
          (this.depthBuffer = void 0 === r.depthBuffer || r.depthBuffer),
          (this.stencilBuffer = void 0 === r.stencilBuffer || r.stencilBuffer),
          (this.depthTexture = void 0 !== r.depthTexture ? r.depthTexture : null);
      }
      function pr(e, t, r) {
        dr.call(this, e, t, r), (this.samples = 4);
      }
      function fr(e, t, r) {
        dr.call(this, e, t, r), (this.activeCubeFace = 0), (this.activeMipMapLevel = 0);
      }
      function mr(e, t, r, n, i, a, o, s, c, u, l, h) {
        lr.call(this, null, a, o, s, c, u, n, i, l, h),
          (this.image = { data: e, width: t, height: r }),
          (this.magFilter = void 0 !== c ? c : Pe),
          (this.minFilter = void 0 !== u ? u : Pe),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
      function vr(e, t) {
        (this.min = void 0 !== e ? e : new tr(1 / 0, 1 / 0, 1 / 0)),
          (this.max = void 0 !== t ? t : new tr(-1 / 0, -1 / 0, -1 / 0));
      }
      function gr(e, t) {
        (this.center = void 0 !== e ? e : new tr()), (this.radius = void 0 !== t ? t : 0);
      }
      function yr(e, t) {
        (this.normal = void 0 !== e ? e : new tr(1, 0, 0)), (this.constant = void 0 !== t ? t : 0);
      }
      function xr(e, t, r, n, i, a) {
        this.planes = [
          void 0 !== e ? e : new yr(),
          void 0 !== t ? t : new yr(),
          void 0 !== r ? r : new yr(),
          void 0 !== n ? n : new yr(),
          void 0 !== i ? i : new yr(),
          void 0 !== a ? a : new yr(),
        ];
      }
      (lr.DEFAULT_IMAGE = void 0),
        (lr.DEFAULT_MAPPING = be),
        (lr.prototype = Object.assign(Object.create(n.prototype), {
          constructor: lr,
          isTexture: !0,
          updateMatrix: function () {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y,
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (
              (this.name = e.name),
              (this.image = e.image),
              (this.mipmaps = e.mipmaps.slice(0)),
              (this.mapping = e.mapping),
              (this.wrapS = e.wrapS),
              (this.wrapT = e.wrapT),
              (this.magFilter = e.magFilter),
              (this.minFilter = e.minFilter),
              (this.anisotropy = e.anisotropy),
              (this.format = e.format),
              (this.type = e.type),
              this.offset.copy(e.offset),
              this.repeat.copy(e.repeat),
              this.center.copy(e.center),
              (this.rotation = e.rotation),
              (this.matrixAutoUpdate = e.matrixAutoUpdate),
              this.matrix.copy(e.matrix),
              (this.generateMipmaps = e.generateMipmaps),
              (this.premultiplyAlpha = e.premultiplyAlpha),
              (this.flipY = e.flipY),
              (this.unpackAlignment = e.unpackAlignment),
              (this.encoding = e.encoding),
              this
            );
          },
          toJSON: function (e) {
            var t = void 0 === e || 'string' == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            var r = {
              metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' },
              uuid: this.uuid,
              name: this.name,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            if (void 0 !== this.image) {
              var n = this.image;
              if (
                (void 0 === n.uuid && (n.uuid = Kt.generateUUID()),
                !t && void 0 === e.images[n.uuid])
              ) {
                var i;
                if (Array.isArray(n)) {
                  i = [];
                  for (var a = 0, o = n.length; a < o; a++) i.push(cr.getDataURL(n[a]));
                } else i = cr.getDataURL(n);
                e.images[n.uuid] = { uuid: n.uuid, url: i };
              }
              r.image = n.uuid;
            }
            return t || (e.textures[this.uuid] = r), r;
          },
          dispose: function () {
            this.dispatchEvent({ type: 'dispose' });
          },
          transformUv: function (e) {
            if (this.mapping !== be) return e;
            if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
              switch (this.wrapS) {
                case Le:
                  e.x = e.x - Math.floor(e.x);
                  break;
                case Re:
                  e.x = e.x < 0 ? 0 : 1;
                  break;
                case Ce:
                  1 === Math.abs(Math.floor(e.x) % 2)
                    ? (e.x = Math.ceil(e.x) - e.x)
                    : (e.x = e.x - Math.floor(e.x));
              }
            if (e.y < 0 || e.y > 1)
              switch (this.wrapT) {
                case Le:
                  e.y = e.y - Math.floor(e.y);
                  break;
                case Re:
                  e.y = e.y < 0 ? 0 : 1;
                  break;
                case Ce:
                  1 === Math.abs(Math.floor(e.y) % 2)
                    ? (e.y = Math.ceil(e.y) - e.y)
                    : (e.y = e.y - Math.floor(e.y));
              }
            return this.flipY && (e.y = 1 - e.y), e;
          },
        })),
        Object.defineProperty(lr.prototype, 'needsUpdate', {
          set: function (e) {
            !0 === e && this.version++;
          },
        }),
        Object.assign(hr.prototype, {
          isVector4: !0,
          set: function (e, t, r, n) {
            return (this.x = e), (this.y = t), (this.z = r), (this.w = n), this;
          },
          setScalar: function (e) {
            return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
          },
          setX: function (e) {
            return (this.x = e), this;
          },
          setY: function (e) {
            return (this.y = e), this;
          },
          setZ: function (e) {
            return (this.z = e), this;
          },
          setW: function (e) {
            return (this.w = e), this;
          },
          setComponent: function (e, t) {
            switch (e) {
              case 0:
                this.x = t;
                break;
              case 1:
                this.y = t;
                break;
              case 2:
                this.z = t;
                break;
              case 3:
                this.w = t;
                break;
              default:
                throw new Error('index is out of range: ' + e);
            }
            return this;
          },
          getComponent: function (e) {
            switch (e) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw new Error('index is out of range: ' + e);
            }
          },
          clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w);
          },
          copy: function (e) {
            return (
              (this.x = e.x),
              (this.y = e.y),
              (this.z = e.z),
              (this.w = void 0 !== e.w ? e.w : 1),
              this
            );
          },
          add: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                ),
                this.addVectors(e, t))
              : ((this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this);
          },
          addScalar: function (e) {
            return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
          },
          addVectors: function (e, t) {
            return (
              (this.x = e.x + t.x),
              (this.y = e.y + t.y),
              (this.z = e.z + t.z),
              (this.w = e.w + t.w),
              this
            );
          },
          addScaledVector: function (e, t) {
            return (
              (this.x += e.x * t),
              (this.y += e.y * t),
              (this.z += e.z * t),
              (this.w += e.w * t),
              this
            );
          },
          sub: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                ),
                this.subVectors(e, t))
              : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this);
          },
          subScalar: function (e) {
            return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
          },
          subVectors: function (e, t) {
            return (
              (this.x = e.x - t.x),
              (this.y = e.y - t.y),
              (this.z = e.z - t.z),
              (this.w = e.w - t.w),
              this
            );
          },
          multiplyScalar: function (e) {
            return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
          },
          applyMatrix4: function (e) {
            var t = this.x,
              r = this.y,
              n = this.z,
              i = this.w,
              a = e.elements;
            return (
              (this.x = a[0] * t + a[4] * r + a[8] * n + a[12] * i),
              (this.y = a[1] * t + a[5] * r + a[9] * n + a[13] * i),
              (this.z = a[2] * t + a[6] * r + a[10] * n + a[14] * i),
              (this.w = a[3] * t + a[7] * r + a[11] * n + a[15] * i),
              this
            );
          },
          divideScalar: function (e) {
            return this.multiplyScalar(1 / e);
          },
          setAxisAngleFromQuaternion: function (e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return (
              t < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
              this
            );
          },
          setAxisAngleFromRotationMatrix: function (e) {
            var t,
              r,
              n,
              i,
              a = e.elements,
              o = a[0],
              s = a[4],
              c = a[8],
              u = a[1],
              l = a[5],
              h = a[9],
              d = a[2],
              p = a[6],
              f = a[10];
            if (Math.abs(s - u) < 0.01 && Math.abs(c - d) < 0.01 && Math.abs(h - p) < 0.01) {
              if (
                Math.abs(s + u) < 0.1 &&
                Math.abs(c + d) < 0.1 &&
                Math.abs(h + p) < 0.1 &&
                Math.abs(o + l + f - 3) < 0.1
              )
                return this.set(1, 0, 0, 0), this;
              t = Math.PI;
              var m = (o + 1) / 2,
                v = (l + 1) / 2,
                g = (f + 1) / 2,
                y = (s + u) / 4,
                x = (c + d) / 4,
                b = (h + p) / 4;
              return (
                m > v && m > g
                  ? m < 0.01
                    ? ((r = 0), (n = 0.707106781), (i = 0.707106781))
                    : ((n = y / (r = Math.sqrt(m))), (i = x / r))
                  : v > g
                  ? v < 0.01
                    ? ((r = 0.707106781), (n = 0), (i = 0.707106781))
                    : ((r = y / (n = Math.sqrt(v))), (i = b / n))
                  : g < 0.01
                  ? ((r = 0.707106781), (n = 0.707106781), (i = 0))
                  : ((r = x / (i = Math.sqrt(g))), (n = b / i)),
                this.set(r, n, i, t),
                this
              );
            }
            var w = Math.sqrt((p - h) * (p - h) + (c - d) * (c - d) + (u - s) * (u - s));
            return (
              Math.abs(w) < 0.001 && (w = 1),
              (this.x = (p - h) / w),
              (this.y = (c - d) / w),
              (this.z = (u - s) / w),
              (this.w = Math.acos((o + l + f - 1) / 2)),
              this
            );
          },
          min: function (e) {
            return (
              (this.x = Math.min(this.x, e.x)),
              (this.y = Math.min(this.y, e.y)),
              (this.z = Math.min(this.z, e.z)),
              (this.w = Math.min(this.w, e.w)),
              this
            );
          },
          max: function (e) {
            return (
              (this.x = Math.max(this.x, e.x)),
              (this.y = Math.max(this.y, e.y)),
              (this.z = Math.max(this.z, e.z)),
              (this.w = Math.max(this.w, e.w)),
              this
            );
          },
          clamp: function (e, t) {
            return (
              (this.x = Math.max(e.x, Math.min(t.x, this.x))),
              (this.y = Math.max(e.y, Math.min(t.y, this.y))),
              (this.z = Math.max(e.z, Math.min(t.z, this.z))),
              (this.w = Math.max(e.w, Math.min(t.w, this.w))),
              this
            );
          },
          clampScalar: (function () {
            var e, t;
            return function (r, n) {
              return (
                void 0 === e && ((e = new hr()), (t = new hr())),
                e.set(r, r, r, r),
                t.set(n, n, n, n),
                this.clamp(e, t)
              );
            };
          })(),
          clampLength: function (e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
          },
          floor: function () {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          },
          ceil: function () {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          },
          round: function () {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          },
          roundToZero: function () {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
              this
            );
          },
          negate: function () {
            return (
              (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this
            );
          },
          dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
          },
          lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
          },
          length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
          },
          manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
          },
          normalize: function () {
            return this.divideScalar(this.length() || 1);
          },
          setLength: function (e) {
            return this.normalize().multiplyScalar(e);
          },
          lerp: function (e, t) {
            return (
              (this.x += (e.x - this.x) * t),
              (this.y += (e.y - this.y) * t),
              (this.z += (e.z - this.z) * t),
              (this.w += (e.w - this.w) * t),
              this
            );
          },
          lerpVectors: function (e, t, r) {
            return this.subVectors(t, e).multiplyScalar(r).add(e);
          },
          equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
          },
          fromArray: function (e, t) {
            return (
              void 0 === t && (t = 0),
              (this.x = e[t]),
              (this.y = e[t + 1]),
              (this.z = e[t + 2]),
              (this.w = e[t + 3]),
              this
            );
          },
          toArray: function (e, t) {
            return (
              void 0 === e && (e = []),
              void 0 === t && (t = 0),
              (e[t] = this.x),
              (e[t + 1] = this.y),
              (e[t + 2] = this.z),
              (e[t + 3] = this.w),
              e
            );
          },
          fromBufferAttribute: function (e, t, r) {
            return (
              void 0 !== r &&
                console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().'),
              (this.x = e.getX(t)),
              (this.y = e.getY(t)),
              (this.z = e.getZ(t)),
              (this.w = e.getW(t)),
              this
            );
          },
        }),
        (dr.prototype = Object.assign(Object.create(n.prototype), {
          constructor: dr,
          isWebGLRenderTarget: !0,
          setSize: function (e, t) {
            (this.width === e && this.height === t) ||
              ((this.width = e), (this.height = t), this.dispose()),
              this.viewport.set(0, 0, e, t),
              this.scissor.set(0, 0, e, t);
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (
              (this.width = e.width),
              (this.height = e.height),
              this.viewport.copy(e.viewport),
              (this.texture = e.texture.clone()),
              (this.depthBuffer = e.depthBuffer),
              (this.stencilBuffer = e.stencilBuffer),
              (this.depthTexture = e.depthTexture),
              this
            );
          },
          dispose: function () {
            this.dispatchEvent({ type: 'dispose' });
          },
        })),
        (pr.prototype = Object.assign(Object.create(dr.prototype), {
          constructor: pr,
          isWebGLMultisampleRenderTarget: !0,
          copy: function (e) {
            return dr.prototype.copy.call(this, e), (this.samples = e.samples), this;
          },
        })),
        (fr.prototype = Object.create(dr.prototype)),
        (fr.prototype.constructor = fr),
        (fr.prototype.isWebGLRenderTargetCube = !0),
        (mr.prototype = Object.create(lr.prototype)),
        (mr.prototype.constructor = mr),
        (mr.prototype.isDataTexture = !0),
        Object.assign(vr.prototype, {
          isBox3: !0,
          set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this;
          },
          setFromArray: function (e) {
            for (
              var t = 1 / 0,
                r = 1 / 0,
                n = 1 / 0,
                i = -1 / 0,
                a = -1 / 0,
                o = -1 / 0,
                s = 0,
                c = e.length;
              s < c;
              s += 3
            ) {
              var u = e[s],
                l = e[s + 1],
                h = e[s + 2];
              u < t && (t = u),
                l < r && (r = l),
                h < n && (n = h),
                u > i && (i = u),
                l > a && (a = l),
                h > o && (o = h);
            }
            return this.min.set(t, r, n), this.max.set(i, a, o), this;
          },
          setFromBufferAttribute: function (e) {
            for (
              var t = 1 / 0,
                r = 1 / 0,
                n = 1 / 0,
                i = -1 / 0,
                a = -1 / 0,
                o = -1 / 0,
                s = 0,
                c = e.count;
              s < c;
              s++
            ) {
              var u = e.getX(s),
                l = e.getY(s),
                h = e.getZ(s);
              u < t && (t = u),
                l < r && (r = l),
                h < n && (n = h),
                u > i && (i = u),
                l > a && (a = l),
                h > o && (o = h);
            }
            return this.min.set(t, r, n), this.max.set(i, a, o), this;
          },
          setFromPoints: function (e) {
            this.makeEmpty();
            for (var t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
            return this;
          },
          setFromCenterAndSize: (function () {
            var e = new tr();
            return function (t, r) {
              var n = e.copy(r).multiplyScalar(0.5);
              return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
            };
          })(),
          setFromObject: function (e) {
            return this.makeEmpty(), this.expandByObject(e);
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this;
          },
          makeEmpty: function () {
            return (
              (this.min.x = this.min.y = this.min.z = 1 / 0),
              (this.max.x = this.max.y = this.max.z = -1 / 0),
              this
            );
          },
          isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
          },
          getCenter: function (e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Box3: .getCenter() target is now required'), (e = new tr())),
              this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5)
            );
          },
          getSize: function (e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Box3: .getSize() target is now required'), (e = new tr())),
              this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            );
          },
          expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this;
          },
          expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this;
          },
          expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this;
          },
          expandByObject: (function () {
            var e,
              t,
              r,
              n = new tr();
            function i(i) {
              var a = i.geometry;
              if (void 0 !== a)
                if (a.isGeometry) {
                  var o = a.vertices;
                  for (t = 0, r = o.length; t < r; t++)
                    n.copy(o[t]), n.applyMatrix4(i.matrixWorld), e.expandByPoint(n);
                } else if (a.isBufferGeometry) {
                  var s = a.attributes.position;
                  if (void 0 !== s)
                    for (t = 0, r = s.count; t < r; t++)
                      n.fromBufferAttribute(s, t).applyMatrix4(i.matrixWorld), e.expandByPoint(n);
                }
            }
            return function (t) {
              return (e = this), t.updateMatrixWorld(!0), t.traverse(i), this;
            };
          })(),
          containsPoint: function (e) {
            return !(
              e.x < this.min.x ||
              e.x > this.max.x ||
              e.y < this.min.y ||
              e.y > this.max.y ||
              e.z < this.min.z ||
              e.z > this.max.z
            );
          },
          containsBox: function (e) {
            return (
              this.min.x <= e.min.x &&
              e.max.x <= this.max.x &&
              this.min.y <= e.min.y &&
              e.max.y <= this.max.y &&
              this.min.z <= e.min.z &&
              e.max.z <= this.max.z
            );
          },
          getParameter: function (e, t) {
            return (
              void 0 === t &&
                (console.warn('THREE.Box3: .getParameter() target is now required'),
                (t = new tr())),
              t.set(
                (e.x - this.min.x) / (this.max.x - this.min.x),
                (e.y - this.min.y) / (this.max.y - this.min.y),
                (e.z - this.min.z) / (this.max.z - this.min.z),
              )
            );
          },
          intersectsBox: function (e) {
            return !(
              e.max.x < this.min.x ||
              e.min.x > this.max.x ||
              e.max.y < this.min.y ||
              e.min.y > this.max.y ||
              e.max.z < this.min.z ||
              e.min.z > this.max.z
            );
          },
          intersectsSphere:
            ((ir = new tr()),
            function (e) {
              return (
                this.clampPoint(e.center, ir), ir.distanceToSquared(e.center) <= e.radius * e.radius
              );
            }),
          intersectsPlane: function (e) {
            var t, r;
            return (
              e.normal.x > 0
                ? ((t = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
                : ((t = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
              e.normal.y > 0
                ? ((t += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
                : ((t += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
              e.normal.z > 0
                ? ((t += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
                : ((t += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
              t <= -e.constant && r >= -e.constant
            );
          },
          intersectsTriangle: (function () {
            var e = new tr(),
              t = new tr(),
              r = new tr(),
              n = new tr(),
              i = new tr(),
              a = new tr(),
              o = new tr(),
              s = new tr(),
              c = new tr(),
              u = new tr();
            function l(n) {
              var i, a;
              for (i = 0, a = n.length - 3; i <= a; i += 3) {
                o.fromArray(n, i);
                var s = c.x * Math.abs(o.x) + c.y * Math.abs(o.y) + c.z * Math.abs(o.z),
                  u = e.dot(o),
                  l = t.dot(o),
                  h = r.dot(o);
                if (Math.max(-Math.max(u, l, h), Math.min(u, l, h)) > s) return !1;
              }
              return !0;
            }
            return function (o) {
              if (this.isEmpty()) return !1;
              this.getCenter(s),
                c.subVectors(this.max, s),
                e.subVectors(o.a, s),
                t.subVectors(o.b, s),
                r.subVectors(o.c, s),
                n.subVectors(t, e),
                i.subVectors(r, t),
                a.subVectors(e, r);
              var h = [
                0,
                -n.z,
                n.y,
                0,
                -i.z,
                i.y,
                0,
                -a.z,
                a.y,
                n.z,
                0,
                -n.x,
                i.z,
                0,
                -i.x,
                a.z,
                0,
                -a.x,
                -n.y,
                n.x,
                0,
                -i.y,
                i.x,
                0,
                -a.y,
                a.x,
                0,
              ];
              return (
                !!l(h) &&
                !!l((h = [1, 0, 0, 0, 1, 0, 0, 0, 1])) &&
                (u.crossVectors(n, i), l((h = [u.x, u.y, u.z])))
              );
            };
          })(),
          clampPoint: function (e, t) {
            return (
              void 0 === t &&
                (console.warn('THREE.Box3: .clampPoint() target is now required'), (t = new tr())),
              t.copy(e).clamp(this.min, this.max)
            );
          },
          distanceToPoint: (function () {
            var e = new tr();
            return function (t) {
              return e.copy(t).clamp(this.min, this.max).sub(t).length();
            };
          })(),
          getBoundingSphere: (function () {
            var e = new tr();
            return function (t) {
              return (
                void 0 === t &&
                  (console.warn('THREE.Box3: .getBoundingSphere() target is now required'),
                  (t = new gr())),
                this.getCenter(t.center),
                (t.radius = 0.5 * this.getSize(e).length()),
                t
              );
            };
          })(),
          intersect: function (e) {
            return (
              this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
            );
          },
          union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this;
          },
          applyMatrix4:
            ((nr = [
              new tr(),
              new tr(),
              new tr(),
              new tr(),
              new tr(),
              new tr(),
              new tr(),
              new tr(),
            ]),
            function (e) {
              return this.isEmpty()
                ? this
                : (nr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                  nr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                  nr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                  nr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                  nr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                  nr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                  nr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                  nr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                  this.setFromPoints(nr),
                  this);
            }),
          translate: function (e) {
            return this.min.add(e), this.max.add(e), this;
          },
          equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max);
          },
        }),
        Object.assign(gr.prototype, {
          set: function (e, t) {
            return this.center.copy(e), (this.radius = t), this;
          },
          setFromPoints:
            ((ar = new vr()),
            function (e, t) {
              var r = this.center;
              void 0 !== t ? r.copy(t) : ar.setFromPoints(e).getCenter(r);
              for (var n = 0, i = 0, a = e.length; i < a; i++)
                n = Math.max(n, r.distanceToSquared(e[i]));
              return (this.radius = Math.sqrt(n)), this;
            }),
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return this.center.copy(e.center), (this.radius = e.radius), this;
          },
          empty: function () {
            return this.radius <= 0;
          },
          containsPoint: function (e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius;
          },
          distanceToPoint: function (e) {
            return e.distanceTo(this.center) - this.radius;
          },
          intersectsSphere: function (e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t;
          },
          intersectsBox: function (e) {
            return e.intersectsSphere(this);
          },
          intersectsPlane: function (e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
          },
          clampPoint: function (e, t) {
            var r = this.center.distanceToSquared(e);
            return (
              void 0 === t &&
                (console.warn('THREE.Sphere: .clampPoint() target is now required'),
                (t = new tr())),
              t.copy(e),
              r > this.radius * this.radius &&
                (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)),
              t
            );
          },
          getBoundingBox: function (e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Sphere: .getBoundingBox() target is now required'),
                (e = new vr())),
              e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e
            );
          },
          applyMatrix4: function (e) {
            return (
              this.center.applyMatrix4(e), (this.radius = this.radius * e.getMaxScaleOnAxis()), this
            );
          },
          translate: function (e) {
            return this.center.add(e), this;
          },
          equals: function (e) {
            return e.center.equals(this.center) && e.radius === this.radius;
          },
        }),
        Object.assign(yr.prototype, {
          set: function (e, t) {
            return this.normal.copy(e), (this.constant = t), this;
          },
          setComponents: function (e, t, r, n) {
            return this.normal.set(e, t, r), (this.constant = n), this;
          },
          setFromNormalAndCoplanarPoint: function (e, t) {
            return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
          },
          setFromCoplanarPoints: (function () {
            var e = new tr(),
              t = new tr();
            return function (r, n, i) {
              var a = e.subVectors(i, n).cross(t.subVectors(r, n)).normalize();
              return this.setFromNormalAndCoplanarPoint(a, r), this;
            };
          })(),
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return this.normal.copy(e.normal), (this.constant = e.constant), this;
          },
          normalize: function () {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), (this.constant *= e), this;
          },
          negate: function () {
            return (this.constant *= -1), this.normal.negate(), this;
          },
          distanceToPoint: function (e) {
            return this.normal.dot(e) + this.constant;
          },
          distanceToSphere: function (e) {
            return this.distanceToPoint(e.center) - e.radius;
          },
          projectPoint: function (e, t) {
            return (
              void 0 === t &&
                (console.warn('THREE.Plane: .projectPoint() target is now required'),
                (t = new tr())),
              t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
            );
          },
          intersectLine: (function () {
            var e = new tr();
            return function (t, r) {
              void 0 === r &&
                (console.warn('THREE.Plane: .intersectLine() target is now required'),
                (r = new tr()));
              var n = t.delta(e),
                i = this.normal.dot(n);
              if (0 === i) return 0 === this.distanceToPoint(t.start) ? r.copy(t.start) : void 0;
              var a = -(t.start.dot(this.normal) + this.constant) / i;
              return a < 0 || a > 1 ? void 0 : r.copy(n).multiplyScalar(a).add(t.start);
            };
          })(),
          intersectsLine: function (e) {
            var t = this.distanceToPoint(e.start),
              r = this.distanceToPoint(e.end);
            return (t < 0 && r > 0) || (r < 0 && t > 0);
          },
          intersectsBox: function (e) {
            return e.intersectsPlane(this);
          },
          intersectsSphere: function (e) {
            return e.intersectsPlane(this);
          },
          coplanarPoint: function (e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Plane: .coplanarPoint() target is now required'),
                (e = new tr())),
              e.copy(this.normal).multiplyScalar(-this.constant)
            );
          },
          applyMatrix4: (function () {
            var e = new tr(),
              t = new rr();
            return function (r, n) {
              var i = n || t.getNormalMatrix(r),
                a = this.coplanarPoint(e).applyMatrix4(r),
                o = this.normal.applyMatrix3(i).normalize();
              return (this.constant = -a.dot(o)), this;
            };
          })(),
          translate: function (e) {
            return (this.constant -= e.dot(this.normal)), this;
          },
          equals: function (e) {
            return e.normal.equals(this.normal) && e.constant === this.constant;
          },
        }),
        Object.assign(xr.prototype, {
          set: function (e, t, r, n, i, a) {
            var o = this.planes;
            return (
              o[0].copy(e),
              o[1].copy(t),
              o[2].copy(r),
              o[3].copy(n),
              o[4].copy(i),
              o[5].copy(a),
              this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            for (var t = this.planes, r = 0; r < 6; r++) t[r].copy(e.planes[r]);
            return this;
          },
          setFromMatrix: function (e) {
            var t = this.planes,
              r = e.elements,
              n = r[0],
              i = r[1],
              a = r[2],
              o = r[3],
              s = r[4],
              c = r[5],
              u = r[6],
              l = r[7],
              h = r[8],
              d = r[9],
              p = r[10],
              f = r[11],
              m = r[12],
              v = r[13],
              g = r[14],
              y = r[15];
            return (
              t[0].setComponents(o - n, l - s, f - h, y - m).normalize(),
              t[1].setComponents(o + n, l + s, f + h, y + m).normalize(),
              t[2].setComponents(o + i, l + c, f + d, y + v).normalize(),
              t[3].setComponents(o - i, l - c, f - d, y - v).normalize(),
              t[4].setComponents(o - a, l - u, f - p, y - g).normalize(),
              t[5].setComponents(o + a, l + u, f + p, y + g).normalize(),
              this
            );
          },
          intersectsObject:
            ((sr = new gr()),
            function (e) {
              var t = e.geometry;
              return (
                null === t.boundingSphere && t.computeBoundingSphere(),
                sr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
                this.intersectsSphere(sr)
              );
            }),
          intersectsSprite: (function () {
            var e = new gr();
            return function (t) {
              return (
                e.center.set(0, 0, 0),
                (e.radius = 0.7071067811865476),
                e.applyMatrix4(t.matrixWorld),
                this.intersectsSphere(e)
              );
            };
          })(),
          intersectsSphere: function (e) {
            for (var t = this.planes, r = e.center, n = -e.radius, i = 0; i < 6; i++) {
              if (t[i].distanceToPoint(r) < n) return !1;
            }
            return !0;
          },
          intersectsBox:
            ((or = new tr()),
            function (e) {
              for (var t = this.planes, r = 0; r < 6; r++) {
                var n = t[r];
                if (
                  ((or.x = n.normal.x > 0 ? e.max.x : e.min.x),
                  (or.y = n.normal.y > 0 ? e.max.y : e.min.y),
                  (or.z = n.normal.z > 0 ? e.max.z : e.min.z),
                  n.distanceToPoint(or) < 0)
                )
                  return !1;
              }
              return !0;
            }),
          containsPoint: function (e) {
            for (var t = this.planes, r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
            return !0;
          },
        });
      var br = {
        alphamap_fragment:
          '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif',
        alphamap_pars_fragment: '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
        alphatest_fragment:
          '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif',
        aomap_fragment:
          '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif',
        aomap_pars_fragment:
          '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
        begin_vertex: 'vec3 transformed = vec3( position );',
        beginnormal_vertex: 'vec3 objectNormal = vec3( normal );',
        bsdfs:
          'vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}',
        bumpmap_pars_fragment:
          '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
        clipping_planes_fragment:
          '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
        clipping_planes_pars_fragment:
          '#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
        clipping_planes_pars_vertex:
          '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif',
        clipping_planes_vertex:
          '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif',
        color_fragment: '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif',
        color_pars_fragment: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
        color_pars_vertex: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
        color_vertex: '#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif',
        common:
          '#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}',
        cube_uv_reflection_fragment:
          '#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif',
        defaultnormal_vertex:
          'vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif',
        displacementmap_pars_vertex:
          '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
        displacementmap_vertex:
          '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif',
        emissivemap_fragment:
          '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
        emissivemap_pars_fragment:
          '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
        encodings_fragment: 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
        encodings_pars_fragment:
          '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}',
        envmap_fragment:
          '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
        envmap_pars_fragment:
          '#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
        envmap_pars_vertex:
          '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
        envmap_physical_pars_fragment:
          '#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif',
        envmap_vertex:
          '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
        fog_vertex: '#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif',
        fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif',
        fog_fragment:
          '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
        fog_pars_fragment:
          '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
        gradientmap_pars_fragment:
          '#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif',
        lightmap_fragment:
          '#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif',
        lightmap_pars_fragment:
          '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
        lights_lambert_vertex:
          'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif',
        lights_pars_begin:
          'uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif',
        lights_phong_fragment:
          'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
        lights_phong_pars_fragment:
          'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)',
        lights_physical_fragment:
          'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif',
        lights_physical_pars_fragment:
          'struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
        lights_fragment_begin:
          '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif',
        lights_fragment_maps:
          '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif',
        lights_fragment_end:
          '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif',
        logdepthbuf_fragment:
          '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
        logdepthbuf_pars_fragment:
          '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif',
        logdepthbuf_pars_vertex:
          '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
        logdepthbuf_vertex:
          '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif',
        map_fragment:
          '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif',
        map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
        map_particle_fragment:
          '#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif',
        map_particle_pars_fragment:
          '#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif',
        metalnessmap_fragment:
          'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
        metalnessmap_pars_fragment:
          '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
        morphnormal_vertex:
          '#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif',
        morphtarget_pars_vertex:
          '#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',
        morphtarget_vertex:
          '#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif',
        normal_fragment_begin:
          '#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif',
        normal_fragment_maps:
          '#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif',
        normalmap_pars_fragment:
          '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif',
        packing:
          'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}',
        premultiplied_alpha_fragment:
          '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
        project_vertex:
          'vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;',
        dithering_fragment:
          '#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
        dithering_pars_fragment:
          '#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
        roughnessmap_fragment:
          'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
        roughnessmap_pars_fragment:
          '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
        shadowmap_pars_fragment:
          '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
        shadowmap_pars_vertex:
          '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif',
        shadowmap_vertex:
          '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif',
        shadowmask_pars_fragment:
          'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}',
        skinbase_vertex:
          '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
        skinning_pars_vertex:
          '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif',
        skinning_vertex:
          '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
        skinnormal_vertex:
          '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif',
        specularmap_fragment:
          'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
        specularmap_pars_fragment:
          '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
        tonemapping_fragment:
          '#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
        tonemapping_pars_fragment:
          '#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}',
        uv_pars_fragment:
          '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif',
        uv_pars_vertex:
          '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif',
        uv_vertex:
          '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
        uv2_pars_fragment:
          '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
        uv2_pars_vertex:
          '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif',
        uv2_vertex: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif',
        worldpos_vertex:
          '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif',
        background_frag:
          'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
        background_vert:
          'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
        cube_frag:
          'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
        cube_vert:
          'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
        depth_frag:
          '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}',
        depth_vert:
          '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}',
        distanceRGBA_frag:
          '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
        distanceRGBA_vert:
          '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
        equirect_frag:
          'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
        equirect_vert:
          'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
        linedashed_frag:
          'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        linedashed_vert:
          'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
        meshbasic_frag:
          'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        meshbasic_vert:
          '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
        meshlambert_frag:
          'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        meshlambert_vert:
          '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        meshmatcap_frag:
          '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        meshmatcap_vert:
          '#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
        meshphong_frag:
          '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        meshphong_vert:
          '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        meshphysical_frag:
          '#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        meshphysical_vert:
          '#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        normal_frag:
          '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}',
        normal_vert:
          '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
        points_frag:
          'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        points_vert:
          'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
        shadow_frag:
          'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}',
        shadow_vert:
          '#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        sprite_frag:
          'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        sprite_vert:
          'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
      };
      function wr(e) {
        var t = {};
        for (var r in e)
          for (var n in ((t[r] = {}), e[r])) {
            var i = e[r][n];
            i &&
            (i.isColor ||
              i.isMatrix3 ||
              i.isMatrix4 ||
              i.isVector2 ||
              i.isVector3 ||
              i.isVector4 ||
              i.isTexture)
              ? (t[r][n] = i.clone())
              : Array.isArray(i)
              ? (t[r][n] = i.slice())
              : (t[r][n] = i);
          }
        return t;
      }
      function _r(e) {
        for (var t = {}, r = 0; r < e.length; r++) {
          var n = wr(e[r]);
          for (var i in n) t[i] = n[i];
        }
        return t;
      }
      var Mr,
        Sr,
        Er,
        Tr = { clone: wr, merge: _r },
        Ar = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        };
      function Lr(e, t, r) {
        return void 0 === t && void 0 === r ? this.set(e) : this.setRGB(e, t, r);
      }
      Object.assign(Lr.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function (e) {
          return (
            e && e.isColor
              ? this.copy(e)
              : 'number' == typeof e
              ? this.setHex(e)
              : 'string' == typeof e && this.setStyle(e),
            this
          );
        },
        setScalar: function (e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        },
        setHex: function (e) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (255 & e) / 255),
            this
          );
        },
        setRGB: function (e, t, r) {
          return (this.r = e), (this.g = t), (this.b = r), this;
        },
        setHSL: (function () {
          function e(e, t, r) {
            return (
              r < 0 && (r += 1),
              r > 1 && (r -= 1),
              r < 1 / 6
                ? e + 6 * (t - e) * r
                : r < 0.5
                ? t
                : r < 2 / 3
                ? e + 6 * (t - e) * (2 / 3 - r)
                : e
            );
          }
          return function (t, r, n) {
            if (
              ((t = Kt.euclideanModulo(t, 1)),
              (r = Kt.clamp(r, 0, 1)),
              (n = Kt.clamp(n, 0, 1)),
              0 === r)
            )
              this.r = this.g = this.b = n;
            else {
              var i = n <= 0.5 ? n * (1 + r) : n + r - n * r,
                a = 2 * n - i;
              (this.r = e(a, i, t + 1 / 3)), (this.g = e(a, i, t)), (this.b = e(a, i, t - 1 / 3));
            }
            return this;
          };
        })(),
        setStyle: function (e) {
          function t(t) {
            void 0 !== t &&
              parseFloat(t) < 1 &&
              console.warn('THREE.Color: Alpha component of ' + e + ' will be ignored.');
          }
          var r;
          if ((r = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e))) {
            var n,
              i = r[1],
              a = r[2];
            switch (i) {
              case 'rgb':
              case 'rgba':
                if ((n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)))
                  return (
                    (this.r = Math.min(255, parseInt(n[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(n[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(n[3], 10)) / 255),
                    t(n[5]),
                    this
                  );
                if (
                  (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    a,
                  ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(n[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(n[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(n[3], 10)) / 100),
                    t(n[5]),
                    this
                  );
                break;
              case 'hsl':
              case 'hsla':
                if (
                  (n =
                    /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                      a,
                    ))
                ) {
                  var o = parseFloat(n[1]) / 360,
                    s = parseInt(n[2], 10) / 100,
                    c = parseInt(n[3], 10) / 100;
                  return t(n[5]), this.setHSL(o, s, c);
                }
            }
          } else if ((r = /^\#([A-Fa-f0-9]+)$/.exec(e))) {
            var u,
              l = (u = r[1]).length;
            if (3 === l)
              return (
                (this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255),
                (this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255),
                (this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255),
                this
              );
            if (6 === l)
              return (
                (this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255),
                (this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255),
                (this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255),
                this
              );
          }
          e &&
            e.length > 0 &&
            (void 0 !== (u = Ar[e])
              ? this.setHex(u)
              : console.warn('THREE.Color: Unknown color ' + e));
          return this;
        },
        clone: function () {
          return new this.constructor(this.r, this.g, this.b);
        },
        copy: function (e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        },
        copyGammaToLinear: function (e, t) {
          return (
            void 0 === t && (t = 2),
            (this.r = Math.pow(e.r, t)),
            (this.g = Math.pow(e.g, t)),
            (this.b = Math.pow(e.b, t)),
            this
          );
        },
        copyLinearToGamma: function (e, t) {
          void 0 === t && (t = 2);
          var r = t > 0 ? 1 / t : 1;
          return (
            (this.r = Math.pow(e.r, r)),
            (this.g = Math.pow(e.g, r)),
            (this.b = Math.pow(e.b, r)),
            this
          );
        },
        convertGammaToLinear: function (e) {
          return this.copyGammaToLinear(this, e), this;
        },
        convertLinearToGamma: function (e) {
          return this.copyLinearToGamma(this, e), this;
        },
        copySRGBToLinear: (function () {
          function e(e) {
            return e < 0.04045 ? 0.0773993808 * e : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
          }
          return function (t) {
            return (this.r = e(t.r)), (this.g = e(t.g)), (this.b = e(t.b)), this;
          };
        })(),
        copyLinearToSRGB: (function () {
          function e(e) {
            return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
          }
          return function (t) {
            return (this.r = e(t.r)), (this.g = e(t.g)), (this.b = e(t.b)), this;
          };
        })(),
        convertSRGBToLinear: function () {
          return this.copySRGBToLinear(this), this;
        },
        convertLinearToSRGB: function () {
          return this.copyLinearToSRGB(this), this;
        },
        getHex: function () {
          return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0);
        },
        getHexString: function () {
          return ('000000' + this.getHex().toString(16)).slice(-6);
        },
        getHSL: function (e) {
          void 0 === e &&
            (console.warn('THREE.Color: .getHSL() target is now required'),
            (e = { h: 0, s: 0, l: 0 }));
          var t,
            r,
            n = this.r,
            i = this.g,
            a = this.b,
            o = Math.max(n, i, a),
            s = Math.min(n, i, a),
            c = (s + o) / 2;
          if (s === o) (t = 0), (r = 0);
          else {
            var u = o - s;
            switch (((r = c <= 0.5 ? u / (o + s) : u / (2 - o - s)), o)) {
              case n:
                t = (i - a) / u + (i < a ? 6 : 0);
                break;
              case i:
                t = (a - n) / u + 2;
                break;
              case a:
                t = (n - i) / u + 4;
            }
            t /= 6;
          }
          return (e.h = t), (e.s = r), (e.l = c), e;
        },
        getStyle: function () {
          return (
            'rgb(' +
            ((255 * this.r) | 0) +
            ',' +
            ((255 * this.g) | 0) +
            ',' +
            ((255 * this.b) | 0) +
            ')'
          );
        },
        offsetHSL:
          ((Er = {}),
          function (e, t, r) {
            return (
              this.getHSL(Er),
              (Er.h += e),
              (Er.s += t),
              (Er.l += r),
              this.setHSL(Er.h, Er.s, Er.l),
              this
            );
          }),
        add: function (e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        },
        addColors: function (e, t) {
          return (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this;
        },
        addScalar: function (e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        },
        sub: function (e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        },
        multiply: function (e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        },
        multiplyScalar: function (e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        },
        lerp: function (e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        },
        lerpHSL:
          ((Mr = { h: 0, s: 0, l: 0 }),
          (Sr = { h: 0, s: 0, l: 0 }),
          function (e, t) {
            this.getHSL(Mr), e.getHSL(Sr);
            var r = Kt.lerp(Mr.h, Sr.h, t),
              n = Kt.lerp(Mr.s, Sr.s, t),
              i = Kt.lerp(Mr.l, Sr.l, t);
            return this.setHSL(r, n, i), this;
          }),
        equals: function (e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        },
        fromArray: function (e, t) {
          return (
            void 0 === t && (t = 0), (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        },
        toArray: function (e, t) {
          return (
            void 0 === e && (e = []),
            void 0 === t && (t = 0),
            (e[t] = this.r),
            (e[t + 1] = this.g),
            (e[t + 2] = this.b),
            e
          );
        },
        toJSON: function () {
          return this.getHex();
        },
      });
      var Rr,
        Cr = {
          common: {
            diffuse: { value: new Lr(15658734) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new rr() },
            alphaMap: { value: null },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: { normalMap: { value: null }, normalScale: { value: new Qt(1, 1) } },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Lr(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            directionalLights: {
              value: [],
              properties: {
                direction: {},
                color: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                decay: {},
                distance: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
          },
          points: {
            diffuse: { value: new Lr(15658734) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            uvTransform: { value: new rr() },
          },
          sprite: {
            diffuse: { value: new Lr(15658734) },
            opacity: { value: 1 },
            center: { value: new Qt(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            uvTransform: { value: new rr() },
          },
        },
        Pr = {
          basic: {
            uniforms: _r([Cr.common, Cr.specularmap, Cr.envmap, Cr.aomap, Cr.lightmap, Cr.fog]),
            vertexShader: br.meshbasic_vert,
            fragmentShader: br.meshbasic_frag,
          },
          lambert: {
            uniforms: _r([
              Cr.common,
              Cr.specularmap,
              Cr.envmap,
              Cr.aomap,
              Cr.lightmap,
              Cr.emissivemap,
              Cr.fog,
              Cr.lights,
              { emissive: { value: new Lr(0) } },
            ]),
            vertexShader: br.meshlambert_vert,
            fragmentShader: br.meshlambert_frag,
          },
          phong: {
            uniforms: _r([
              Cr.common,
              Cr.specularmap,
              Cr.envmap,
              Cr.aomap,
              Cr.lightmap,
              Cr.emissivemap,
              Cr.bumpmap,
              Cr.normalmap,
              Cr.displacementmap,
              Cr.gradientmap,
              Cr.fog,
              Cr.lights,
              {
                emissive: { value: new Lr(0) },
                specular: { value: new Lr(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: br.meshphong_vert,
            fragmentShader: br.meshphong_frag,
          },
          standard: {
            uniforms: _r([
              Cr.common,
              Cr.envmap,
              Cr.aomap,
              Cr.lightmap,
              Cr.emissivemap,
              Cr.bumpmap,
              Cr.normalmap,
              Cr.displacementmap,
              Cr.roughnessmap,
              Cr.metalnessmap,
              Cr.fog,
              Cr.lights,
              {
                emissive: { value: new Lr(0) },
                roughness: { value: 0.5 },
                metalness: { value: 0.5 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: br.meshphysical_vert,
            fragmentShader: br.meshphysical_frag,
          },
          matcap: {
            uniforms: _r([
              Cr.common,
              Cr.bumpmap,
              Cr.normalmap,
              Cr.displacementmap,
              Cr.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: br.meshmatcap_vert,
            fragmentShader: br.meshmatcap_frag,
          },
          points: {
            uniforms: _r([Cr.points, Cr.fog]),
            vertexShader: br.points_vert,
            fragmentShader: br.points_frag,
          },
          dashed: {
            uniforms: _r([
              Cr.common,
              Cr.fog,
              { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } },
            ]),
            vertexShader: br.linedashed_vert,
            fragmentShader: br.linedashed_frag,
          },
          depth: {
            uniforms: _r([Cr.common, Cr.displacementmap]),
            vertexShader: br.depth_vert,
            fragmentShader: br.depth_frag,
          },
          normal: {
            uniforms: _r([
              Cr.common,
              Cr.bumpmap,
              Cr.normalmap,
              Cr.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: br.normal_vert,
            fragmentShader: br.normal_frag,
          },
          sprite: {
            uniforms: _r([Cr.sprite, Cr.fog]),
            vertexShader: br.sprite_vert,
            fragmentShader: br.sprite_frag,
          },
          background: {
            uniforms: { uvTransform: { value: new rr() }, t2D: { value: null } },
            vertexShader: br.background_vert,
            fragmentShader: br.background_frag,
          },
          cube: {
            uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } },
            vertexShader: br.cube_vert,
            fragmentShader: br.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: br.equirect_vert,
            fragmentShader: br.equirect_frag,
          },
          distanceRGBA: {
            uniforms: _r([
              Cr.common,
              Cr.displacementmap,
              {
                referencePosition: { value: new tr() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: br.distanceRGBA_vert,
            fragmentShader: br.distanceRGBA_frag,
          },
          shadow: {
            uniforms: _r([
              Cr.lights,
              Cr.fog,
              { color: { value: new Lr(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: br.shadow_vert,
            fragmentShader: br.shadow_frag,
          },
        };
      function Or() {
        var e = null,
          t = !1,
          r = null;
        function n(i, a) {
          !1 !== t && (r(i, a), e.requestAnimationFrame(n));
        }
        return {
          start: function () {
            !0 !== t && null !== r && (e.requestAnimationFrame(n), (t = !0));
          },
          stop: function () {
            t = !1;
          },
          setAnimationLoop: function (e) {
            r = e;
          },
          setContext: function (t) {
            e = t;
          },
        };
      }
      function Ir(e) {
        var t = new WeakMap();
        return {
          get: function (e) {
            return e.isInterleavedBufferAttribute && (e = e.data), t.get(e);
          },
          remove: function (r) {
            r.isInterleavedBufferAttribute && (r = r.data);
            var n = t.get(r);
            n && (e.deleteBuffer(n.buffer), t.delete(r));
          },
          update: function (r, n) {
            r.isInterleavedBufferAttribute && (r = r.data);
            var i = t.get(r);
            void 0 === i
              ? t.set(
                  r,
                  (function (t, r) {
                    var n = t.array,
                      i = t.dynamic ? 35048 : 35044,
                      a = e.createBuffer();
                    e.bindBuffer(r, a), e.bufferData(r, n, i), t.onUploadCallback();
                    var o = 5126;
                    return (
                      n instanceof Float32Array
                        ? (o = 5126)
                        : n instanceof Float64Array
                        ? console.warn(
                            'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.',
                          )
                        : n instanceof Uint16Array
                        ? (o = 5123)
                        : n instanceof Int16Array
                        ? (o = 5122)
                        : n instanceof Uint32Array
                        ? (o = 5125)
                        : n instanceof Int32Array
                        ? (o = 5124)
                        : n instanceof Int8Array
                        ? (o = 5120)
                        : n instanceof Uint8Array && (o = 5121),
                      {
                        buffer: a,
                        type: o,
                        bytesPerElement: n.BYTES_PER_ELEMENT,
                        version: t.version,
                      }
                    );
                  })(r, n),
                )
              : i.version < r.version &&
                ((function (t, r, n) {
                  var i = r.array,
                    a = r.updateRange;
                  e.bindBuffer(n, t),
                    !1 === r.dynamic
                      ? e.bufferData(n, i, 35044)
                      : -1 === a.count
                      ? e.bufferSubData(n, 0, i)
                      : 0 === a.count
                      ? console.error(
                          'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.',
                        )
                      : (e.bufferSubData(
                          n,
                          a.offset * i.BYTES_PER_ELEMENT,
                          i.subarray(a.offset, a.offset + a.count),
                        ),
                        (a.count = -1));
                })(i.buffer, r, n),
                (i.version = r.version));
          },
        };
      }
      function Dr(e, t, r, n, i, a) {
        (this.a = e),
          (this.b = t),
          (this.c = r),
          (this.normal = n && n.isVector3 ? n : new tr()),
          (this.vertexNormals = Array.isArray(n) ? n : []),
          (this.color = i && i.isColor ? i : new Lr()),
          (this.vertexColors = Array.isArray(i) ? i : []),
          (this.materialIndex = void 0 !== a ? a : 0);
      }
      function Br(e, t, r, n) {
        (this._x = e || 0),
          (this._y = t || 0),
          (this._z = r || 0),
          (this._order = n || Br.DefaultOrder);
      }
      function Nr() {
        this.mask = 1;
      }
      (Pr.physical = {
        uniforms: _r([
          Pr.standard.uniforms,
          { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } },
        ]),
        vertexShader: br.meshphysical_vert,
        fragmentShader: br.meshphysical_frag,
      }),
        Object.assign(Dr.prototype, {
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            (this.a = e.a),
              (this.b = e.b),
              (this.c = e.c),
              this.normal.copy(e.normal),
              this.color.copy(e.color),
              (this.materialIndex = e.materialIndex);
            for (var t = 0, r = e.vertexNormals.length; t < r; t++)
              this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0, r = e.vertexColors.length; t < r; t++)
              this.vertexColors[t] = e.vertexColors[t].clone();
            return this;
          },
        }),
        (Br.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']),
        (Br.DefaultOrder = 'XYZ'),
        Object.defineProperties(Br.prototype, {
          x: {
            get: function () {
              return this._x;
            },
            set: function (e) {
              (this._x = e), this.onChangeCallback();
            },
          },
          y: {
            get: function () {
              return this._y;
            },
            set: function (e) {
              (this._y = e), this.onChangeCallback();
            },
          },
          z: {
            get: function () {
              return this._z;
            },
            set: function (e) {
              (this._z = e), this.onChangeCallback();
            },
          },
          order: {
            get: function () {
              return this._order;
            },
            set: function (e) {
              (this._order = e), this.onChangeCallback();
            },
          },
        }),
        Object.assign(Br.prototype, {
          isEuler: !0,
          set: function (e, t, r, n) {
            return (
              (this._x = e),
              (this._y = t),
              (this._z = r),
              (this._order = n || this._order),
              this.onChangeCallback(),
              this
            );
          },
          clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order);
          },
          copy: function (e) {
            return (
              (this._x = e._x),
              (this._y = e._y),
              (this._z = e._z),
              (this._order = e._order),
              this.onChangeCallback(),
              this
            );
          },
          setFromRotationMatrix: function (e, t, r) {
            var n = Kt.clamp,
              i = e.elements,
              a = i[0],
              o = i[4],
              s = i[8],
              c = i[1],
              u = i[5],
              l = i[9],
              h = i[2],
              d = i[6],
              p = i[10];
            return (
              'XYZ' === (t = t || this._order)
                ? ((this._y = Math.asin(n(s, -1, 1))),
                  Math.abs(s) < 0.99999
                    ? ((this._x = Math.atan2(-l, p)), (this._z = Math.atan2(-o, a)))
                    : ((this._x = Math.atan2(d, u)), (this._z = 0)))
                : 'YXZ' === t
                ? ((this._x = Math.asin(-n(l, -1, 1))),
                  Math.abs(l) < 0.99999
                    ? ((this._y = Math.atan2(s, p)), (this._z = Math.atan2(c, u)))
                    : ((this._y = Math.atan2(-h, a)), (this._z = 0)))
                : 'ZXY' === t
                ? ((this._x = Math.asin(n(d, -1, 1))),
                  Math.abs(d) < 0.99999
                    ? ((this._y = Math.atan2(-h, p)), (this._z = Math.atan2(-o, u)))
                    : ((this._y = 0), (this._z = Math.atan2(c, a))))
                : 'ZYX' === t
                ? ((this._y = Math.asin(-n(h, -1, 1))),
                  Math.abs(h) < 0.99999
                    ? ((this._x = Math.atan2(d, p)), (this._z = Math.atan2(c, a)))
                    : ((this._x = 0), (this._z = Math.atan2(-o, u))))
                : 'YZX' === t
                ? ((this._z = Math.asin(n(c, -1, 1))),
                  Math.abs(c) < 0.99999
                    ? ((this._x = Math.atan2(-l, u)), (this._y = Math.atan2(-h, a)))
                    : ((this._x = 0), (this._y = Math.atan2(s, p))))
                : 'XZY' === t
                ? ((this._z = Math.asin(-n(o, -1, 1))),
                  Math.abs(o) < 0.99999
                    ? ((this._x = Math.atan2(d, u)), (this._y = Math.atan2(s, a)))
                    : ((this._x = Math.atan2(-l, p)), (this._y = 0)))
                : console.warn(
                    'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + t,
                  ),
              (this._order = t),
              !1 !== r && this.onChangeCallback(),
              this
            );
          },
          setFromQuaternion: (function () {
            var e = new $t();
            return function (t, r, n) {
              return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, r, n);
            };
          })(),
          setFromVector3: function (e, t) {
            return this.set(e.x, e.y, e.z, t || this._order);
          },
          reorder:
            ((Rr = new er()),
            function (e) {
              return Rr.setFromEuler(this), this.setFromQuaternion(Rr, e);
            }),
          equals: function (e) {
            return (
              e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            );
          },
          fromArray: function (e) {
            return (
              (this._x = e[0]),
              (this._y = e[1]),
              (this._z = e[2]),
              void 0 !== e[3] && (this._order = e[3]),
              this.onChangeCallback(),
              this
            );
          },
          toArray: function (e, t) {
            return (
              void 0 === e && (e = []),
              void 0 === t && (t = 0),
              (e[t] = this._x),
              (e[t + 1] = this._y),
              (e[t + 2] = this._z),
              (e[t + 3] = this._order),
              e
            );
          },
          toVector3: function (e) {
            return e ? e.set(this._x, this._y, this._z) : new tr(this._x, this._y, this._z);
          },
          onChange: function (e) {
            return (this.onChangeCallback = e), this;
          },
          onChangeCallback: function () {},
        }),
        Object.assign(Nr.prototype, {
          set: function (e) {
            this.mask = (1 << e) | 0;
          },
          enable: function (e) {
            this.mask |= (1 << e) | 0;
          },
          toggle: function (e) {
            this.mask ^= (1 << e) | 0;
          },
          disable: function (e) {
            this.mask &= ~((1 << e) | 0);
          },
          test: function (e) {
            return 0 != (this.mask & e.mask);
          },
        });
      var Ur,
        Gr,
        Fr,
        zr,
        Hr = 0;
      function kr() {
        Object.defineProperty(this, 'id', { value: Hr++ }),
          (this.uuid = Kt.generateUUID()),
          (this.name = ''),
          (this.type = 'Object3D'),
          (this.parent = null),
          (this.children = []),
          (this.up = kr.DefaultUp.clone());
        var e = new tr(),
          t = new Br(),
          r = new er(),
          n = new tr(1, 1, 1);
        t.onChange(function () {
          r.setFromEuler(t, !1);
        }),
          r.onChange(function () {
            t.setFromQuaternion(r, void 0, !1);
          }),
          Object.defineProperties(this, {
            position: { configurable: !0, enumerable: !0, value: e },
            rotation: { configurable: !0, enumerable: !0, value: t },
            quaternion: { configurable: !0, enumerable: !0, value: r },
            scale: { configurable: !0, enumerable: !0, value: n },
            modelViewMatrix: { value: new $t() },
            normalMatrix: { value: new rr() },
          }),
          (this.matrix = new $t()),
          (this.matrixWorld = new $t()),
          (this.matrixAutoUpdate = kr.DefaultMatrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = !1),
          (this.layers = new Nr()),
          (this.visible = !0),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !0),
          (this.renderOrder = 0),
          (this.userData = {});
      }
      (kr.DefaultUp = new tr(0, 1, 0)),
        (kr.DefaultMatrixAutoUpdate = !0),
        (kr.prototype = Object.assign(Object.create(n.prototype), {
          constructor: kr,
          isObject3D: !0,
          onBeforeRender: function () {},
          onAfterRender: function () {},
          applyMatrix: function (e) {
            this.matrix.multiplyMatrices(e, this.matrix),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          },
          applyQuaternion: function (e) {
            return this.quaternion.premultiply(e), this;
          },
          setRotationFromAxisAngle: function (e, t) {
            this.quaternion.setFromAxisAngle(e, t);
          },
          setRotationFromEuler: function (e) {
            this.quaternion.setFromEuler(e, !0);
          },
          setRotationFromMatrix: function (e) {
            this.quaternion.setFromRotationMatrix(e);
          },
          setRotationFromQuaternion: function (e) {
            this.quaternion.copy(e);
          },
          rotateOnAxis:
            ((zr = new er()),
            function (e, t) {
              return zr.setFromAxisAngle(e, t), this.quaternion.multiply(zr), this;
            }),
          rotateOnWorldAxis: (function () {
            var e = new er();
            return function (t, r) {
              return e.setFromAxisAngle(t, r), this.quaternion.premultiply(e), this;
            };
          })(),
          rotateX: (function () {
            var e = new tr(1, 0, 0);
            return function (t) {
              return this.rotateOnAxis(e, t);
            };
          })(),
          rotateY: (function () {
            var e = new tr(0, 1, 0);
            return function (t) {
              return this.rotateOnAxis(e, t);
            };
          })(),
          rotateZ: (function () {
            var e = new tr(0, 0, 1);
            return function (t) {
              return this.rotateOnAxis(e, t);
            };
          })(),
          translateOnAxis: (function () {
            var e = new tr();
            return function (t, r) {
              return (
                e.copy(t).applyQuaternion(this.quaternion),
                this.position.add(e.multiplyScalar(r)),
                this
              );
            };
          })(),
          translateX: (function () {
            var e = new tr(1, 0, 0);
            return function (t) {
              return this.translateOnAxis(e, t);
            };
          })(),
          translateY: (function () {
            var e = new tr(0, 1, 0);
            return function (t) {
              return this.translateOnAxis(e, t);
            };
          })(),
          translateZ: (function () {
            var e = new tr(0, 0, 1);
            return function (t) {
              return this.translateOnAxis(e, t);
            };
          })(),
          localToWorld: function (e) {
            return e.applyMatrix4(this.matrixWorld);
          },
          worldToLocal:
            ((Fr = new $t()),
            function (e) {
              return e.applyMatrix4(Fr.getInverse(this.matrixWorld));
            }),
          lookAt: (function () {
            var e = new er(),
              t = new $t(),
              r = new tr(),
              n = new tr();
            return function (i, a, o) {
              i.isVector3 ? r.copy(i) : r.set(i, a, o);
              var s = this.parent;
              this.updateWorldMatrix(!0, !1),
                n.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? t.lookAt(n, r, this.up) : t.lookAt(r, n, this.up),
                this.quaternion.setFromRotationMatrix(t),
                s &&
                  (t.extractRotation(s.matrixWorld),
                  e.setFromRotationMatrix(t),
                  this.quaternion.premultiply(e.inverse()));
            };
          })(),
          add: function (e) {
            if (arguments.length > 1) {
              for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
              return this;
            }
            return e === this
              ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  e,
                ),
                this)
              : (e && e.isObject3D
                  ? (null !== e.parent && e.parent.remove(e),
                    (e.parent = this),
                    e.dispatchEvent({ type: 'added' }),
                    this.children.push(e))
                  : console.error(
                      'THREE.Object3D.add: object not an instance of THREE.Object3D.',
                      e,
                    ),
                this);
          },
          remove: function (e) {
            if (arguments.length > 1) {
              for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
              return this;
            }
            var r = this.children.indexOf(e);
            return (
              -1 !== r &&
                ((e.parent = null),
                e.dispatchEvent({ type: 'removed' }),
                this.children.splice(r, 1)),
              this
            );
          },
          getObjectById: function (e) {
            return this.getObjectByProperty('id', e);
          },
          getObjectByName: function (e) {
            return this.getObjectByProperty('name', e);
          },
          getObjectByProperty: function (e, t) {
            if (this[e] === t) return this;
            for (var r = 0, n = this.children.length; r < n; r++) {
              var i = this.children[r].getObjectByProperty(e, t);
              if (void 0 !== i) return i;
            }
          },
          getWorldPosition: function (e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Object3D: .getWorldPosition() target is now required'),
                (e = new tr())),
              this.updateMatrixWorld(!0),
              e.setFromMatrixPosition(this.matrixWorld)
            );
          },
          getWorldQuaternion:
            ((Ur = new tr()),
            (Gr = new tr()),
            function (e) {
              return (
                void 0 === e &&
                  (console.warn('THREE.Object3D: .getWorldQuaternion() target is now required'),
                  (e = new er())),
                this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(Ur, e, Gr),
                e
              );
            }),
          getWorldScale: (function () {
            var e = new tr(),
              t = new er();
            return function (r) {
              return (
                void 0 === r &&
                  (console.warn('THREE.Object3D: .getWorldScale() target is now required'),
                  (r = new tr())),
                this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(e, t, r),
                r
              );
            };
          })(),
          getWorldDirection: function (e) {
            void 0 === e &&
              (console.warn('THREE.Object3D: .getWorldDirection() target is now required'),
              (e = new tr())),
              this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize();
          },
          raycast: function () {},
          traverse: function (e) {
            e(this);
            for (var t = this.children, r = 0, n = t.length; r < n; r++) t[r].traverse(e);
          },
          traverseVisible: function (e) {
            if (!1 !== this.visible) {
              e(this);
              for (var t = this.children, r = 0, n = t.length; r < n; r++) t[r].traverseVisible(e);
            }
          },
          traverseAncestors: function (e) {
            var t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e));
          },
          updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          },
          updateMatrixWorld: function (e) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || e) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                (this.matrixWorldNeedsUpdate = !1),
                (e = !0));
            for (var t = this.children, r = 0, n = t.length; r < n; r++) t[r].updateMatrixWorld(e);
          },
          updateWorldMatrix: function (e, t) {
            var r = this.parent;
            if (
              (!0 === e && null !== r && r.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
              !0 === t)
            )
              for (var n = this.children, i = 0, a = n.length; i < a; i++)
                n[i].updateWorldMatrix(!1, !0);
          },
          toJSON: function (e) {
            var t = void 0 === e || 'string' == typeof e,
              r = {};
            t &&
              ((e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }),
              (r.metadata = { version: 4.5, type: 'Object', generator: 'Object3D.toJSON' }));
            var n = {};
            function i(t, r) {
              return void 0 === t[r.uuid] && (t[r.uuid] = r.toJSON(e)), r.uuid;
            }
            if (
              ((n.uuid = this.uuid),
              (n.type = this.type),
              '' !== this.name && (n.name = this.name),
              !0 === this.castShadow && (n.castShadow = !0),
              !0 === this.receiveShadow && (n.receiveShadow = !0),
              !1 === this.visible && (n.visible = !1),
              !1 === this.frustumCulled && (n.frustumCulled = !1),
              0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
              '{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
              (n.layers = this.layers.mask),
              (n.matrix = this.matrix.toArray()),
              !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
              this.isMesh && this.drawMode !== Nt && (n.drawMode = this.drawMode),
              this.isMesh || this.isLine || this.isPoints)
            ) {
              n.geometry = i(e.geometries, this.geometry);
              var a = this.geometry.parameters;
              if (void 0 !== a && void 0 !== a.shapes) {
                var o = a.shapes;
                if (Array.isArray(o))
                  for (var s = 0, c = o.length; s < c; s++) {
                    var u = o[s];
                    i(e.shapes, u);
                  }
                else i(e.shapes, o);
              }
            }
            if (void 0 !== this.material)
              if (Array.isArray(this.material)) {
                var l = [];
                for (s = 0, c = this.material.length; s < c; s++)
                  l.push(i(e.materials, this.material[s]));
                n.material = l;
              } else n.material = i(e.materials, this.material);
            if (this.children.length > 0) {
              n.children = [];
              for (s = 0; s < this.children.length; s++)
                n.children.push(this.children[s].toJSON(e).object);
            }
            if (t) {
              var h = m(e.geometries),
                d = m(e.materials),
                p = m(e.textures),
                f = m(e.images);
              o = m(e.shapes);
              h.length > 0 && (r.geometries = h),
                d.length > 0 && (r.materials = d),
                p.length > 0 && (r.textures = p),
                f.length > 0 && (r.images = f),
                o.length > 0 && (r.shapes = o);
            }
            return (r.object = n), r;
            function m(e) {
              var t = [];
              for (var r in e) {
                var n = e[r];
                delete n.metadata, t.push(n);
              }
              return t;
            }
          },
          clone: function (e) {
            return new this.constructor().copy(this, e);
          },
          copy: function (e, t) {
            if (
              (void 0 === t && (t = !0),
              (this.name = e.name),
              this.up.copy(e.up),
              this.position.copy(e.position),
              this.quaternion.copy(e.quaternion),
              this.scale.copy(e.scale),
              this.matrix.copy(e.matrix),
              this.matrixWorld.copy(e.matrixWorld),
              (this.matrixAutoUpdate = e.matrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
              (this.layers.mask = e.layers.mask),
              (this.visible = e.visible),
              (this.castShadow = e.castShadow),
              (this.receiveShadow = e.receiveShadow),
              (this.frustumCulled = e.frustumCulled),
              (this.renderOrder = e.renderOrder),
              (this.userData = JSON.parse(JSON.stringify(e.userData))),
              !0 === t)
            )
              for (var r = 0; r < e.children.length; r++) {
                var n = e.children[r];
                this.add(n.clone());
              }
            return this;
          },
        }));
      var Vr,
        jr,
        Wr = 0;
      function qr() {
        Object.defineProperty(this, 'id', { value: (Wr += 2) }),
          (this.uuid = Kt.generateUUID()),
          (this.name = ''),
          (this.type = 'Geometry'),
          (this.vertices = []),
          (this.colors = []),
          (this.faces = []),
          (this.faceVertexUvs = [[]]),
          (this.morphTargets = []),
          (this.morphNormals = []),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.lineDistances = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.elementsNeedUpdate = !1),
          (this.verticesNeedUpdate = !1),
          (this.uvsNeedUpdate = !1),
          (this.normalsNeedUpdate = !1),
          (this.colorsNeedUpdate = !1),
          (this.lineDistancesNeedUpdate = !1),
          (this.groupsNeedUpdate = !1);
      }
      function Xr(e, t, r) {
        if (Array.isArray(e))
          throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        (this.name = ''),
          (this.array = e),
          (this.itemSize = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.normalized = !0 === r),
          (this.dynamic = !1),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0);
      }
      function Yr(e, t, r) {
        Xr.call(this, new Int8Array(e), t, r);
      }
      function Jr(e, t, r) {
        Xr.call(this, new Uint8Array(e), t, r);
      }
      function Zr(e, t, r) {
        Xr.call(this, new Uint8ClampedArray(e), t, r);
      }
      function Kr(e, t, r) {
        Xr.call(this, new Int16Array(e), t, r);
      }
      function Qr(e, t, r) {
        Xr.call(this, new Uint16Array(e), t, r);
      }
      function $r(e, t, r) {
        Xr.call(this, new Int32Array(e), t, r);
      }
      function en(e, t, r) {
        Xr.call(this, new Uint32Array(e), t, r);
      }
      function tn(e, t, r) {
        Xr.call(this, new Float32Array(e), t, r);
      }
      function rn(e, t, r) {
        Xr.call(this, new Float64Array(e), t, r);
      }
      function nn() {
        (this.vertices = []),
          (this.normals = []),
          (this.colors = []),
          (this.uvs = []),
          (this.uvs2 = []),
          (this.groups = []),
          (this.morphTargets = {}),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.verticesNeedUpdate = !1),
          (this.normalsNeedUpdate = !1),
          (this.colorsNeedUpdate = !1),
          (this.uvsNeedUpdate = !1),
          (this.groupsNeedUpdate = !1);
      }
      function an(e) {
        if (0 === e.length) return -1 / 0;
        for (var t = e[0], r = 1, n = e.length; r < n; ++r) e[r] > t && (t = e[r]);
        return t;
      }
      (qr.prototype = Object.assign(Object.create(n.prototype), {
        constructor: qr,
        isGeometry: !0,
        applyMatrix: function (e) {
          for (var t = new rr().getNormalMatrix(e), r = 0, n = this.vertices.length; r < n; r++) {
            this.vertices[r].applyMatrix4(e);
          }
          for (r = 0, n = this.faces.length; r < n; r++) {
            var i = this.faces[r];
            i.normal.applyMatrix3(t).normalize();
            for (var a = 0, o = i.vertexNormals.length; a < o; a++)
              i.vertexNormals[a].applyMatrix3(t).normalize();
          }
          return (
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            (this.verticesNeedUpdate = !0),
            (this.normalsNeedUpdate = !0),
            this
          );
        },
        rotateX: (function () {
          var e = new $t();
          return function (t) {
            return e.makeRotationX(t), this.applyMatrix(e), this;
          };
        })(),
        rotateY: (function () {
          var e = new $t();
          return function (t) {
            return e.makeRotationY(t), this.applyMatrix(e), this;
          };
        })(),
        rotateZ: (function () {
          var e = new $t();
          return function (t) {
            return e.makeRotationZ(t), this.applyMatrix(e), this;
          };
        })(),
        translate: (function () {
          var e = new $t();
          return function (t, r, n) {
            return e.makeTranslation(t, r, n), this.applyMatrix(e), this;
          };
        })(),
        scale: (function () {
          var e = new $t();
          return function (t, r, n) {
            return e.makeScale(t, r, n), this.applyMatrix(e), this;
          };
        })(),
        lookAt:
          ((jr = new kr()),
          function (e) {
            jr.lookAt(e), jr.updateMatrix(), this.applyMatrix(jr.matrix);
          }),
        fromBufferGeometry: function (e) {
          var t = this,
            r = null !== e.index ? e.index.array : void 0,
            n = e.attributes,
            i = n.position.array,
            a = void 0 !== n.normal ? n.normal.array : void 0,
            o = void 0 !== n.color ? n.color.array : void 0,
            s = void 0 !== n.uv ? n.uv.array : void 0,
            c = void 0 !== n.uv2 ? n.uv2.array : void 0;
          void 0 !== c && (this.faceVertexUvs[1] = []);
          for (var u = 0, l = 0; u < i.length; u += 3, l += 2)
            t.vertices.push(new tr().fromArray(i, u)),
              void 0 !== o && t.colors.push(new Lr().fromArray(o, u));
          function h(e, r, n, i) {
            var u =
                void 0 === o ? [] : [t.colors[e].clone(), t.colors[r].clone(), t.colors[n].clone()],
              l = new Dr(
                e,
                r,
                n,
                void 0 === a
                  ? []
                  : [
                      new tr().fromArray(a, 3 * e),
                      new tr().fromArray(a, 3 * r),
                      new tr().fromArray(a, 3 * n),
                    ],
                u,
                i,
              );
            t.faces.push(l),
              void 0 !== s &&
                t.faceVertexUvs[0].push([
                  new Qt().fromArray(s, 2 * e),
                  new Qt().fromArray(s, 2 * r),
                  new Qt().fromArray(s, 2 * n),
                ]),
              void 0 !== c &&
                t.faceVertexUvs[1].push([
                  new Qt().fromArray(c, 2 * e),
                  new Qt().fromArray(c, 2 * r),
                  new Qt().fromArray(c, 2 * n),
                ]);
          }
          var d = e.groups;
          if (d.length > 0)
            for (u = 0; u < d.length; u++)
              for (var p = d[u], f = p.start, m = ((l = f), f + p.count); l < m; l += 3)
                void 0 !== r
                  ? h(r[l], r[l + 1], r[l + 2], p.materialIndex)
                  : h(l, l + 1, l + 2, p.materialIndex);
          else if (void 0 !== r) for (u = 0; u < r.length; u += 3) h(r[u], r[u + 1], r[u + 2]);
          else for (u = 0; u < i.length / 3; u += 3) h(u, u + 1, u + 2);
          return (
            this.computeFaceNormals(),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            this
          );
        },
        center:
          ((Vr = new tr()),
          function () {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(Vr).negate(),
              this.translate(Vr.x, Vr.y, Vr.z),
              this
            );
          }),
        normalize: function () {
          this.computeBoundingSphere();
          var e = this.boundingSphere.center,
            t = this.boundingSphere.radius,
            r = 0 === t ? 1 : 1 / t,
            n = new $t();
          return (
            n.set(r, 0, 0, -r * e.x, 0, r, 0, -r * e.y, 0, 0, r, -r * e.z, 0, 0, 0, 1),
            this.applyMatrix(n),
            this
          );
        },
        computeFaceNormals: function () {
          for (var e = new tr(), t = new tr(), r = 0, n = this.faces.length; r < n; r++) {
            var i = this.faces[r],
              a = this.vertices[i.a],
              o = this.vertices[i.b],
              s = this.vertices[i.c];
            e.subVectors(s, o), t.subVectors(a, o), e.cross(t), e.normalize(), i.normal.copy(e);
          }
        },
        computeVertexNormals: function (e) {
          var t, r, n, i, a, o;
          for (
            void 0 === e && (e = !0),
              o = new Array(this.vertices.length),
              t = 0,
              r = this.vertices.length;
            t < r;
            t++
          )
            o[t] = new tr();
          if (e) {
            var s,
              c,
              u,
              l = new tr(),
              h = new tr();
            for (n = 0, i = this.faces.length; n < i; n++)
              (a = this.faces[n]),
                (s = this.vertices[a.a]),
                (c = this.vertices[a.b]),
                (u = this.vertices[a.c]),
                l.subVectors(u, c),
                h.subVectors(s, c),
                l.cross(h),
                o[a.a].add(l),
                o[a.b].add(l),
                o[a.c].add(l);
          } else
            for (this.computeFaceNormals(), n = 0, i = this.faces.length; n < i; n++)
              o[(a = this.faces[n]).a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a.normal);
          for (t = 0, r = this.vertices.length; t < r; t++) o[t].normalize();
          for (n = 0, i = this.faces.length; n < i; n++) {
            var d = (a = this.faces[n]).vertexNormals;
            3 === d.length
              ? (d[0].copy(o[a.a]), d[1].copy(o[a.b]), d[2].copy(o[a.c]))
              : ((d[0] = o[a.a].clone()), (d[1] = o[a.b].clone()), (d[2] = o[a.c].clone()));
          }
          this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeFlatVertexNormals: function () {
          var e, t, r;
          for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
            var n = (r = this.faces[e]).vertexNormals;
            3 === n.length
              ? (n[0].copy(r.normal), n[1].copy(r.normal), n[2].copy(r.normal))
              : ((n[0] = r.normal.clone()), (n[1] = r.normal.clone()), (n[2] = r.normal.clone()));
          }
          this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeMorphNormals: function () {
          var e, t, r, n, i;
          for (r = 0, n = this.faces.length; r < n; r++)
            for (
              (i = this.faces[r]).__originalFaceNormal
                ? i.__originalFaceNormal.copy(i.normal)
                : (i.__originalFaceNormal = i.normal.clone()),
                i.__originalVertexNormals || (i.__originalVertexNormals = []),
                e = 0,
                t = i.vertexNormals.length;
              e < t;
              e++
            )
              i.__originalVertexNormals[e]
                ? i.__originalVertexNormals[e].copy(i.vertexNormals[e])
                : (i.__originalVertexNormals[e] = i.vertexNormals[e].clone());
          var a = new qr();
          for (a.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
            if (!this.morphNormals[e]) {
              (this.morphNormals[e] = {}),
                (this.morphNormals[e].faceNormals = []),
                (this.morphNormals[e].vertexNormals = []);
              var o = this.morphNormals[e].faceNormals,
                s = this.morphNormals[e].vertexNormals;
              for (r = 0, n = this.faces.length; r < n; r++)
                (c = new tr()),
                  (u = { a: new tr(), b: new tr(), c: new tr() }),
                  o.push(c),
                  s.push(u);
            }
            var c,
              u,
              l = this.morphNormals[e];
            for (
              a.vertices = this.morphTargets[e].vertices,
                a.computeFaceNormals(),
                a.computeVertexNormals(),
                r = 0,
                n = this.faces.length;
              r < n;
              r++
            )
              (i = this.faces[r]),
                (c = l.faceNormals[r]),
                (u = l.vertexNormals[r]),
                c.copy(i.normal),
                u.a.copy(i.vertexNormals[0]),
                u.b.copy(i.vertexNormals[1]),
                u.c.copy(i.vertexNormals[2]);
          }
          for (r = 0, n = this.faces.length; r < n; r++)
            ((i = this.faces[r]).normal = i.__originalFaceNormal),
              (i.vertexNormals = i.__originalVertexNormals);
        },
        computeBoundingBox: function () {
          null === this.boundingBox && (this.boundingBox = new vr()),
            this.boundingBox.setFromPoints(this.vertices);
        },
        computeBoundingSphere: function () {
          null === this.boundingSphere && (this.boundingSphere = new gr()),
            this.boundingSphere.setFromPoints(this.vertices);
        },
        merge: function (e, t, r) {
          if (e && e.isGeometry) {
            var n,
              i = this.vertices.length,
              a = this.vertices,
              o = e.vertices,
              s = this.faces,
              c = e.faces,
              u = this.faceVertexUvs[0],
              l = e.faceVertexUvs[0],
              h = this.colors,
              d = e.colors;
            void 0 === r && (r = 0), void 0 !== t && (n = new rr().getNormalMatrix(t));
            for (var p = 0, f = o.length; p < f; p++) {
              var m = o[p].clone();
              void 0 !== t && m.applyMatrix4(t), a.push(m);
            }
            for (p = 0, f = d.length; p < f; p++) h.push(d[p].clone());
            for (p = 0, f = c.length; p < f; p++) {
              var v,
                g,
                y,
                x = c[p],
                b = x.vertexNormals,
                w = x.vertexColors;
              (v = new Dr(x.a + i, x.b + i, x.c + i)).normal.copy(x.normal),
                void 0 !== n && v.normal.applyMatrix3(n).normalize();
              for (var _ = 0, M = b.length; _ < M; _++)
                (g = b[_].clone()),
                  void 0 !== n && g.applyMatrix3(n).normalize(),
                  v.vertexNormals.push(g);
              v.color.copy(x.color);
              for (_ = 0, M = w.length; _ < M; _++) (y = w[_]), v.vertexColors.push(y.clone());
              (v.materialIndex = x.materialIndex + r), s.push(v);
            }
            for (p = 0, f = l.length; p < f; p++) {
              var S = l[p],
                E = [];
              if (void 0 !== S) {
                for (_ = 0, M = S.length; _ < M; _++) E.push(S[_].clone());
                u.push(E);
              }
            }
          } else
            console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', e);
        },
        mergeMesh: function (e) {
          e && e.isMesh
            ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix))
            : console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', e);
        },
        mergeVertices: function () {
          var e,
            t,
            r,
            n,
            i,
            a,
            o,
            s,
            c = {},
            u = [],
            l = [],
            h = Math.pow(10, 4);
          for (r = 0, n = this.vertices.length; r < n; r++)
            (e = this.vertices[r]),
              void 0 ===
              c[(t = Math.round(e.x * h) + '_' + Math.round(e.y * h) + '_' + Math.round(e.z * h))]
                ? ((c[t] = r), u.push(this.vertices[r]), (l[r] = u.length - 1))
                : (l[r] = l[c[t]]);
          var d = [];
          for (r = 0, n = this.faces.length; r < n; r++) {
            ((i = this.faces[r]).a = l[i.a]), (i.b = l[i.b]), (i.c = l[i.c]), (a = [i.a, i.b, i.c]);
            for (var p = 0; p < 3; p++)
              if (a[p] === a[(p + 1) % 3]) {
                d.push(r);
                break;
              }
          }
          for (r = d.length - 1; r >= 0; r--) {
            var f = d[r];
            for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++)
              this.faceVertexUvs[o].splice(f, 1);
          }
          var m = this.vertices.length - u.length;
          return (this.vertices = u), m;
        },
        setFromPoints: function (e) {
          this.vertices = [];
          for (var t = 0, r = e.length; t < r; t++) {
            var n = e[t];
            this.vertices.push(new tr(n.x, n.y, n.z || 0));
          }
          return this;
        },
        sortFacesByMaterialIndex: function () {
          for (var e = this.faces, t = e.length, r = 0; r < t; r++) e[r]._id = r;
          e.sort(function (e, t) {
            return e.materialIndex - t.materialIndex;
          });
          var n,
            i,
            a = this.faceVertexUvs[0],
            o = this.faceVertexUvs[1];
          a && a.length === t && (n = []), o && o.length === t && (i = []);
          for (r = 0; r < t; r++) {
            var s = e[r]._id;
            n && n.push(a[s]), i && i.push(o[s]);
          }
          n && (this.faceVertexUvs[0] = n), i && (this.faceVertexUvs[1] = i);
        },
        toJSON: function () {
          var e = { metadata: { version: 4.5, type: 'Geometry', generator: 'Geometry.toJSON' } };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            '' !== this.name && (e.name = this.name),
            void 0 !== this.parameters)
          ) {
            var t = this.parameters;
            for (var r in t) void 0 !== t[r] && (e[r] = t[r]);
            return e;
          }
          for (var n = [], i = 0; i < this.vertices.length; i++) {
            var a = this.vertices[i];
            n.push(a.x, a.y, a.z);
          }
          var o = [],
            s = [],
            c = {},
            u = [],
            l = {},
            h = [],
            d = {};
          for (i = 0; i < this.faces.length; i++) {
            var p = this.faces[i],
              f = void 0 !== this.faceVertexUvs[0][i],
              m = p.normal.length() > 0,
              v = p.vertexNormals.length > 0,
              g = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
              y = p.vertexColors.length > 0,
              x = 0;
            if (
              ((x = M(x, 0, 0)),
              (x = M(x, 1, !0)),
              (x = M(x, 2, !1)),
              (x = M(x, 3, f)),
              (x = M(x, 4, m)),
              (x = M(x, 5, v)),
              (x = M(x, 6, g)),
              (x = M(x, 7, y)),
              o.push(x),
              o.push(p.a, p.b, p.c),
              o.push(p.materialIndex),
              f)
            ) {
              var b = this.faceVertexUvs[0][i];
              o.push(T(b[0]), T(b[1]), T(b[2]));
            }
            if ((m && o.push(S(p.normal)), v)) {
              var w = p.vertexNormals;
              o.push(S(w[0]), S(w[1]), S(w[2]));
            }
            if ((g && o.push(E(p.color)), y)) {
              var _ = p.vertexColors;
              o.push(E(_[0]), E(_[1]), E(_[2]));
            }
          }
          function M(e, t, r) {
            return r ? e | (1 << t) : e & ~(1 << t);
          }
          function S(e) {
            var t = e.x.toString() + e.y.toString() + e.z.toString();
            return void 0 !== c[t] ? c[t] : ((c[t] = s.length / 3), s.push(e.x, e.y, e.z), c[t]);
          }
          function E(e) {
            var t = e.r.toString() + e.g.toString() + e.b.toString();
            return void 0 !== l[t] ? l[t] : ((l[t] = u.length), u.push(e.getHex()), l[t]);
          }
          function T(e) {
            var t = e.x.toString() + e.y.toString();
            return void 0 !== d[t] ? d[t] : ((d[t] = h.length / 2), h.push(e.x, e.y), d[t]);
          }
          return (
            (e.data = {}),
            (e.data.vertices = n),
            (e.data.normals = s),
            u.length > 0 && (e.data.colors = u),
            h.length > 0 && (e.data.uvs = [h]),
            (e.data.faces = o),
            e
          );
        },
        clone: function () {
          return new qr().copy(this);
        },
        copy: function (e) {
          var t, r, n, i, a, o;
          (this.vertices = []),
            (this.colors = []),
            (this.faces = []),
            (this.faceVertexUvs = [[]]),
            (this.morphTargets = []),
            (this.morphNormals = []),
            (this.skinWeights = []),
            (this.skinIndices = []),
            (this.lineDistances = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.name = e.name);
          var s = e.vertices;
          for (t = 0, r = s.length; t < r; t++) this.vertices.push(s[t].clone());
          var c = e.colors;
          for (t = 0, r = c.length; t < r; t++) this.colors.push(c[t].clone());
          var u = e.faces;
          for (t = 0, r = u.length; t < r; t++) this.faces.push(u[t].clone());
          for (t = 0, r = e.faceVertexUvs.length; t < r; t++) {
            var l = e.faceVertexUvs[t];
            for (
              void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), n = 0, i = l.length;
              n < i;
              n++
            ) {
              var h = l[n],
                d = [];
              for (a = 0, o = h.length; a < o; a++) {
                var p = h[a];
                d.push(p.clone());
              }
              this.faceVertexUvs[t].push(d);
            }
          }
          var f = e.morphTargets;
          for (t = 0, r = f.length; t < r; t++) {
            var m = {};
            if (((m.name = f[t].name), void 0 !== f[t].vertices))
              for (m.vertices = [], n = 0, i = f[t].vertices.length; n < i; n++)
                m.vertices.push(f[t].vertices[n].clone());
            if (void 0 !== f[t].normals)
              for (m.normals = [], n = 0, i = f[t].normals.length; n < i; n++)
                m.normals.push(f[t].normals[n].clone());
            this.morphTargets.push(m);
          }
          var v = e.morphNormals;
          for (t = 0, r = v.length; t < r; t++) {
            var g = {};
            if (void 0 !== v[t].vertexNormals)
              for (g.vertexNormals = [], n = 0, i = v[t].vertexNormals.length; n < i; n++) {
                var y = v[t].vertexNormals[n],
                  x = {};
                (x.a = y.a.clone()),
                  (x.b = y.b.clone()),
                  (x.c = y.c.clone()),
                  g.vertexNormals.push(x);
              }
            if (void 0 !== v[t].faceNormals)
              for (g.faceNormals = [], n = 0, i = v[t].faceNormals.length; n < i; n++)
                g.faceNormals.push(v[t].faceNormals[n].clone());
            this.morphNormals.push(g);
          }
          var b = e.skinWeights;
          for (t = 0, r = b.length; t < r; t++) this.skinWeights.push(b[t].clone());
          var w = e.skinIndices;
          for (t = 0, r = w.length; t < r; t++) this.skinIndices.push(w[t].clone());
          var _ = e.lineDistances;
          for (t = 0, r = _.length; t < r; t++) this.lineDistances.push(_[t]);
          var M = e.boundingBox;
          null !== M && (this.boundingBox = M.clone());
          var S = e.boundingSphere;
          return (
            null !== S && (this.boundingSphere = S.clone()),
            (this.elementsNeedUpdate = e.elementsNeedUpdate),
            (this.verticesNeedUpdate = e.verticesNeedUpdate),
            (this.uvsNeedUpdate = e.uvsNeedUpdate),
            (this.normalsNeedUpdate = e.normalsNeedUpdate),
            (this.colorsNeedUpdate = e.colorsNeedUpdate),
            (this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate),
            (this.groupsNeedUpdate = e.groupsNeedUpdate),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: 'dispose' });
        },
      })),
        Object.defineProperty(Xr.prototype, 'needsUpdate', {
          set: function (e) {
            !0 === e && this.version++;
          },
        }),
        Object.assign(Xr.prototype, {
          isBufferAttribute: !0,
          onUploadCallback: function () {},
          setArray: function (e) {
            if (Array.isArray(e))
              throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            return (
              (this.count = void 0 !== e ? e.length / this.itemSize : 0), (this.array = e), this
            );
          },
          setDynamic: function (e) {
            return (this.dynamic = e), this;
          },
          copy: function (e) {
            return (
              (this.name = e.name),
              (this.array = new e.array.constructor(e.array)),
              (this.itemSize = e.itemSize),
              (this.count = e.count),
              (this.normalized = e.normalized),
              (this.dynamic = e.dynamic),
              this
            );
          },
          copyAt: function (e, t, r) {
            (e *= this.itemSize), (r *= t.itemSize);
            for (var n = 0, i = this.itemSize; n < i; n++) this.array[e + n] = t.array[r + n];
            return this;
          },
          copyArray: function (e) {
            return this.array.set(e), this;
          },
          copyColorsArray: function (e) {
            for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
              var a = e[n];
              void 0 === a &&
                (console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', n),
                (a = new Lr())),
                (t[r++] = a.r),
                (t[r++] = a.g),
                (t[r++] = a.b);
            }
            return this;
          },
          copyVector2sArray: function (e) {
            for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
              var a = e[n];
              void 0 === a &&
                (console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', n),
                (a = new Qt())),
                (t[r++] = a.x),
                (t[r++] = a.y);
            }
            return this;
          },
          copyVector3sArray: function (e) {
            for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
              var a = e[n];
              void 0 === a &&
                (console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', n),
                (a = new tr())),
                (t[r++] = a.x),
                (t[r++] = a.y),
                (t[r++] = a.z);
            }
            return this;
          },
          copyVector4sArray: function (e) {
            for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
              var a = e[n];
              void 0 === a &&
                (console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', n),
                (a = new hr())),
                (t[r++] = a.x),
                (t[r++] = a.y),
                (t[r++] = a.z),
                (t[r++] = a.w);
            }
            return this;
          },
          set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this;
          },
          getX: function (e) {
            return this.array[e * this.itemSize];
          },
          setX: function (e, t) {
            return (this.array[e * this.itemSize] = t), this;
          },
          getY: function (e) {
            return this.array[e * this.itemSize + 1];
          },
          setY: function (e, t) {
            return (this.array[e * this.itemSize + 1] = t), this;
          },
          getZ: function (e) {
            return this.array[e * this.itemSize + 2];
          },
          setZ: function (e, t) {
            return (this.array[e * this.itemSize + 2] = t), this;
          },
          getW: function (e) {
            return this.array[e * this.itemSize + 3];
          },
          setW: function (e, t) {
            return (this.array[e * this.itemSize + 3] = t), this;
          },
          setXY: function (e, t, r) {
            return (e *= this.itemSize), (this.array[e + 0] = t), (this.array[e + 1] = r), this;
          },
          setXYZ: function (e, t, r, n) {
            return (
              (e *= this.itemSize),
              (this.array[e + 0] = t),
              (this.array[e + 1] = r),
              (this.array[e + 2] = n),
              this
            );
          },
          setXYZW: function (e, t, r, n, i) {
            return (
              (e *= this.itemSize),
              (this.array[e + 0] = t),
              (this.array[e + 1] = r),
              (this.array[e + 2] = n),
              (this.array[e + 3] = i),
              this
            );
          },
          onUpload: function (e) {
            return (this.onUploadCallback = e), this;
          },
          clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this);
          },
        }),
        (Yr.prototype = Object.create(Xr.prototype)),
        (Yr.prototype.constructor = Yr),
        (Jr.prototype = Object.create(Xr.prototype)),
        (Jr.prototype.constructor = Jr),
        (Zr.prototype = Object.create(Xr.prototype)),
        (Zr.prototype.constructor = Zr),
        (Kr.prototype = Object.create(Xr.prototype)),
        (Kr.prototype.constructor = Kr),
        (Qr.prototype = Object.create(Xr.prototype)),
        (Qr.prototype.constructor = Qr),
        ($r.prototype = Object.create(Xr.prototype)),
        ($r.prototype.constructor = $r),
        (en.prototype = Object.create(Xr.prototype)),
        (en.prototype.constructor = en),
        (tn.prototype = Object.create(Xr.prototype)),
        (tn.prototype.constructor = tn),
        (rn.prototype = Object.create(Xr.prototype)),
        (rn.prototype.constructor = rn),
        Object.assign(nn.prototype, {
          computeGroups: function (e) {
            for (var t, r = [], n = void 0, i = e.faces, a = 0; a < i.length; a++) {
              var o = i[a];
              o.materialIndex !== n &&
                ((n = o.materialIndex),
                void 0 !== t && ((t.count = 3 * a - t.start), r.push(t)),
                (t = { start: 3 * a, materialIndex: n }));
            }
            void 0 !== t && ((t.count = 3 * a - t.start), r.push(t)), (this.groups = r);
          },
          fromGeometry: function (e) {
            var t,
              r = e.faces,
              n = e.vertices,
              i = e.faceVertexUvs,
              a = i[0] && i[0].length > 0,
              o = i[1] && i[1].length > 0,
              s = e.morphTargets,
              c = s.length;
            if (c > 0) {
              t = [];
              for (var u = 0; u < c; u++) t[u] = { name: s[u].name, data: [] };
              this.morphTargets.position = t;
            }
            var l,
              h = e.morphNormals,
              d = h.length;
            if (d > 0) {
              l = [];
              for (u = 0; u < d; u++) l[u] = { name: h[u].name, data: [] };
              this.morphTargets.normal = l;
            }
            var p = e.skinIndices,
              f = e.skinWeights,
              m = p.length === n.length,
              v = f.length === n.length;
            n.length > 0 &&
              0 === r.length &&
              console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
            for (u = 0; u < r.length; u++) {
              var g = r[u];
              this.vertices.push(n[g.a], n[g.b], n[g.c]);
              var y = g.vertexNormals;
              if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
              else {
                var x = g.normal;
                this.normals.push(x, x, x);
              }
              var b,
                w = g.vertexColors;
              if (3 === w.length) this.colors.push(w[0], w[1], w[2]);
              else {
                var _ = g.color;
                this.colors.push(_, _, _);
              }
              if (!0 === a)
                void 0 !== (b = i[0][u])
                  ? this.uvs.push(b[0], b[1], b[2])
                  : (console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', u),
                    this.uvs.push(new Qt(), new Qt(), new Qt()));
              if (!0 === o)
                void 0 !== (b = i[1][u])
                  ? this.uvs2.push(b[0], b[1], b[2])
                  : (console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', u),
                    this.uvs2.push(new Qt(), new Qt(), new Qt()));
              for (var M = 0; M < c; M++) {
                var S = s[M].vertices;
                t[M].data.push(S[g.a], S[g.b], S[g.c]);
              }
              for (M = 0; M < d; M++) {
                var E = h[M].vertexNormals[u];
                l[M].data.push(E.a, E.b, E.c);
              }
              m && this.skinIndices.push(p[g.a], p[g.b], p[g.c]),
                v && this.skinWeights.push(f[g.a], f[g.b], f[g.c]);
            }
            return (
              this.computeGroups(e),
              (this.verticesNeedUpdate = e.verticesNeedUpdate),
              (this.normalsNeedUpdate = e.normalsNeedUpdate),
              (this.colorsNeedUpdate = e.colorsNeedUpdate),
              (this.uvsNeedUpdate = e.uvsNeedUpdate),
              (this.groupsNeedUpdate = e.groupsNeedUpdate),
              this
            );
          },
        });
      var on = 1;
      function sn() {
        Object.defineProperty(this, 'id', { value: (on += 2) }),
          (this.uuid = Kt.generateUUID()),
          (this.name = ''),
          (this.type = 'BufferGeometry'),
          (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.drawRange = { start: 0, count: 1 / 0 }),
          (this.userData = {});
      }
      function cn(e, t, r, n, i, a) {
        qr.call(this),
          (this.type = 'BoxGeometry'),
          (this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: n,
            heightSegments: i,
            depthSegments: a,
          }),
          this.fromBufferGeometry(new un(e, t, r, n, i, a)),
          this.mergeVertices();
      }
      function un(e, t, r, n, i, a) {
        sn.call(this),
          (this.type = 'BoxBufferGeometry'),
          (this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: n,
            heightSegments: i,
            depthSegments: a,
          });
        var o = this;
        (e = e || 1),
          (t = t || 1),
          (r = r || 1),
          (n = Math.floor(n) || 1),
          (i = Math.floor(i) || 1),
          (a = Math.floor(a) || 1);
        var s = [],
          c = [],
          u = [],
          l = [],
          h = 0,
          d = 0;
        function p(e, t, r, n, i, a, p, f, m, v, g) {
          var y,
            x,
            b = a / m,
            w = p / v,
            _ = a / 2,
            M = p / 2,
            S = f / 2,
            E = m + 1,
            T = v + 1,
            A = 0,
            L = 0,
            R = new tr();
          for (x = 0; x < T; x++) {
            var C = x * w - M;
            for (y = 0; y < E; y++) {
              var P = y * b - _;
              (R[e] = P * n),
                (R[t] = C * i),
                (R[r] = S),
                c.push(R.x, R.y, R.z),
                (R[e] = 0),
                (R[t] = 0),
                (R[r] = f > 0 ? 1 : -1),
                u.push(R.x, R.y, R.z),
                l.push(y / m),
                l.push(1 - x / v),
                (A += 1);
            }
          }
          for (x = 0; x < v; x++)
            for (y = 0; y < m; y++) {
              var O = h + y + E * x,
                I = h + y + E * (x + 1),
                D = h + (y + 1) + E * (x + 1),
                B = h + (y + 1) + E * x;
              s.push(O, I, B), s.push(I, D, B), (L += 6);
            }
          o.addGroup(d, L, g), (d += L), (h += A);
        }
        p('z', 'y', 'x', -1, -1, r, t, e, a, i, 0),
          p('z', 'y', 'x', 1, -1, r, t, -e, a, i, 1),
          p('x', 'z', 'y', 1, 1, e, r, t, n, a, 2),
          p('x', 'z', 'y', 1, -1, e, r, -t, n, a, 3),
          p('x', 'y', 'z', 1, -1, e, t, r, n, i, 4),
          p('x', 'y', 'z', -1, -1, e, t, -r, n, i, 5),
          this.setIndex(s),
          this.addAttribute('position', new tn(c, 3)),
          this.addAttribute('normal', new tn(u, 3)),
          this.addAttribute('uv', new tn(l, 2));
      }
      function ln(e, t, r, n) {
        qr.call(this),
          (this.type = 'PlaneGeometry'),
          (this.parameters = { width: e, height: t, widthSegments: r, heightSegments: n }),
          this.fromBufferGeometry(new hn(e, t, r, n)),
          this.mergeVertices();
      }
      function hn(e, t, r, n) {
        sn.call(this),
          (this.type = 'PlaneBufferGeometry'),
          (this.parameters = { width: e, height: t, widthSegments: r, heightSegments: n });
        var i,
          a,
          o = (e = e || 1) / 2,
          s = (t = t || 1) / 2,
          c = Math.floor(r) || 1,
          u = Math.floor(n) || 1,
          l = c + 1,
          h = u + 1,
          d = e / c,
          p = t / u,
          f = [],
          m = [],
          v = [],
          g = [];
        for (a = 0; a < h; a++) {
          var y = a * p - s;
          for (i = 0; i < l; i++) {
            var x = i * d - o;
            m.push(x, -y, 0), v.push(0, 0, 1), g.push(i / c), g.push(1 - a / u);
          }
        }
        for (a = 0; a < u; a++)
          for (i = 0; i < c; i++) {
            var b = i + l * a,
              w = i + l * (a + 1),
              _ = i + 1 + l * (a + 1),
              M = i + 1 + l * a;
            f.push(b, w, M), f.push(w, _, M);
          }
        this.setIndex(f),
          this.addAttribute('position', new tn(m, 3)),
          this.addAttribute('normal', new tn(v, 3)),
          this.addAttribute('uv', new tn(g, 2));
      }
      (sn.prototype = Object.assign(Object.create(n.prototype), {
        constructor: sn,
        isBufferGeometry: !0,
        getIndex: function () {
          return this.index;
        },
        setIndex: function (e) {
          Array.isArray(e) ? (this.index = new (an(e) > 65535 ? en : Qr)(e, 1)) : (this.index = e);
        },
        addAttribute: function (e, t) {
          return (t && t.isBufferAttribute) || (t && t.isInterleavedBufferAttribute)
            ? 'index' === e
              ? (console.warn(
                  'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.',
                ),
                this.setIndex(t),
                this)
              : ((this.attributes[e] = t), this)
            : (console.warn(
                'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).',
              ),
              this.addAttribute(e, new Xr(arguments[1], arguments[2])));
        },
        getAttribute: function (e) {
          return this.attributes[e];
        },
        removeAttribute: function (e) {
          return delete this.attributes[e], this;
        },
        addGroup: function (e, t, r) {
          this.groups.push({ start: e, count: t, materialIndex: void 0 !== r ? r : 0 });
        },
        clearGroups: function () {
          this.groups = [];
        },
        setDrawRange: function (e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        },
        applyMatrix: function (e) {
          var t = this.attributes.position;
          void 0 !== t && (e.applyToBufferAttribute(t), (t.needsUpdate = !0));
          var r = this.attributes.normal;
          void 0 !== r &&
            (new rr().getNormalMatrix(e).applyToBufferAttribute(r), (r.needsUpdate = !0));
          return (
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        },
        rotateX: (function () {
          var e = new $t();
          return function (t) {
            return e.makeRotationX(t), this.applyMatrix(e), this;
          };
        })(),
        rotateY: (function () {
          var e = new $t();
          return function (t) {
            return e.makeRotationY(t), this.applyMatrix(e), this;
          };
        })(),
        rotateZ: (function () {
          var e = new $t();
          return function (t) {
            return e.makeRotationZ(t), this.applyMatrix(e), this;
          };
        })(),
        translate: (function () {
          var e = new $t();
          return function (t, r, n) {
            return e.makeTranslation(t, r, n), this.applyMatrix(e), this;
          };
        })(),
        scale: (function () {
          var e = new $t();
          return function (t, r, n) {
            return e.makeScale(t, r, n), this.applyMatrix(e), this;
          };
        })(),
        lookAt: (function () {
          var e = new kr();
          return function (t) {
            e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix);
          };
        })(),
        center: (function () {
          var e = new tr();
          return function () {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(e).negate(),
              this.translate(e.x, e.y, e.z),
              this
            );
          };
        })(),
        setFromObject: function (e) {
          var t = e.geometry;
          if (e.isPoints || e.isLine) {
            var r = new tn(3 * t.vertices.length, 3),
              n = new tn(3 * t.colors.length, 3);
            if (
              (this.addAttribute('position', r.copyVector3sArray(t.vertices)),
              this.addAttribute('color', n.copyColorsArray(t.colors)),
              t.lineDistances && t.lineDistances.length === t.vertices.length)
            ) {
              var i = new tn(t.lineDistances.length, 1);
              this.addAttribute('lineDistance', i.copyArray(t.lineDistances));
            }
            null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
              null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone());
          } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
          return this;
        },
        setFromPoints: function (e) {
          for (var t = [], r = 0, n = e.length; r < n; r++) {
            var i = e[r];
            t.push(i.x, i.y, i.z || 0);
          }
          return this.addAttribute('position', new tn(t, 3)), this;
        },
        updateFromObject: function (e) {
          var t,
            r = e.geometry;
          if (e.isMesh) {
            var n = r.__directGeometry;
            if (
              (!0 === r.elementsNeedUpdate && ((n = void 0), (r.elementsNeedUpdate = !1)),
              void 0 === n)
            )
              return this.fromGeometry(r);
            (n.verticesNeedUpdate = r.verticesNeedUpdate),
              (n.normalsNeedUpdate = r.normalsNeedUpdate),
              (n.colorsNeedUpdate = r.colorsNeedUpdate),
              (n.uvsNeedUpdate = r.uvsNeedUpdate),
              (n.groupsNeedUpdate = r.groupsNeedUpdate),
              (r.verticesNeedUpdate = !1),
              (r.normalsNeedUpdate = !1),
              (r.colorsNeedUpdate = !1),
              (r.uvsNeedUpdate = !1),
              (r.groupsNeedUpdate = !1),
              (r = n);
          }
          return (
            !0 === r.verticesNeedUpdate &&
              (void 0 !== (t = this.attributes.position) &&
                (t.copyVector3sArray(r.vertices), (t.needsUpdate = !0)),
              (r.verticesNeedUpdate = !1)),
            !0 === r.normalsNeedUpdate &&
              (void 0 !== (t = this.attributes.normal) &&
                (t.copyVector3sArray(r.normals), (t.needsUpdate = !0)),
              (r.normalsNeedUpdate = !1)),
            !0 === r.colorsNeedUpdate &&
              (void 0 !== (t = this.attributes.color) &&
                (t.copyColorsArray(r.colors), (t.needsUpdate = !0)),
              (r.colorsNeedUpdate = !1)),
            r.uvsNeedUpdate &&
              (void 0 !== (t = this.attributes.uv) &&
                (t.copyVector2sArray(r.uvs), (t.needsUpdate = !0)),
              (r.uvsNeedUpdate = !1)),
            r.lineDistancesNeedUpdate &&
              (void 0 !== (t = this.attributes.lineDistance) &&
                (t.copyArray(r.lineDistances), (t.needsUpdate = !0)),
              (r.lineDistancesNeedUpdate = !1)),
            r.groupsNeedUpdate &&
              (r.computeGroups(e.geometry), (this.groups = r.groups), (r.groupsNeedUpdate = !1)),
            this
          );
        },
        fromGeometry: function (e) {
          return (
            (e.__directGeometry = new nn().fromGeometry(e)),
            this.fromDirectGeometry(e.__directGeometry)
          );
        },
        fromDirectGeometry: function (e) {
          var t = new Float32Array(3 * e.vertices.length);
          if (
            (this.addAttribute('position', new Xr(t, 3).copyVector3sArray(e.vertices)),
            e.normals.length > 0)
          ) {
            var r = new Float32Array(3 * e.normals.length);
            this.addAttribute('normal', new Xr(r, 3).copyVector3sArray(e.normals));
          }
          if (e.colors.length > 0) {
            var n = new Float32Array(3 * e.colors.length);
            this.addAttribute('color', new Xr(n, 3).copyColorsArray(e.colors));
          }
          if (e.uvs.length > 0) {
            var i = new Float32Array(2 * e.uvs.length);
            this.addAttribute('uv', new Xr(i, 2).copyVector2sArray(e.uvs));
          }
          if (e.uvs2.length > 0) {
            var a = new Float32Array(2 * e.uvs2.length);
            this.addAttribute('uv2', new Xr(a, 2).copyVector2sArray(e.uvs2));
          }
          for (var o in ((this.groups = e.groups), e.morphTargets)) {
            for (var s = [], c = e.morphTargets[o], u = 0, l = c.length; u < l; u++) {
              var h = c[u],
                d = new tn(3 * h.data.length, 3);
              (d.name = h.name), s.push(d.copyVector3sArray(h.data));
            }
            this.morphAttributes[o] = s;
          }
          if (e.skinIndices.length > 0) {
            var p = new tn(4 * e.skinIndices.length, 4);
            this.addAttribute('skinIndex', p.copyVector4sArray(e.skinIndices));
          }
          if (e.skinWeights.length > 0) {
            var f = new tn(4 * e.skinWeights.length, 4);
            this.addAttribute('skinWeight', f.copyVector4sArray(e.skinWeights));
          }
          return (
            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            this
          );
        },
        computeBoundingBox: function () {
          null === this.boundingBox && (this.boundingBox = new vr());
          var e = this.attributes.position;
          void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(),
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this,
              );
        },
        computeBoundingSphere: (function () {
          var e = new vr(),
            t = new tr();
          return function () {
            null === this.boundingSphere && (this.boundingSphere = new gr());
            var r = this.attributes.position;
            if (r) {
              var n = this.boundingSphere.center;
              e.setFromBufferAttribute(r), e.getCenter(n);
              for (var i = 0, a = 0, o = r.count; a < o; a++)
                (t.x = r.getX(a)),
                  (t.y = r.getY(a)),
                  (t.z = r.getZ(a)),
                  (i = Math.max(i, n.distanceToSquared(t)));
              (this.boundingSphere.radius = Math.sqrt(i)),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    this,
                  );
            }
          };
        })(),
        computeFaceNormals: function () {},
        computeVertexNormals: function () {
          var e = this.index,
            t = this.attributes;
          if (t.position) {
            var r = t.position.array;
            if (void 0 === t.normal)
              this.addAttribute('normal', new Xr(new Float32Array(r.length), 3));
            else for (var n = t.normal.array, i = 0, a = n.length; i < a; i++) n[i] = 0;
            var o,
              s,
              c,
              u = t.normal.array,
              l = new tr(),
              h = new tr(),
              d = new tr(),
              p = new tr(),
              f = new tr();
            if (e) {
              var m = e.array;
              for (i = 0, a = e.count; i < a; i += 3)
                (o = 3 * m[i + 0]),
                  (s = 3 * m[i + 1]),
                  (c = 3 * m[i + 2]),
                  l.fromArray(r, o),
                  h.fromArray(r, s),
                  d.fromArray(r, c),
                  p.subVectors(d, h),
                  f.subVectors(l, h),
                  p.cross(f),
                  (u[o] += p.x),
                  (u[o + 1] += p.y),
                  (u[o + 2] += p.z),
                  (u[s] += p.x),
                  (u[s + 1] += p.y),
                  (u[s + 2] += p.z),
                  (u[c] += p.x),
                  (u[c + 1] += p.y),
                  (u[c + 2] += p.z);
            } else
              for (i = 0, a = r.length; i < a; i += 9)
                l.fromArray(r, i),
                  h.fromArray(r, i + 3),
                  d.fromArray(r, i + 6),
                  p.subVectors(d, h),
                  f.subVectors(l, h),
                  p.cross(f),
                  (u[i] = p.x),
                  (u[i + 1] = p.y),
                  (u[i + 2] = p.z),
                  (u[i + 3] = p.x),
                  (u[i + 4] = p.y),
                  (u[i + 5] = p.z),
                  (u[i + 6] = p.x),
                  (u[i + 7] = p.y),
                  (u[i + 8] = p.z);
            this.normalizeNormals(), (t.normal.needsUpdate = !0);
          }
        },
        merge: function (e, t) {
          if (e && e.isBufferGeometry) {
            void 0 === t &&
              ((t = 0),
              console.warn(
                'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.',
              ));
            var r = this.attributes;
            for (var n in r)
              if (void 0 !== e.attributes[n])
                for (
                  var i = r[n].array, a = e.attributes[n], o = a.array, s = 0, c = a.itemSize * t;
                  s < o.length;
                  s++, c++
                )
                  i[c] = o[s];
            return this;
          }
          console.error(
            'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
            e,
          );
        },
        normalizeNormals: (function () {
          var e = new tr();
          return function () {
            for (var t = this.attributes.normal, r = 0, n = t.count; r < n; r++)
              (e.x = t.getX(r)),
                (e.y = t.getY(r)),
                (e.z = t.getZ(r)),
                e.normalize(),
                t.setXYZ(r, e.x, e.y, e.z);
          };
        })(),
        toNonIndexed: function () {
          function e(e, t) {
            for (
              var r = e.array,
                n = e.itemSize,
                i = new r.constructor(t.length * n),
                a = 0,
                o = 0,
                s = 0,
                c = t.length;
              s < c;
              s++
            ) {
              a = t[s] * n;
              for (var u = 0; u < n; u++) i[o++] = r[a++];
            }
            return new Xr(i, n);
          }
          if (null === this.index)
            return (
              console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.'),
              this
            );
          var t = new sn(),
            r = this.index.array,
            n = this.attributes;
          for (var i in n) {
            var a = e(n[i], r);
            t.addAttribute(i, a);
          }
          var o = this.morphAttributes;
          for (i in o) {
            for (var s = [], c = o[i], u = 0, l = c.length; u < l; u++) {
              a = e(c[u], r);
              s.push(a);
            }
            t.morphAttributes[i] = s;
          }
          for (var h = this.groups, d = ((u = 0), h.length); u < d; u++) {
            var p = h[u];
            t.addGroup(p.start, p.count, p.materialIndex);
          }
          return t;
        },
        toJSON: function () {
          var e = {
            metadata: { version: 4.5, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            '' !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            var t = this.parameters;
            for (var r in t) void 0 !== t[r] && (e[r] = t[r]);
            return e;
          }
          e.data = { attributes: {} };
          var n = this.index;
          if (null !== n) {
            var i = Array.prototype.slice.call(n.array);
            e.data.index = { type: n.array.constructor.name, array: i };
          }
          var a = this.attributes;
          for (var r in a) {
            var o = a[r];
            i = Array.prototype.slice.call(o.array);
            e.data.attributes[r] = {
              itemSize: o.itemSize,
              type: o.array.constructor.name,
              array: i,
              normalized: o.normalized,
            };
          }
          var s = this.groups;
          s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
          var c = this.boundingSphere;
          return (
            null !== c &&
              (e.data.boundingSphere = { center: c.center.toArray(), radius: c.radius }),
            e
          );
        },
        clone: function () {
          return new sn().copy(this);
        },
        copy: function (e) {
          var t, r, n;
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.name = e.name);
          var i = e.index;
          null !== i && this.setIndex(i.clone());
          var a = e.attributes;
          for (t in a) {
            var o = a[t];
            this.addAttribute(t, o.clone());
          }
          var s = e.morphAttributes;
          for (t in s) {
            var c = [],
              u = s[t];
            for (r = 0, n = u.length; r < n; r++) c.push(u[r].clone());
            this.morphAttributes[t] = c;
          }
          var l = e.groups;
          for (r = 0, n = l.length; r < n; r++) {
            var h = l[r];
            this.addGroup(h.start, h.count, h.materialIndex);
          }
          var d = e.boundingBox;
          null !== d && (this.boundingBox = d.clone());
          var p = e.boundingSphere;
          return (
            null !== p && (this.boundingSphere = p.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: 'dispose' });
        },
      })),
        (cn.prototype = Object.create(qr.prototype)),
        (cn.prototype.constructor = cn),
        (un.prototype = Object.create(sn.prototype)),
        (un.prototype.constructor = un),
        (ln.prototype = Object.create(qr.prototype)),
        (ln.prototype.constructor = ln),
        (hn.prototype = Object.create(sn.prototype)),
        (hn.prototype.constructor = hn);
      var dn,
        pn,
        fn,
        mn,
        vn,
        gn,
        yn,
        xn,
        bn,
        wn,
        _n,
        Mn,
        Sn = 0;
      function En() {
        Object.defineProperty(this, 'id', { value: Sn++ }),
          (this.uuid = Kt.generateUUID()),
          (this.name = ''),
          (this.type = 'Material'),
          (this.fog = !0),
          (this.lights = !0),
          (this.blending = N),
          (this.side = A),
          (this.flatShading = !1),
          (this.vertexColors = O),
          (this.opacity = 1),
          (this.transparent = !1),
          (this.blendSrc = Z),
          (this.blendDst = K),
          (this.blendEquation = H),
          (this.blendSrcAlpha = null),
          (this.blendDstAlpha = null),
          (this.blendEquationAlpha = null),
          (this.depthFunc = oe),
          (this.depthTest = !0),
          (this.depthWrite = !0),
          (this.clippingPlanes = null),
          (this.clipIntersection = !1),
          (this.clipShadows = !1),
          (this.shadowSide = null),
          (this.colorWrite = !0),
          (this.precision = null),
          (this.polygonOffset = !1),
          (this.polygonOffsetFactor = 0),
          (this.polygonOffsetUnits = 0),
          (this.dithering = !1),
          (this.alphaTest = 0),
          (this.premultipliedAlpha = !1),
          (this.visible = !0),
          (this.userData = {}),
          (this.needsUpdate = !0);
      }
      function Tn(e) {
        En.call(this),
          (this.type = 'ShaderMaterial'),
          (this.defines = {}),
          (this.uniforms = {}),
          (this.vertexShader =
            'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
          (this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
          (this.linewidth = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.clipping = !1),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
          }),
          (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
          (this.index0AttributeName = void 0),
          (this.uniformsNeedUpdate = !1),
          void 0 !== e &&
            (void 0 !== e.attributes &&
              console.error(
                'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.',
              ),
            this.setValues(e));
      }
      function An(e, t) {
        (this.origin = void 0 !== e ? e : new tr()), (this.direction = void 0 !== t ? t : new tr());
      }
      function Ln(e, t, r) {
        (this.a = void 0 !== e ? e : new tr()),
          (this.b = void 0 !== t ? t : new tr()),
          (this.c = void 0 !== r ? r : new tr());
      }
      function Rn(e) {
        En.call(this),
          (this.type = 'MeshBasicMaterial'),
          (this.color = new Lr(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = he),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = 'round'),
          (this.wireframeLinejoin = 'round'),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.lights = !1),
          this.setValues(e);
      }
      function Cn(e, t) {
        kr.call(this),
          (this.type = 'Mesh'),
          (this.geometry = void 0 !== e ? e : new sn()),
          (this.material = void 0 !== t ? t : new Rn({ color: 16777215 * Math.random() })),
          (this.drawMode = Nt),
          this.updateMorphTargets();
      }
      function Pn(e, t, r, n) {
        var i,
          a,
          o = new Lr(0),
          s = 0,
          c = null,
          u = 0;
        function l(e, r) {
          t.buffers.color.setClear(e.r, e.g, e.b, r, n);
        }
        return {
          getClearColor: function () {
            return o;
          },
          setClearColor: function (e, t) {
            o.set(e), l(o, (s = void 0 !== t ? t : 1));
          },
          getClearAlpha: function () {
            return s;
          },
          setClearAlpha: function (e) {
            l(o, (s = e));
          },
          render: function (t, n, h, d) {
            var p = n.background;
            if (
              (null === p
                ? (l(o, s), (c = null), (u = 0))
                : p && p.isColor && (l(p, 1), (d = !0), (c = null), (u = 0)),
              (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
              p && (p.isCubeTexture || p.isWebGLRenderTargetCube))
            ) {
              void 0 === a &&
                ((a = new Cn(
                  new un(1, 1, 1),
                  new Tn({
                    type: 'BackgroundCubeMaterial',
                    uniforms: wr(Pr.cube.uniforms),
                    vertexShader: Pr.cube.vertexShader,
                    fragmentShader: Pr.cube.fragmentShader,
                    side: L,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  }),
                )).geometry.removeAttribute('normal'),
                a.geometry.removeAttribute('uv'),
                (a.onBeforeRender = function (e, t, r) {
                  this.matrixWorld.copyPosition(r.matrixWorld);
                }),
                Object.defineProperty(a.material, 'map', {
                  get: function () {
                    return this.uniforms.tCube.value;
                  },
                }),
                r.update(a));
              var f = p.isWebGLRenderTargetCube ? p.texture : p;
              (a.material.uniforms.tCube.value = f),
                (a.material.uniforms.tFlip.value = p.isWebGLRenderTargetCube ? 1 : -1),
                (c === p && u === f.version) ||
                  ((a.material.needsUpdate = !0), (c = p), (u = f.version)),
                t.unshift(a, a.geometry, a.material, 0, 0, null);
            } else
              p &&
                p.isTexture &&
                (void 0 === i &&
                  ((i = new Cn(
                    new hn(2, 2),
                    new Tn({
                      type: 'BackgroundMaterial',
                      uniforms: wr(Pr.background.uniforms),
                      vertexShader: Pr.background.vertexShader,
                      fragmentShader: Pr.background.fragmentShader,
                      side: A,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    }),
                  )).geometry.removeAttribute('normal'),
                  Object.defineProperty(i.material, 'map', {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  r.update(i)),
                (i.material.uniforms.t2D.value = p),
                !0 === p.matrixAutoUpdate && p.updateMatrix(),
                i.material.uniforms.uvTransform.value.copy(p.matrix),
                (c === p && u === p.version) ||
                  ((i.material.needsUpdate = !0), (c = p), (u = p.version)),
                t.unshift(i, i.geometry, i.material, 0, 0, null));
          },
        };
      }
      function On(e, t, r, n) {
        var i;
        (this.setMode = function (e) {
          i = e;
        }),
          (this.render = function (t, n) {
            e.drawArrays(i, t, n), r.update(n, i);
          }),
          (this.renderInstances = function (a, o, s) {
            var c;
            if (n.isWebGL2) c = e;
            else if (null === (c = t.get('ANGLE_instanced_arrays')))
              return void console.error(
                'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
              );
            c[n.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE'](
              i,
              o,
              s,
              a.maxInstancedCount,
            ),
              r.update(s, i, a.maxInstancedCount);
          });
      }
      function In(e, t, r) {
        var n;
        function i(t) {
          if ('highp' === t) {
            if (
              e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              e.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return 'highp';
            t = 'mediump';
          }
          return 'mediump' === t &&
            e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            e.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? 'mediump'
            : 'lowp';
        }
        var a = 'undefined' != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
          o = void 0 !== r.precision ? r.precision : 'highp',
          s = i(o);
        s !== o &&
          (console.warn('THREE.WebGLRenderer:', o, 'not supported, using', s, 'instead.'), (o = s));
        var c = !0 === r.logarithmicDepthBuffer,
          u = e.getParameter(34930),
          l = e.getParameter(35660),
          h = e.getParameter(3379),
          d = e.getParameter(34076),
          p = e.getParameter(34921),
          f = e.getParameter(36347),
          m = e.getParameter(36348),
          v = e.getParameter(36349),
          g = l > 0,
          y = a || !!t.get('OES_texture_float');
        return {
          isWebGL2: a,
          getMaxAnisotropy: function () {
            if (void 0 !== n) return n;
            var r = t.get('EXT_texture_filter_anisotropic');
            return (n = null !== r ? e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0);
          },
          getMaxPrecision: i,
          precision: o,
          logarithmicDepthBuffer: c,
          maxTextures: u,
          maxVertexTextures: l,
          maxTextureSize: h,
          maxCubemapSize: d,
          maxAttributes: p,
          maxVertexUniforms: f,
          maxVaryings: m,
          maxFragmentUniforms: v,
          vertexTextures: g,
          floatFragmentTextures: y,
          floatVertexTextures: g && y,
          maxSamples: a ? e.getParameter(36183) : 0,
        };
      }
      function Dn() {
        var e = this,
          t = null,
          r = 0,
          n = !1,
          i = !1,
          a = new yr(),
          o = new rr(),
          s = { value: null, needsUpdate: !1 };
        function c() {
          s.value !== t && ((s.value = t), (s.needsUpdate = r > 0)),
            (e.numPlanes = r),
            (e.numIntersection = 0);
        }
        function u(t, r, n, i) {
          var c = null !== t ? t.length : 0,
            u = null;
          if (0 !== c) {
            if (((u = s.value), !0 !== i || null === u)) {
              var l = n + 4 * c,
                h = r.matrixWorldInverse;
              o.getNormalMatrix(h), (null === u || u.length < l) && (u = new Float32Array(l));
              for (var d = 0, p = n; d !== c; ++d, p += 4)
                a.copy(t[d]).applyMatrix4(h, o), a.normal.toArray(u, p), (u[p + 3] = a.constant);
            }
            (s.value = u), (s.needsUpdate = !0);
          }
          return (e.numPlanes = c), u;
        }
        (this.uniform = s),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (e, i, a) {
            var o = 0 !== e.length || i || 0 !== r || n;
            return (n = i), (t = u(e, a, 0)), (r = e.length), o;
          }),
          (this.beginShadows = function () {
            (i = !0), u(null);
          }),
          (this.endShadows = function () {
            (i = !1), c();
          }),
          (this.setState = function (e, a, o, l, h, d) {
            if (!n || null === e || 0 === e.length || (i && !o)) i ? u(null) : c();
            else {
              var p = i ? 0 : r,
                f = 4 * p,
                m = h.clippingState || null;
              (s.value = m), (m = u(e, l, f, d));
              for (var v = 0; v !== f; ++v) m[v] = t[v];
              (h.clippingState = m),
                (this.numIntersection = a ? this.numPlanes : 0),
                (this.numPlanes += p);
            }
          });
      }
      function Bn(e) {
        var t = {};
        return {
          get: function (r) {
            if (void 0 !== t[r]) return t[r];
            var n;
            switch (r) {
              case 'WEBGL_depth_texture':
                n =
                  e.getExtension('WEBGL_depth_texture') ||
                  e.getExtension('MOZ_WEBGL_depth_texture') ||
                  e.getExtension('WEBKIT_WEBGL_depth_texture');
                break;
              case 'EXT_texture_filter_anisotropic':
                n =
                  e.getExtension('EXT_texture_filter_anisotropic') ||
                  e.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                  e.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
              case 'WEBGL_compressed_texture_s3tc':
                n =
                  e.getExtension('WEBGL_compressed_texture_s3tc') ||
                  e.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                  e.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
              case 'WEBGL_compressed_texture_pvrtc':
                n =
                  e.getExtension('WEBGL_compressed_texture_pvrtc') ||
                  e.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
              default:
                n = e.getExtension(r);
            }
            return (
              null === n && console.warn('THREE.WebGLRenderer: ' + r + ' extension not supported.'),
              (t[r] = n),
              n
            );
          },
        };
      }
      function Nn(e, t, r) {
        var n = {},
          i = {};
        function a(e) {
          var o = e.target,
            s = n[o.id];
          for (var c in (null !== s.index && t.remove(s.index), s.attributes))
            t.remove(s.attributes[c]);
          o.removeEventListener('dispose', a), delete n[o.id];
          var u = i[s.id];
          u && (t.remove(u), delete i[s.id]), r.memory.geometries--;
        }
        return {
          get: function (e, t) {
            var i = n[t.id];
            return (
              i ||
              (t.addEventListener('dispose', a),
              t.isBufferGeometry
                ? (i = t)
                : t.isGeometry &&
                  (void 0 === t._bufferGeometry && (t._bufferGeometry = new sn().setFromObject(e)),
                  (i = t._bufferGeometry)),
              (n[t.id] = i),
              r.memory.geometries++,
              i)
            );
          },
          update: function (e) {
            var r = e.index,
              n = e.attributes;
            for (var i in (null !== r && t.update(r, 34963), n)) t.update(n[i], 34962);
            var a = e.morphAttributes;
            for (var i in a)
              for (var o = a[i], s = 0, c = o.length; s < c; s++) t.update(o[s], 34962);
          },
          getWireframeAttribute: function (e) {
            var r = i[e.id];
            if (r) return r;
            var n,
              a = [],
              o = e.index,
              s = e.attributes;
            if (null !== o)
              for (var c = 0, u = (n = o.array).length; c < u; c += 3) {
                var l = n[c + 0],
                  h = n[c + 1],
                  d = n[c + 2];
                a.push(l, h, h, d, d, l);
              }
            else
              for (c = 0, u = (n = s.position.array).length / 3 - 1; c < u; c += 3)
                (l = c + 0), (h = c + 1), (d = c + 2), a.push(l, h, h, d, d, l);
            return (r = new (an(a) > 65535 ? en : Qr)(a, 1)), t.update(r, 34963), (i[e.id] = r), r;
          },
        };
      }
      function Un(e, t, r, n) {
        var i, a, o;
        (this.setMode = function (e) {
          i = e;
        }),
          (this.setIndex = function (e) {
            (a = e.type), (o = e.bytesPerElement);
          }),
          (this.render = function (t, n) {
            e.drawElements(i, n, a, t * o), r.update(n, i);
          }),
          (this.renderInstances = function (s, c, u) {
            var l;
            if (n.isWebGL2) l = e;
            else if (null === (l = t.get('ANGLE_instanced_arrays')))
              return void console.error(
                'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
              );
            l[n.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE'](
              i,
              u,
              a,
              c * o,
              s.maxInstancedCount,
            ),
              r.update(u, i, s.maxInstancedCount);
          });
      }
      function Gn(e) {
        var t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: t,
          programs: null,
          autoReset: !0,
          reset: function () {
            t.frame++, (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
          },
          update: function (e, r, n) {
            switch (((n = n || 1), t.calls++, r)) {
              case 4:
                t.triangles += n * (e / 3);
                break;
              case 5:
              case 6:
                t.triangles += n * (e - 2);
                break;
              case 1:
                t.lines += n * (e / 2);
                break;
              case 3:
                t.lines += n * (e - 1);
                break;
              case 2:
                t.lines += n * e;
                break;
              case 0:
                t.points += n * e;
                break;
              default:
                console.error('THREE.WebGLInfo: Unknown draw mode:', r);
            }
          },
        };
      }
      function Fn(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1]);
      }
      function zn(e) {
        var t = {},
          r = new Float32Array(8);
        return {
          update: function (n, i, a, o) {
            var s = n.morphTargetInfluences,
              c = s.length,
              u = t[i.id];
            if (void 0 === u) {
              u = [];
              for (var l = 0; l < c; l++) u[l] = [l, 0];
              t[i.id] = u;
            }
            var h = a.morphTargets && i.morphAttributes.position,
              d = a.morphNormals && i.morphAttributes.normal;
            for (l = 0; l < c; l++)
              0 !== (p = u[l])[1] &&
                (h && i.removeAttribute('morphTarget' + l),
                d && i.removeAttribute('morphNormal' + l));
            for (l = 0; l < c; l++) ((p = u[l])[0] = l), (p[1] = s[l]);
            for (u.sort(Fn), l = 0; l < 8; l++) {
              var p;
              if ((p = u[l])) {
                var f = p[0],
                  m = p[1];
                if (m) {
                  h && i.addAttribute('morphTarget' + l, h[f]),
                    d && i.addAttribute('morphNormal' + l, d[f]),
                    (r[l] = m);
                  continue;
                }
              }
              r[l] = 0;
            }
            o.getUniforms().setValue(e, 'morphTargetInfluences', r);
          },
        };
      }
      function Hn(e, t) {
        var r = {};
        return {
          update: function (n) {
            var i = t.render.frame,
              a = n.geometry,
              o = e.get(n, a);
            return (
              r[o.id] !== i && (a.isGeometry && o.updateFromObject(n), e.update(o), (r[o.id] = i)),
              o
            );
          },
          dispose: function () {
            r = {};
          },
        };
      }
      function kn(e, t, r, n, i, a, o, s, c, u) {
        (e = void 0 !== e ? e : []),
          (t = void 0 !== t ? t : we),
          lr.call(this, e, t, r, n, i, a, o, s, c, u),
          (this.flipY = !1);
      }
      function Vn(e, t, r, n) {
        lr.call(this, null),
          (this.image = { data: e, width: t, height: r, depth: n }),
          (this.magFilter = Pe),
          (this.minFilter = Pe),
          (this.generateMipmaps = !1),
          (this.flipY = !1);
      }
      (En.prototype = Object.assign(Object.create(n.prototype), {
        constructor: En,
        isMaterial: !0,
        onBeforeCompile: function () {},
        setValues: function (e) {
          if (void 0 !== e)
            for (var t in e) {
              var r = e[t];
              if (void 0 !== r)
                if ('shading' !== t) {
                  var n = this[t];
                  void 0 !== n
                    ? n && n.isColor
                      ? n.set(r)
                      : n && n.isVector3 && r && r.isVector3
                      ? n.copy(r)
                      : (this[t] = r)
                    : console.warn(
                        'THREE.' + this.type + ": '" + t + "' is not a property of this material.",
                      );
                } else
                  console.warn(
                    'THREE.' +
                      this.type +
                      ': .shading has been removed. Use the boolean .flatShading instead.',
                  ),
                    (this.flatShading = r === C);
              else console.warn("THREE.Material: '" + t + "' parameter is undefined.");
            }
        },
        toJSON: function (e) {
          var t = void 0 === e || 'string' == typeof e;
          t && (e = { textures: {}, images: {} });
          var r = { metadata: { version: 4.5, type: 'Material', generator: 'Material.toJSON' } };
          function n(e) {
            var t = [];
            for (var r in e) {
              var n = e[r];
              delete n.metadata, t.push(n);
            }
            return t;
          }
          if (
            ((r.uuid = this.uuid),
            (r.type = this.type),
            '' !== this.name && (r.name = this.name),
            this.color && this.color.isColor && (r.color = this.color.getHex()),
            void 0 !== this.roughness && (r.roughness = this.roughness),
            void 0 !== this.metalness && (r.metalness = this.metalness),
            this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()),
            1 !== this.emissiveIntensity && (r.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (r.specular = this.specular.getHex()),
            void 0 !== this.shininess && (r.shininess = this.shininess),
            void 0 !== this.clearCoat && (r.clearCoat = this.clearCoat),
            void 0 !== this.clearCoatRoughness && (r.clearCoatRoughness = this.clearCoatRoughness),
            this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((r.aoMap = this.aoMap.toJSON(e).uuid), (r.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((r.bumpMap = this.bumpMap.toJSON(e).uuid), (r.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((r.normalMap = this.normalMap.toJSON(e).uuid),
              (r.normalMapType = this.normalMapType),
              (r.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
              (r.displacementScale = this.displacementScale),
              (r.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (r.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((r.envMap = this.envMap.toJSON(e).uuid),
              (r.reflectivity = this.reflectivity),
              void 0 !== this.combine && (r.combine = this.combine),
              void 0 !== this.envMapIntensity && (r.envMapIntensity = this.envMapIntensity)),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (r.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.size && (r.size = this.size),
            void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation),
            this.blending !== N && (r.blending = this.blending),
            !0 === this.flatShading && (r.flatShading = this.flatShading),
            this.side !== A && (r.side = this.side),
            this.vertexColors !== O && (r.vertexColors = this.vertexColors),
            this.opacity < 1 && (r.opacity = this.opacity),
            !0 === this.transparent && (r.transparent = this.transparent),
            (r.depthFunc = this.depthFunc),
            (r.depthTest = this.depthTest),
            (r.depthWrite = this.depthWrite),
            0 !== this.rotation && (r.rotation = this.rotation),
            !0 === this.polygonOffset && (r.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (r.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (r.polygonOffsetUnits = this.polygonOffsetUnits),
            1 !== this.linewidth && (r.linewidth = this.linewidth),
            void 0 !== this.dashSize && (r.dashSize = this.dashSize),
            void 0 !== this.gapSize && (r.gapSize = this.gapSize),
            void 0 !== this.scale && (r.scale = this.scale),
            !0 === this.dithering && (r.dithering = !0),
            this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (r.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth),
            'round' !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap),
            'round' !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (r.morphTargets = !0),
            !0 === this.skinning && (r.skinning = !0),
            !1 === this.visible && (r.visible = !1),
            '{}' !== JSON.stringify(this.userData) && (r.userData = this.userData),
            t)
          ) {
            var i = n(e.textures),
              a = n(e.images);
            i.length > 0 && (r.textures = i), a.length > 0 && (r.images = a);
          }
          return r;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (e) {
          (this.name = e.name),
            (this.fog = e.fog),
            (this.lights = e.lights),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.flatShading = e.flatShading),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.visible = e.visible),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            (this.clipShadows = e.clipShadows),
            (this.clipIntersection = e.clipIntersection);
          var t = e.clippingPlanes,
            r = null;
          if (null !== t) {
            var n = t.length;
            r = new Array(n);
            for (var i = 0; i !== n; ++i) r[i] = t[i].clone();
          }
          return (this.clippingPlanes = r), (this.shadowSide = e.shadowSide), this;
        },
        dispose: function () {
          this.dispatchEvent({ type: 'dispose' });
        },
      })),
        (Tn.prototype = Object.create(En.prototype)),
        (Tn.prototype.constructor = Tn),
        (Tn.prototype.isShaderMaterial = !0),
        (Tn.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = wr(e.uniforms)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.extensions = e.extensions),
            this
          );
        }),
        (Tn.prototype.toJSON = function (e) {
          var t = En.prototype.toJSON.call(this, e);
          for (var r in ((t.uniforms = {}), this.uniforms)) {
            var n = this.uniforms[r].value;
            n && n.isTexture
              ? (t.uniforms[r] = { type: 't', value: n.toJSON(e).uuid })
              : n && n.isColor
              ? (t.uniforms[r] = { type: 'c', value: n.getHex() })
              : n && n.isVector2
              ? (t.uniforms[r] = { type: 'v2', value: n.toArray() })
              : n && n.isVector3
              ? (t.uniforms[r] = { type: 'v3', value: n.toArray() })
              : n && n.isVector4
              ? (t.uniforms[r] = { type: 'v4', value: n.toArray() })
              : n && n.isMatrix3
              ? (t.uniforms[r] = { type: 'm3', value: n.toArray() })
              : n && n.isMatrix4
              ? (t.uniforms[r] = { type: 'm4', value: n.toArray() })
              : (t.uniforms[r] = { value: n });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader);
          var i = {};
          for (var a in this.extensions) !0 === this.extensions[a] && (i[a] = !0);
          return Object.keys(i).length > 0 && (t.extensions = i), t;
        }),
        Object.assign(An.prototype, {
          set: function (e, t) {
            return this.origin.copy(e), this.direction.copy(t), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
          },
          at: function (e, t) {
            return (
              void 0 === t &&
                (console.warn('THREE.Ray: .at() target is now required'), (t = new tr())),
              t.copy(this.direction).multiplyScalar(e).add(this.origin)
            );
          },
          lookAt: function (e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this;
          },
          recast: (function () {
            var e = new tr();
            return function (t) {
              return this.origin.copy(this.at(t, e)), this;
            };
          })(),
          closestPointToPoint: function (e, t) {
            void 0 === t &&
              (console.warn('THREE.Ray: .closestPointToPoint() target is now required'),
              (t = new tr())),
              t.subVectors(e, this.origin);
            var r = t.dot(this.direction);
            return r < 0
              ? t.copy(this.origin)
              : t.copy(this.direction).multiplyScalar(r).add(this.origin);
          },
          distanceToPoint: function (e) {
            return Math.sqrt(this.distanceSqToPoint(e));
          },
          distanceSqToPoint: (function () {
            var e = new tr();
            return function (t) {
              var r = e.subVectors(t, this.origin).dot(this.direction);
              return r < 0
                ? this.origin.distanceToSquared(t)
                : (e.copy(this.direction).multiplyScalar(r).add(this.origin),
                  e.distanceToSquared(t));
            };
          })(),
          distanceSqToSegment:
            ((pn = new tr()),
            (fn = new tr()),
            (mn = new tr()),
            function (e, t, r, n) {
              pn.copy(e).add(t).multiplyScalar(0.5),
                fn.copy(t).sub(e).normalize(),
                mn.copy(this.origin).sub(pn);
              var i,
                a,
                o,
                s,
                c = 0.5 * e.distanceTo(t),
                u = -this.direction.dot(fn),
                l = mn.dot(this.direction),
                h = -mn.dot(fn),
                d = mn.lengthSq(),
                p = Math.abs(1 - u * u);
              if (p > 0)
                if (((a = u * l - h), (s = c * p), (i = u * h - l) >= 0))
                  if (a >= -s)
                    if (a <= s) {
                      var f = 1 / p;
                      o = (i *= f) * (i + u * (a *= f) + 2 * l) + a * (u * i + a + 2 * h) + d;
                    } else
                      (a = c), (o = -(i = Math.max(0, -(u * a + l))) * i + a * (a + 2 * h) + d);
                  else (a = -c), (o = -(i = Math.max(0, -(u * a + l))) * i + a * (a + 2 * h) + d);
                else
                  a <= -s
                    ? (o =
                        -(i = Math.max(0, -(-u * c + l))) * i +
                        (a = i > 0 ? -c : Math.min(Math.max(-c, -h), c)) * (a + 2 * h) +
                        d)
                    : a <= s
                    ? ((i = 0), (o = (a = Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d))
                    : (o =
                        -(i = Math.max(0, -(u * c + l))) * i +
                        (a = i > 0 ? c : Math.min(Math.max(-c, -h), c)) * (a + 2 * h) +
                        d);
              else
                (a = u > 0 ? -c : c),
                  (o = -(i = Math.max(0, -(u * a + l))) * i + a * (a + 2 * h) + d);
              return (
                r && r.copy(this.direction).multiplyScalar(i).add(this.origin),
                n && n.copy(fn).multiplyScalar(a).add(pn),
                o
              );
            }),
          intersectSphere: (function () {
            var e = new tr();
            return function (t, r) {
              e.subVectors(t.center, this.origin);
              var n = e.dot(this.direction),
                i = e.dot(e) - n * n,
                a = t.radius * t.radius;
              if (i > a) return null;
              var o = Math.sqrt(a - i),
                s = n - o,
                c = n + o;
              return s < 0 && c < 0 ? null : s < 0 ? this.at(c, r) : this.at(s, r);
            };
          })(),
          intersectsSphere: function (e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
          },
          distanceToPlane: function (e) {
            var t = e.normal.dot(this.direction);
            if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            var r = -(this.origin.dot(e.normal) + e.constant) / t;
            return r >= 0 ? r : null;
          },
          intersectPlane: function (e, t) {
            var r = this.distanceToPlane(e);
            return null === r ? null : this.at(r, t);
          },
          intersectsPlane: function (e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0;
          },
          intersectBox: function (e, t) {
            var r,
              n,
              i,
              a,
              o,
              s,
              c = 1 / this.direction.x,
              u = 1 / this.direction.y,
              l = 1 / this.direction.z,
              h = this.origin;
            return (
              c >= 0
                ? ((r = (e.min.x - h.x) * c), (n = (e.max.x - h.x) * c))
                : ((r = (e.max.x - h.x) * c), (n = (e.min.x - h.x) * c)),
              u >= 0
                ? ((i = (e.min.y - h.y) * u), (a = (e.max.y - h.y) * u))
                : ((i = (e.max.y - h.y) * u), (a = (e.min.y - h.y) * u)),
              r > a || i > n
                ? null
                : ((i > r || r != r) && (r = i),
                  (a < n || n != n) && (n = a),
                  l >= 0
                    ? ((o = (e.min.z - h.z) * l), (s = (e.max.z - h.z) * l))
                    : ((o = (e.max.z - h.z) * l), (s = (e.min.z - h.z) * l)),
                  r > s || o > n
                    ? null
                    : ((o > r || r != r) && (r = o),
                      (s < n || n != n) && (n = s),
                      n < 0 ? null : this.at(r >= 0 ? r : n, t)))
            );
          },
          intersectsBox:
            ((dn = new tr()),
            function (e) {
              return null !== this.intersectBox(e, dn);
            }),
          intersectTriangle: (function () {
            var e = new tr(),
              t = new tr(),
              r = new tr(),
              n = new tr();
            return function (i, a, o, s, c) {
              t.subVectors(a, i), r.subVectors(o, i), n.crossVectors(t, r);
              var u,
                l = this.direction.dot(n);
              if (l > 0) {
                if (s) return null;
                u = 1;
              } else {
                if (!(l < 0)) return null;
                (u = -1), (l = -l);
              }
              e.subVectors(this.origin, i);
              var h = u * this.direction.dot(r.crossVectors(e, r));
              if (h < 0) return null;
              var d = u * this.direction.dot(t.cross(e));
              if (d < 0) return null;
              if (h + d > l) return null;
              var p = -u * e.dot(n);
              return p < 0 ? null : this.at(p / l, c);
            };
          })(),
          applyMatrix4: function (e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
          },
          equals: function (e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction);
          },
        }),
        Object.assign(Ln, {
          getNormal:
            ((gn = new tr()),
            function (e, t, r, n) {
              void 0 === n &&
                (console.warn('THREE.Triangle: .getNormal() target is now required'),
                (n = new tr())),
                n.subVectors(r, t),
                gn.subVectors(e, t),
                n.cross(gn);
              var i = n.lengthSq();
              return i > 0 ? n.multiplyScalar(1 / Math.sqrt(i)) : n.set(0, 0, 0);
            }),
          getBarycoord: (function () {
            var e = new tr(),
              t = new tr(),
              r = new tr();
            return function (n, i, a, o, s) {
              e.subVectors(o, i), t.subVectors(a, i), r.subVectors(n, i);
              var c = e.dot(e),
                u = e.dot(t),
                l = e.dot(r),
                h = t.dot(t),
                d = t.dot(r),
                p = c * h - u * u;
              if (
                (void 0 === s &&
                  (console.warn('THREE.Triangle: .getBarycoord() target is now required'),
                  (s = new tr())),
                0 === p)
              )
                return s.set(-2, -1, -1);
              var f = 1 / p,
                m = (h * l - u * d) * f,
                v = (c * d - u * l) * f;
              return s.set(1 - m - v, v, m);
            };
          })(),
          containsPoint: (function () {
            var e = new tr();
            return function (t, r, n, i) {
              return Ln.getBarycoord(t, r, n, i, e), e.x >= 0 && e.y >= 0 && e.x + e.y <= 1;
            };
          })(),
          getUV:
            ((vn = new tr()),
            function (e, t, r, n, i, a, o, s) {
              return (
                this.getBarycoord(e, t, r, n, vn),
                s.set(0, 0),
                s.addScaledVector(i, vn.x),
                s.addScaledVector(a, vn.y),
                s.addScaledVector(o, vn.z),
                s
              );
            }),
        }),
        Object.assign(Ln.prototype, {
          set: function (e, t, r) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
          },
          setFromPointsAndIndices: function (e, t, r, n) {
            return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[n]), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
          },
          getArea: (function () {
            var e = new tr(),
              t = new tr();
            return function () {
              return (
                e.subVectors(this.c, this.b),
                t.subVectors(this.a, this.b),
                0.5 * e.cross(t).length()
              );
            };
          })(),
          getMidpoint: function (e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Triangle: .getMidpoint() target is now required'),
                (e = new tr())),
              e
                .addVectors(this.a, this.b)
                .add(this.c)
                .multiplyScalar(1 / 3)
            );
          },
          getNormal: function (e) {
            return Ln.getNormal(this.a, this.b, this.c, e);
          },
          getPlane: function (e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Triangle: .getPlane() target is now required'),
                (e = new tr())),
              e.setFromCoplanarPoints(this.a, this.b, this.c)
            );
          },
          getBarycoord: function (e, t) {
            return Ln.getBarycoord(e, this.a, this.b, this.c, t);
          },
          containsPoint: function (e) {
            return Ln.containsPoint(e, this.a, this.b, this.c);
          },
          getUV: function (e, t, r, n, i) {
            return Ln.getUV(e, this.a, this.b, this.c, t, r, n, i);
          },
          intersectsBox: function (e) {
            return e.intersectsTriangle(this);
          },
          closestPointToPoint:
            ((yn = new tr()),
            (xn = new tr()),
            (bn = new tr()),
            (wn = new tr()),
            (_n = new tr()),
            (Mn = new tr()),
            function (e, t) {
              void 0 === t &&
                (console.warn('THREE.Triangle: .closestPointToPoint() target is now required'),
                (t = new tr()));
              var r,
                n,
                i = this.a,
                a = this.b,
                o = this.c;
              yn.subVectors(a, i), xn.subVectors(o, i), wn.subVectors(e, i);
              var s = yn.dot(wn),
                c = xn.dot(wn);
              if (s <= 0 && c <= 0) return t.copy(i);
              _n.subVectors(e, a);
              var u = yn.dot(_n),
                l = xn.dot(_n);
              if (u >= 0 && l <= u) return t.copy(a);
              var h = s * l - u * c;
              if (h <= 0 && s >= 0 && u <= 0)
                return (r = s / (s - u)), t.copy(i).addScaledVector(yn, r);
              Mn.subVectors(e, o);
              var d = yn.dot(Mn),
                p = xn.dot(Mn);
              if (p >= 0 && d <= p) return t.copy(o);
              var f = d * c - s * p;
              if (f <= 0 && c >= 0 && p <= 0)
                return (n = c / (c - p)), t.copy(i).addScaledVector(xn, n);
              var m = u * p - d * l;
              if (m <= 0 && l - u >= 0 && d - p >= 0)
                return (
                  bn.subVectors(o, a),
                  (n = (l - u) / (l - u + (d - p))),
                  t.copy(a).addScaledVector(bn, n)
                );
              var v = 1 / (m + f + h);
              return (
                (r = f * v), (n = h * v), t.copy(i).addScaledVector(yn, r).addScaledVector(xn, n)
              );
            }),
          equals: function (e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
          },
        }),
        (Rn.prototype = Object.create(En.prototype)),
        (Rn.prototype.constructor = Rn),
        (Rn.prototype.isMeshBasicMaterial = !0),
        (Rn.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            this
          );
        }),
        (Cn.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: Cn,
          isMesh: !0,
          setDrawMode: function (e) {
            this.drawMode = e;
          },
          copy: function (e) {
            return (
              kr.prototype.copy.call(this, e),
              (this.drawMode = e.drawMode),
              void 0 !== e.morphTargetInfluences &&
                (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
              void 0 !== e.morphTargetDictionary &&
                (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
              this
            );
          },
          updateMorphTargets: function () {
            var e,
              t,
              r,
              n = this.geometry;
            if (n.isBufferGeometry) {
              var i = n.morphAttributes,
                a = Object.keys(i);
              if (a.length > 0) {
                var o = i[a[0]];
                if (void 0 !== o)
                  for (
                    this.morphTargetInfluences = [],
                      this.morphTargetDictionary = {},
                      e = 0,
                      t = o.length;
                    e < t;
                    e++
                  )
                    (r = o[e].name || String(e)),
                      this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[r] = e);
              }
            } else {
              var s = n.morphTargets;
              void 0 !== s &&
                s.length > 0 &&
                console.error(
                  'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                );
            }
          },
          raycast: (function () {
            var e = new $t(),
              t = new An(),
              r = new gr(),
              n = new tr(),
              i = new tr(),
              a = new tr(),
              o = new tr(),
              s = new tr(),
              c = new tr(),
              u = new Qt(),
              l = new Qt(),
              h = new Qt(),
              d = new tr(),
              p = new tr();
            function f(e, t, r, n, i, a, o, s) {
              if (
                null ===
                (t.side === L
                  ? n.intersectTriangle(o, a, i, !0, s)
                  : n.intersectTriangle(i, a, o, t.side !== R, s))
              )
                return null;
              p.copy(s), p.applyMatrix4(e.matrixWorld);
              var c = r.ray.origin.distanceTo(p);
              return c < r.near || c > r.far ? null : { distance: c, point: p.clone(), object: e };
            }
            function m(e, t, r, o, s, c, p, m, v) {
              n.fromBufferAttribute(s, p), i.fromBufferAttribute(s, m), a.fromBufferAttribute(s, v);
              var g = f(e, t, r, o, n, i, a, d);
              if (g) {
                c &&
                  (u.fromBufferAttribute(c, p),
                  l.fromBufferAttribute(c, m),
                  h.fromBufferAttribute(c, v),
                  (g.uv = Ln.getUV(d, n, i, a, u, l, h, new Qt())));
                var y = new Dr(p, m, v);
                Ln.getNormal(n, i, a, y.normal), (g.face = y);
              }
              return g;
            }
            return function (p, v) {
              var g,
                y = this.geometry,
                x = this.material,
                b = this.matrixWorld;
              if (
                void 0 !== x &&
                (null === y.boundingSphere && y.computeBoundingSphere(),
                r.copy(y.boundingSphere),
                r.applyMatrix4(b),
                !1 !== p.ray.intersectsSphere(r) &&
                  (e.getInverse(b),
                  t.copy(p.ray).applyMatrix4(e),
                  null === y.boundingBox || !1 !== t.intersectsBox(y.boundingBox)))
              )
                if (y.isBufferGeometry) {
                  var w,
                    _,
                    M,
                    S,
                    E,
                    T,
                    A,
                    L,
                    R,
                    C = y.index,
                    P = y.attributes.position,
                    O = y.attributes.uv,
                    I = y.groups,
                    D = y.drawRange;
                  if (null !== C)
                    if (Array.isArray(x))
                      for (S = 0, T = I.length; S < T; S++)
                        for (
                          R = x[(L = I[S]).materialIndex],
                            E = Math.max(L.start, D.start),
                            A = Math.min(L.start + L.count, D.start + D.count);
                          E < A;
                          E += 3
                        )
                          (w = C.getX(E)),
                            (_ = C.getX(E + 1)),
                            (M = C.getX(E + 2)),
                            (g = m(this, R, p, t, P, O, w, _, M)) &&
                              ((g.faceIndex = Math.floor(E / 3)),
                              (g.face.materialIndex = L.materialIndex),
                              v.push(g));
                    else
                      for (
                        S = Math.max(0, D.start), T = Math.min(C.count, D.start + D.count);
                        S < T;
                        S += 3
                      )
                        (w = C.getX(S)),
                          (_ = C.getX(S + 1)),
                          (M = C.getX(S + 2)),
                          (g = m(this, x, p, t, P, O, w, _, M)) &&
                            ((g.faceIndex = Math.floor(S / 3)), v.push(g));
                  else if (void 0 !== P)
                    if (Array.isArray(x))
                      for (S = 0, T = I.length; S < T; S++)
                        for (
                          R = x[(L = I[S]).materialIndex],
                            E = Math.max(L.start, D.start),
                            A = Math.min(L.start + L.count, D.start + D.count);
                          E < A;
                          E += 3
                        )
                          (g = m(this, R, p, t, P, O, (w = E), (_ = E + 1), (M = E + 2))) &&
                            ((g.faceIndex = Math.floor(E / 3)),
                            (g.face.materialIndex = L.materialIndex),
                            v.push(g));
                    else
                      for (
                        S = Math.max(0, D.start), T = Math.min(P.count, D.start + D.count);
                        S < T;
                        S += 3
                      )
                        (g = m(this, x, p, t, P, O, (w = S), (_ = S + 1), (M = S + 2))) &&
                          ((g.faceIndex = Math.floor(S / 3)), v.push(g));
                } else if (y.isGeometry) {
                  var B,
                    N,
                    U,
                    G,
                    F = Array.isArray(x),
                    z = y.vertices,
                    H = y.faces,
                    k = y.faceVertexUvs[0];
                  k.length > 0 && (G = k);
                  for (var V = 0, j = H.length; V < j; V++) {
                    var W = H[V],
                      q = F ? x[W.materialIndex] : x;
                    if (void 0 !== q) {
                      if (((B = z[W.a]), (N = z[W.b]), (U = z[W.c]), !0 === q.morphTargets)) {
                        var X = y.morphTargets,
                          Y = this.morphTargetInfluences;
                        n.set(0, 0, 0), i.set(0, 0, 0), a.set(0, 0, 0);
                        for (var J = 0, Z = X.length; J < Z; J++) {
                          var K = Y[J];
                          if (0 !== K) {
                            var Q = X[J].vertices;
                            n.addScaledVector(o.subVectors(Q[W.a], B), K),
                              i.addScaledVector(s.subVectors(Q[W.b], N), K),
                              a.addScaledVector(c.subVectors(Q[W.c], U), K);
                          }
                        }
                        n.add(B), i.add(N), a.add(U), (B = n), (N = i), (U = a);
                      }
                      if ((g = f(this, q, p, t, B, N, U, d))) {
                        if (G && G[V]) {
                          var $ = G[V];
                          u.copy($[0]),
                            l.copy($[1]),
                            h.copy($[2]),
                            (g.uv = Ln.getUV(d, B, N, U, u, l, h, new Qt()));
                        }
                        (g.face = W), (g.faceIndex = V), v.push(g);
                      }
                    }
                  }
                }
            };
          })(),
          clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this);
          },
        })),
        (kn.prototype = Object.create(lr.prototype)),
        (kn.prototype.constructor = kn),
        (kn.prototype.isCubeTexture = !0),
        Object.defineProperty(kn.prototype, 'images', {
          get: function () {
            return this.image;
          },
          set: function (e) {
            this.image = e;
          },
        }),
        (Vn.prototype = Object.create(lr.prototype)),
        (Vn.prototype.constructor = Vn),
        (Vn.prototype.isDataTexture3D = !0);
      var jn = new lr(),
        Wn = new Vn(),
        qn = new kn();
      function Xn() {
        (this.seq = []), (this.map = {});
      }
      var Yn = [],
        Jn = [],
        Zn = new Float32Array(16),
        Kn = new Float32Array(9),
        Qn = new Float32Array(4);
      function $n(e, t, r) {
        var n = e[0];
        if (n <= 0 || n > 0) return e;
        var i = t * r,
          a = Yn[i];
        if ((void 0 === a && ((a = new Float32Array(i)), (Yn[i] = a)), 0 !== t)) {
          n.toArray(a, 0);
          for (var o = 1, s = 0; o !== t; ++o) (s += r), e[o].toArray(a, s);
        }
        return a;
      }
      function ei(e, t) {
        if (e.length !== t.length) return !1;
        for (var r = 0, n = e.length; r < n; r++) if (e[r] !== t[r]) return !1;
        return !0;
      }
      function ti(e, t) {
        for (var r = 0, n = t.length; r < n; r++) e[r] = t[r];
      }
      function ri(e, t) {
        var r = Jn[t];
        void 0 === r && ((r = new Int32Array(t)), (Jn[t] = r));
        for (var n = 0; n !== t; ++n) r[n] = e.allocTextureUnit();
        return r;
      }
      function ni(e, t) {
        var r = this.cache;
        r[0] !== t && (e.uniform1f(this.addr, t), (r[0] = t));
      }
      function ii(e, t) {
        var r = this.cache;
        r[0] !== t && (e.uniform1i(this.addr, t), (r[0] = t));
      }
      function ai(e, t) {
        var r = this.cache;
        if (void 0 !== t.x)
          (r[0] === t.x && r[1] === t.y) ||
            (e.uniform2f(this.addr, t.x, t.y), (r[0] = t.x), (r[1] = t.y));
        else {
          if (ei(r, t)) return;
          e.uniform2fv(this.addr, t), ti(r, t);
        }
      }
      function oi(e, t) {
        var r = this.cache;
        if (void 0 !== t.x)
          (r[0] === t.x && r[1] === t.y && r[2] === t.z) ||
            (e.uniform3f(this.addr, t.x, t.y, t.z), (r[0] = t.x), (r[1] = t.y), (r[2] = t.z));
        else if (void 0 !== t.r)
          (r[0] === t.r && r[1] === t.g && r[2] === t.b) ||
            (e.uniform3f(this.addr, t.r, t.g, t.b), (r[0] = t.r), (r[1] = t.g), (r[2] = t.b));
        else {
          if (ei(r, t)) return;
          e.uniform3fv(this.addr, t), ti(r, t);
        }
      }
      function si(e, t) {
        var r = this.cache;
        if (void 0 !== t.x)
          (r[0] === t.x && r[1] === t.y && r[2] === t.z && r[3] === t.w) ||
            (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            (r[0] = t.x),
            (r[1] = t.y),
            (r[2] = t.z),
            (r[3] = t.w));
        else {
          if (ei(r, t)) return;
          e.uniform4fv(this.addr, t), ti(r, t);
        }
      }
      function ci(e, t) {
        var r = this.cache,
          n = t.elements;
        if (void 0 === n) {
          if (ei(r, t)) return;
          e.uniformMatrix2fv(this.addr, !1, t), ti(r, t);
        } else {
          if (ei(r, n)) return;
          Qn.set(n), e.uniformMatrix2fv(this.addr, !1, Qn), ti(r, n);
        }
      }
      function ui(e, t) {
        var r = this.cache,
          n = t.elements;
        if (void 0 === n) {
          if (ei(r, t)) return;
          e.uniformMatrix3fv(this.addr, !1, t), ti(r, t);
        } else {
          if (ei(r, n)) return;
          Kn.set(n), e.uniformMatrix3fv(this.addr, !1, Kn), ti(r, n);
        }
      }
      function li(e, t) {
        var r = this.cache,
          n = t.elements;
        if (void 0 === n) {
          if (ei(r, t)) return;
          e.uniformMatrix4fv(this.addr, !1, t), ti(r, t);
        } else {
          if (ei(r, n)) return;
          Zn.set(n), e.uniformMatrix4fv(this.addr, !1, Zn), ti(r, n);
        }
      }
      function hi(e, t, r) {
        var n = this.cache,
          i = r.allocTextureUnit();
        n[0] !== i && (e.uniform1i(this.addr, i), (n[0] = i)), r.setTexture2D(t || jn, i);
      }
      function di(e, t, r) {
        var n = this.cache,
          i = r.allocTextureUnit();
        n[0] !== i && (e.uniform1i(this.addr, i), (n[0] = i)), r.setTexture3D(t || Wn, i);
      }
      function pi(e, t, r) {
        var n = this.cache,
          i = r.allocTextureUnit();
        n[0] !== i && (e.uniform1i(this.addr, i), (n[0] = i)), r.setTextureCube(t || qn, i);
      }
      function fi(e, t) {
        var r = this.cache;
        ei(r, t) || (e.uniform2iv(this.addr, t), ti(r, t));
      }
      function mi(e, t) {
        var r = this.cache;
        ei(r, t) || (e.uniform3iv(this.addr, t), ti(r, t));
      }
      function vi(e, t) {
        var r = this.cache;
        ei(r, t) || (e.uniform4iv(this.addr, t), ti(r, t));
      }
      function gi(e, t) {
        var r = this.cache;
        ei(r, t) || (e.uniform1fv(this.addr, t), ti(r, t));
      }
      function yi(e, t) {
        var r = this.cache;
        ei(r, t) || (e.uniform1iv(this.addr, t), ti(r, t));
      }
      function xi(e, t) {
        var r = this.cache,
          n = $n(t, this.size, 2);
        ei(r, n) || (e.uniform2fv(this.addr, n), this.updateCache(n));
      }
      function bi(e, t) {
        var r = this.cache,
          n = $n(t, this.size, 3);
        ei(r, n) || (e.uniform3fv(this.addr, n), this.updateCache(n));
      }
      function wi(e, t) {
        var r = this.cache,
          n = $n(t, this.size, 4);
        ei(r, n) || (e.uniform4fv(this.addr, n), this.updateCache(n));
      }
      function _i(e, t) {
        var r = this.cache,
          n = $n(t, this.size, 4);
        ei(r, n) || (e.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n));
      }
      function Mi(e, t) {
        var r = this.cache,
          n = $n(t, this.size, 9);
        ei(r, n) || (e.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n));
      }
      function Si(e, t) {
        var r = this.cache,
          n = $n(t, this.size, 16);
        ei(r, n) || (e.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n));
      }
      function Ei(e, t, r) {
        var n = this.cache,
          i = t.length,
          a = ri(r, i);
        !1 === ei(n, a) && (e.uniform1iv(this.addr, a), ti(n, a));
        for (var o = 0; o !== i; ++o) r.setTexture2D(t[o] || jn, a[o]);
      }
      function Ti(e, t, r) {
        var n = this.cache,
          i = t.length,
          a = ri(r, i);
        !1 === ei(n, a) && (e.uniform1iv(this.addr, a), ti(n, a));
        for (var o = 0; o !== i; ++o) r.setTextureCube(t[o] || qn, a[o]);
      }
      function Ai(e, t, r) {
        (this.id = e),
          (this.addr = r),
          (this.cache = []),
          (this.setValue = (function (e) {
            switch (e) {
              case 5126:
                return ni;
              case 35664:
                return ai;
              case 35665:
                return oi;
              case 35666:
                return si;
              case 35674:
                return ci;
              case 35675:
                return ui;
              case 35676:
                return li;
              case 35678:
              case 36198:
                return hi;
              case 35679:
                return di;
              case 35680:
                return pi;
              case 5124:
              case 35670:
                return ii;
              case 35667:
              case 35671:
                return fi;
              case 35668:
              case 35672:
                return mi;
              case 35669:
              case 35673:
                return vi;
            }
          })(t.type));
      }
      function Li(e, t, r) {
        (this.id = e),
          (this.addr = r),
          (this.cache = []),
          (this.size = t.size),
          (this.setValue = (function (e) {
            switch (e) {
              case 5126:
                return gi;
              case 35664:
                return xi;
              case 35665:
                return bi;
              case 35666:
                return wi;
              case 35674:
                return _i;
              case 35675:
                return Mi;
              case 35676:
                return Si;
              case 35678:
                return Ei;
              case 35680:
                return Ti;
              case 5124:
              case 35670:
                return yi;
              case 35667:
              case 35671:
                return fi;
              case 35668:
              case 35672:
                return mi;
              case 35669:
              case 35673:
                return vi;
            }
          })(t.type));
      }
      function Ri(e) {
        (this.id = e), Xn.call(this);
      }
      (Li.prototype.updateCache = function (e) {
        var t = this.cache;
        e instanceof Float32Array &&
          t.length !== e.length &&
          (this.cache = new Float32Array(e.length)),
          ti(t, e);
      }),
        (Ri.prototype.setValue = function (e, t, r) {
          for (var n = this.seq, i = 0, a = n.length; i !== a; ++i) {
            var o = n[i];
            o.setValue(e, t[o.id], r);
          }
        });
      var Ci = /([\w\d_]+)(\])?(\[|\.)?/g;
      function Pi(e, t) {
        e.seq.push(t), (e.map[t.id] = t);
      }
      function Oi(e, t, r) {
        var n = e.name,
          i = n.length;
        for (Ci.lastIndex = 0; ; ) {
          var a = Ci.exec(n),
            o = Ci.lastIndex,
            s = a[1],
            c = ']' === a[2],
            u = a[3];
          if ((c && (s |= 0), void 0 === u || ('[' === u && o + 2 === i))) {
            Pi(r, void 0 === u ? new Ai(s, e, t) : new Li(s, e, t));
            break;
          }
          var l = r.map[s];
          void 0 === l && Pi(r, (l = new Ri(s))), (r = l);
        }
      }
      function Ii(e, t, r) {
        Xn.call(this), (this.renderer = r);
        for (var n = e.getProgramParameter(t, 35718), i = 0; i < n; ++i) {
          var a = e.getActiveUniform(t, i);
          Oi(a, e.getUniformLocation(t, a.name), this);
        }
      }
      function Di(e, t, r) {
        var n = e.createShader(t);
        return (
          e.shaderSource(n, r),
          e.compileShader(n),
          !1 === e.getShaderParameter(n, 35713) &&
            console.error("THREE.WebGLShader: Shader couldn't compile."),
          '' !== e.getShaderInfoLog(n) &&
            console.warn(
              'THREE.WebGLShader: gl.getShaderInfoLog()',
              35633 === t ? 'vertex' : 'fragment',
              e.getShaderInfoLog(n),
              (function (e) {
                for (var t = e.split('\n'), r = 0; r < t.length; r++) t[r] = r + 1 + ': ' + t[r];
                return t.join('\n');
              })(r),
            ),
          n
        );
      }
      (Ii.prototype.setValue = function (e, t, r) {
        var n = this.map[t];
        void 0 !== n && n.setValue(e, r, this.renderer);
      }),
        (Ii.prototype.setOptional = function (e, t, r) {
          var n = t[r];
          void 0 !== n && this.setValue(e, r, n);
        }),
        (Ii.upload = function (e, t, r, n) {
          for (var i = 0, a = t.length; i !== a; ++i) {
            var o = t[i],
              s = r[o.id];
            !1 !== s.needsUpdate && o.setValue(e, s.value, n);
          }
        }),
        (Ii.seqWithValue = function (e, t) {
          for (var r = [], n = 0, i = e.length; n !== i; ++n) {
            var a = e[n];
            a.id in t && r.push(a);
          }
          return r;
        });
      var Bi = 0;
      function Ni(e) {
        switch (e) {
          case Ft:
            return ['Linear', '( value )'];
          case zt:
            return ['sRGB', '( value )'];
          case kt:
            return ['RGBE', '( value )'];
          case jt:
            return ['RGBM', '( value, 7.0 )'];
          case Wt:
            return ['RGBM', '( value, 16.0 )'];
          case qt:
            return ['RGBD', '( value, 256.0 )'];
          case Ht:
            return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
          default:
            throw new Error('unsupported encoding: ' + e);
        }
      }
      function Ui(e, t) {
        var r = Ni(t);
        return 'vec4 ' + e + '( vec4 value ) { return ' + r[0] + 'ToLinear' + r[1] + '; }';
      }
      function Gi(e, t) {
        var r;
        switch (t) {
          case me:
            r = 'Linear';
            break;
          case ve:
            r = 'Reinhard';
            break;
          case ge:
            r = 'Uncharted2';
            break;
          case ye:
            r = 'OptimizedCineon';
            break;
          case xe:
            r = 'ACESFilmic';
            break;
          default:
            throw new Error('unsupported toneMapping: ' + t);
        }
        return 'vec3 ' + e + '( vec3 color ) { return ' + r + 'ToneMapping( color ); }';
      }
      function Fi(e) {
        return '' !== e;
      }
      function zi(e, t) {
        return e
          .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights);
      }
      function Hi(e, t) {
        return e
          .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
          .replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
      }
      function ki(e) {
        return e.replace(/^[ \t]*#include +<([\w\d.\/]+)>/gm, function (e, t) {
          var r = br[t];
          if (void 0 === r) throw new Error('Can not resolve #include <' + t + '>');
          return ki(r);
        });
      }
      function Vi(e) {
        return e.replace(
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
          function (e, t, r, n) {
            for (var i = '', a = parseInt(t); a < parseInt(r); a++)
              i += n.replace(/\[ i \]/g, '[ ' + a + ' ]');
            return i;
          },
        );
      }
      function ji(e, t, r, n, i, a, o) {
        var s = e.context,
          c = n.defines,
          u = i.vertexShader,
          l = i.fragmentShader,
          h = 'SHADOWMAP_TYPE_BASIC';
        a.shadowMapType === E
          ? (h = 'SHADOWMAP_TYPE_PCF')
          : a.shadowMapType === T && (h = 'SHADOWMAP_TYPE_PCF_SOFT');
        var d = 'ENVMAP_TYPE_CUBE',
          p = 'ENVMAP_MODE_REFLECTION',
          f = 'ENVMAP_BLENDING_MULTIPLY';
        if (a.envMap) {
          switch (n.envMap.mapping) {
            case we:
            case _e:
              d = 'ENVMAP_TYPE_CUBE';
              break;
            case Te:
            case Ae:
              d = 'ENVMAP_TYPE_CUBE_UV';
              break;
            case Me:
            case Se:
              d = 'ENVMAP_TYPE_EQUIREC';
              break;
            case Ee:
              d = 'ENVMAP_TYPE_SPHERE';
          }
          switch (n.envMap.mapping) {
            case _e:
            case Se:
              p = 'ENVMAP_MODE_REFRACTION';
          }
          switch (n.combine) {
            case he:
              f = 'ENVMAP_BLENDING_MULTIPLY';
              break;
            case de:
              f = 'ENVMAP_BLENDING_MIX';
              break;
            case pe:
              f = 'ENVMAP_BLENDING_ADD';
          }
        }
        var m,
          v,
          g,
          y,
          x,
          b = e.gammaFactor > 0 ? e.gammaFactor : 1,
          w = o.isWebGL2
            ? ''
            : (function (e, t, r) {
                return [
                  (e = e || {}).derivatives ||
                  t.envMapCubeUV ||
                  t.bumpMap ||
                  (t.normalMap && !t.objectSpaceNormalMap) ||
                  t.flatShading
                    ? '#extension GL_OES_standard_derivatives : enable'
                    : '',
                  (e.fragDepth || t.logarithmicDepthBuffer) && r.get('EXT_frag_depth')
                    ? '#extension GL_EXT_frag_depth : enable'
                    : '',
                  e.drawBuffers && r.get('WEBGL_draw_buffers')
                    ? '#extension GL_EXT_draw_buffers : require'
                    : '',
                  (e.shaderTextureLOD || t.envMap) && r.get('EXT_shader_texture_lod')
                    ? '#extension GL_EXT_shader_texture_lod : enable'
                    : '',
                ]
                  .filter(Fi)
                  .join('\n');
              })(n.extensions, a, t),
          _ = (function (e) {
            var t = [];
            for (var r in e) {
              var n = e[r];
              !1 !== n && t.push('#define ' + r + ' ' + n);
            }
            return t.join('\n');
          })(c),
          M = s.createProgram();
        if (
          (n.isRawShaderMaterial
            ? ((m = [_].filter(Fi).join('\n')).length > 0 && (m += '\n'),
              (v = [w, _].filter(Fi).join('\n')).length > 0 && (v += '\n'))
            : ((m = [
                'precision ' + a.precision + ' float;',
                'precision ' + a.precision + ' int;',
                '#define SHADER_NAME ' + i.name,
                _,
                a.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                '#define GAMMA_FACTOR ' + b,
                '#define MAX_BONES ' + a.maxBones,
                a.useFog && a.fog ? '#define USE_FOG' : '',
                a.useFog && a.fogExp ? '#define FOG_EXP2' : '',
                a.map ? '#define USE_MAP' : '',
                a.envMap ? '#define USE_ENVMAP' : '',
                a.envMap ? '#define ' + p : '',
                a.lightMap ? '#define USE_LIGHTMAP' : '',
                a.aoMap ? '#define USE_AOMAP' : '',
                a.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                a.bumpMap ? '#define USE_BUMPMAP' : '',
                a.normalMap ? '#define USE_NORMALMAP' : '',
                a.normalMap && a.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
                a.displacementMap && a.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                a.specularMap ? '#define USE_SPECULARMAP' : '',
                a.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                a.metalnessMap ? '#define USE_METALNESSMAP' : '',
                a.alphaMap ? '#define USE_ALPHAMAP' : '',
                a.vertexColors ? '#define USE_COLOR' : '',
                a.flatShading ? '#define FLAT_SHADED' : '',
                a.skinning ? '#define USE_SKINNING' : '',
                a.useVertexTexture ? '#define BONE_TEXTURE' : '',
                a.morphTargets ? '#define USE_MORPHTARGETS' : '',
                a.morphNormals && !1 === a.flatShading ? '#define USE_MORPHNORMALS' : '',
                a.doubleSided ? '#define DOUBLE_SIDED' : '',
                a.flipSided ? '#define FLIP_SIDED' : '',
                a.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                a.shadowMapEnabled ? '#define ' + h : '',
                a.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                a.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                a.logarithmicDepthBuffer && (o.isWebGL2 || t.get('EXT_frag_depth'))
                  ? '#define USE_LOGDEPTHBUF_EXT'
                  : '',
                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',
                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',
                '#ifdef USE_COLOR',
                '\tattribute vec3 color;',
                '#endif',
                '#ifdef USE_MORPHTARGETS',
                '\tattribute vec3 morphTarget0;',
                '\tattribute vec3 morphTarget1;',
                '\tattribute vec3 morphTarget2;',
                '\tattribute vec3 morphTarget3;',
                '\t#ifdef USE_MORPHNORMALS',
                '\t\tattribute vec3 morphNormal0;',
                '\t\tattribute vec3 morphNormal1;',
                '\t\tattribute vec3 morphNormal2;',
                '\t\tattribute vec3 morphNormal3;',
                '\t#else',
                '\t\tattribute vec3 morphTarget4;',
                '\t\tattribute vec3 morphTarget5;',
                '\t\tattribute vec3 morphTarget6;',
                '\t\tattribute vec3 morphTarget7;',
                '\t#endif',
                '#endif',
                '#ifdef USE_SKINNING',
                '\tattribute vec4 skinIndex;',
                '\tattribute vec4 skinWeight;',
                '#endif',
                '\n',
              ]
                .filter(Fi)
                .join('\n')),
              (v = [
                w,
                'precision ' + a.precision + ' float;',
                'precision ' + a.precision + ' int;',
                '#define SHADER_NAME ' + i.name,
                _,
                a.alphaTest
                  ? '#define ALPHATEST ' + a.alphaTest + (a.alphaTest % 1 ? '' : '.0')
                  : '',
                '#define GAMMA_FACTOR ' + b,
                a.useFog && a.fog ? '#define USE_FOG' : '',
                a.useFog && a.fogExp ? '#define FOG_EXP2' : '',
                a.map ? '#define USE_MAP' : '',
                a.matcap ? '#define USE_MATCAP' : '',
                a.envMap ? '#define USE_ENVMAP' : '',
                a.envMap ? '#define ' + d : '',
                a.envMap ? '#define ' + p : '',
                a.envMap ? '#define ' + f : '',
                a.lightMap ? '#define USE_LIGHTMAP' : '',
                a.aoMap ? '#define USE_AOMAP' : '',
                a.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                a.bumpMap ? '#define USE_BUMPMAP' : '',
                a.normalMap ? '#define USE_NORMALMAP' : '',
                a.normalMap && a.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
                a.specularMap ? '#define USE_SPECULARMAP' : '',
                a.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                a.metalnessMap ? '#define USE_METALNESSMAP' : '',
                a.alphaMap ? '#define USE_ALPHAMAP' : '',
                a.vertexColors ? '#define USE_COLOR' : '',
                a.gradientMap ? '#define USE_GRADIENTMAP' : '',
                a.flatShading ? '#define FLAT_SHADED' : '',
                a.doubleSided ? '#define DOUBLE_SIDED' : '',
                a.flipSided ? '#define FLIP_SIDED' : '',
                a.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                a.shadowMapEnabled ? '#define ' + h : '',
                a.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
                a.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
                a.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                a.logarithmicDepthBuffer && (o.isWebGL2 || t.get('EXT_frag_depth'))
                  ? '#define USE_LOGDEPTHBUF_EXT'
                  : '',
                a.envMap && (o.isWebGL2 || t.get('EXT_shader_texture_lod'))
                  ? '#define TEXTURE_LOD_EXT'
                  : '',
                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',
                a.toneMapping !== fe ? '#define TONE_MAPPING' : '',
                a.toneMapping !== fe ? br.tonemapping_pars_fragment : '',
                a.toneMapping !== fe ? Gi('toneMapping', a.toneMapping) : '',
                a.dithering ? '#define DITHERING' : '',
                a.outputEncoding ||
                a.mapEncoding ||
                a.matcapEncoding ||
                a.envMapEncoding ||
                a.emissiveMapEncoding
                  ? br.encodings_pars_fragment
                  : '',
                a.mapEncoding ? Ui('mapTexelToLinear', a.mapEncoding) : '',
                a.matcapEncoding ? Ui('matcapTexelToLinear', a.matcapEncoding) : '',
                a.envMapEncoding ? Ui('envMapTexelToLinear', a.envMapEncoding) : '',
                a.emissiveMapEncoding ? Ui('emissiveMapTexelToLinear', a.emissiveMapEncoding) : '',
                a.outputEncoding
                  ? ((g = 'linearToOutputTexel'),
                    (y = a.outputEncoding),
                    (x = Ni(y)),
                    'vec4 ' + g + '( vec4 value ) { return LinearTo' + x[0] + x[1] + '; }')
                  : '',
                a.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
                '\n',
              ]
                .filter(Fi)
                .join('\n'))),
          (u = Hi((u = zi((u = ki(u)), a)), a)),
          (l = Hi((l = zi((l = ki(l)), a)), a)),
          (u = Vi(u)),
          (l = Vi(l)),
          o.isWebGL2 && !n.isRawShaderMaterial)
        ) {
          var S = !1,
            A = /^\s*#version\s+300\s+es\s*\n/;
          n.isShaderMaterial &&
            null !== u.match(A) &&
            null !== l.match(A) &&
            ((S = !0), (u = u.replace(A, '')), (l = l.replace(A, ''))),
            (m =
              [
                '#version 300 es\n',
                '#define attribute in',
                '#define varying out',
                '#define texture2D texture',
              ].join('\n') +
              '\n' +
              m),
            (v =
              [
                '#version 300 es\n',
                '#define varying in',
                S ? '' : 'out highp vec4 pc_fragColor;',
                S ? '' : '#define gl_FragColor pc_fragColor',
                '#define gl_FragDepthEXT gl_FragDepth',
                '#define texture2D texture',
                '#define textureCube texture',
                '#define texture2DProj textureProj',
                '#define texture2DLodEXT textureLod',
                '#define texture2DProjLodEXT textureProjLod',
                '#define textureCubeLodEXT textureLod',
                '#define texture2DGradEXT textureGrad',
                '#define texture2DProjGradEXT textureProjGrad',
                '#define textureCubeGradEXT textureGrad',
              ].join('\n') +
              '\n' +
              v);
        }
        var L = v + l,
          R = Di(s, 35633, m + u),
          C = Di(s, 35632, L);
        s.attachShader(M, R),
          s.attachShader(M, C),
          void 0 !== n.index0AttributeName
            ? s.bindAttribLocation(M, 0, n.index0AttributeName)
            : !0 === a.morphTargets && s.bindAttribLocation(M, 0, 'position'),
          s.linkProgram(M);
        var P,
          O,
          I = s.getProgramInfoLog(M).trim(),
          D = s.getShaderInfoLog(R).trim(),
          B = s.getShaderInfoLog(C).trim(),
          N = !0,
          U = !0;
        return (
          !1 === s.getProgramParameter(M, 35714)
            ? ((N = !1),
              console.error(
                'THREE.WebGLProgram: shader error: ',
                s.getError(),
                '35715',
                s.getProgramParameter(M, 35715),
                'gl.getProgramInfoLog',
                I,
                D,
                B,
              ))
            : '' !== I
            ? console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', I)
            : ('' !== D && '' !== B) || (U = !1),
          U &&
            (this.diagnostics = {
              runnable: N,
              material: n,
              programLog: I,
              vertexShader: { log: D, prefix: m },
              fragmentShader: { log: B, prefix: v },
            }),
          s.deleteShader(R),
          s.deleteShader(C),
          (this.getUniforms = function () {
            return void 0 === P && (P = new Ii(s, M, e)), P;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === O &&
                (O = (function (e, t) {
                  for (var r = {}, n = e.getProgramParameter(t, 35721), i = 0; i < n; i++) {
                    var a = e.getActiveAttrib(t, i).name;
                    r[a] = e.getAttribLocation(t, a);
                  }
                  return r;
                })(s, M)),
              O
            );
          }),
          (this.destroy = function () {
            s.deleteProgram(M), (this.program = void 0);
          }),
          Object.defineProperties(this, {
            uniforms: {
              get: function () {
                return (
                  console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().'),
                  this.getUniforms()
                );
              },
            },
            attributes: {
              get: function () {
                return (
                  console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().'),
                  this.getAttributes()
                );
              },
            },
          }),
          (this.name = i.name),
          (this.id = Bi++),
          (this.code = r),
          (this.usedTimes = 1),
          (this.program = M),
          (this.vertexShader = R),
          (this.fragmentShader = C),
          this
        );
      }
      function Wi(e, t, r) {
        var n = [],
          i = {
            MeshDepthMaterial: 'depth',
            MeshDistanceMaterial: 'distanceRGBA',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'phong',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            MeshMatcapMaterial: 'matcap',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points',
            ShadowMaterial: 'shadow',
            SpriteMaterial: 'sprite',
          },
          a = [
            'precision',
            'supportsVertexTextures',
            'map',
            'mapEncoding',
            'matcap',
            'matcapEncoding',
            'envMap',
            'envMapMode',
            'envMapEncoding',
            'lightMap',
            'aoMap',
            'emissiveMap',
            'emissiveMapEncoding',
            'bumpMap',
            'normalMap',
            'objectSpaceNormalMap',
            'displacementMap',
            'specularMap',
            'roughnessMap',
            'metalnessMap',
            'gradientMap',
            'alphaMap',
            'combine',
            'vertexColors',
            'fog',
            'useFog',
            'fogExp',
            'flatShading',
            'sizeAttenuation',
            'logarithmicDepthBuffer',
            'skinning',
            'maxBones',
            'useVertexTexture',
            'morphTargets',
            'morphNormals',
            'maxMorphTargets',
            'maxMorphNormals',
            'premultipliedAlpha',
            'numDirLights',
            'numPointLights',
            'numSpotLights',
            'numHemiLights',
            'numRectAreaLights',
            'shadowMapEnabled',
            'shadowMapType',
            'toneMapping',
            'physicallyCorrectLights',
            'alphaTest',
            'doubleSided',
            'flipSided',
            'numClippingPlanes',
            'numClipIntersection',
            'depthPacking',
            'dithering',
          ];
        function o(e, t) {
          var r;
          return (
            e
              ? e.isTexture
                ? (r = e.encoding)
                : e.isWebGLRenderTarget &&
                  (console.warn(
                    "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.",
                  ),
                  (r = e.texture.encoding))
              : (r = Ft),
            r === Ft && t && (r = Ht),
            r
          );
        }
        (this.getParameters = function (t, n, a, s, c, u, l) {
          var h = i[t.type],
            d = l.isSkinnedMesh
              ? (function (e) {
                  var t = e.skeleton.bones;
                  if (r.floatVertexTextures) return 1024;
                  var n = r.maxVertexUniforms,
                    i = Math.floor((n - 20) / 4),
                    a = Math.min(i, t.length);
                  return a < t.length
                    ? (console.warn(
                        'THREE.WebGLRenderer: Skeleton has ' +
                          t.length +
                          ' bones. This GPU supports ' +
                          a +
                          '.',
                      ),
                      0)
                    : a;
                })(l)
              : 0,
            p = r.precision;
          null !== t.precision &&
            (p = r.getMaxPrecision(t.precision)) !== t.precision &&
            console.warn(
              'THREE.WebGLProgram.getParameters:',
              t.precision,
              'not supported, using',
              p,
              'instead.',
            );
          var f = e.getRenderTarget();
          return {
            shaderID: h,
            precision: p,
            supportsVertexTextures: r.vertexTextures,
            outputEncoding: o(f ? f.texture : null, e.gammaOutput),
            map: !!t.map,
            mapEncoding: o(t.map, e.gammaInput),
            matcap: !!t.matcap,
            matcapEncoding: o(t.matcap, e.gammaInput),
            envMap: !!t.envMap,
            envMapMode: t.envMap && t.envMap.mapping,
            envMapEncoding: o(t.envMap, e.gammaInput),
            envMapCubeUV: !!t.envMap && (t.envMap.mapping === Te || t.envMap.mapping === Ae),
            lightMap: !!t.lightMap,
            aoMap: !!t.aoMap,
            emissiveMap: !!t.emissiveMap,
            emissiveMapEncoding: o(t.emissiveMap, e.gammaInput),
            bumpMap: !!t.bumpMap,
            normalMap: !!t.normalMap,
            objectSpaceNormalMap: t.normalMapType === Zt,
            displacementMap: !!t.displacementMap,
            roughnessMap: !!t.roughnessMap,
            metalnessMap: !!t.metalnessMap,
            specularMap: !!t.specularMap,
            alphaMap: !!t.alphaMap,
            gradientMap: !!t.gradientMap,
            combine: t.combine,
            vertexColors: t.vertexColors,
            fog: !!s,
            useFog: t.fog,
            fogExp: s && s.isFogExp2,
            flatShading: t.flatShading,
            sizeAttenuation: t.sizeAttenuation,
            logarithmicDepthBuffer: r.logarithmicDepthBuffer,
            skinning: t.skinning && d > 0,
            maxBones: d,
            useVertexTexture: r.floatVertexTextures,
            morphTargets: t.morphTargets,
            morphNormals: t.morphNormals,
            maxMorphTargets: e.maxMorphTargets,
            maxMorphNormals: e.maxMorphNormals,
            numDirLights: n.directional.length,
            numPointLights: n.point.length,
            numSpotLights: n.spot.length,
            numRectAreaLights: n.rectArea.length,
            numHemiLights: n.hemi.length,
            numClippingPlanes: c,
            numClipIntersection: u,
            dithering: t.dithering,
            shadowMapEnabled: e.shadowMap.enabled && l.receiveShadow && a.length > 0,
            shadowMapType: e.shadowMap.type,
            toneMapping: e.toneMapping,
            physicallyCorrectLights: e.physicallyCorrectLights,
            premultipliedAlpha: t.premultipliedAlpha,
            alphaTest: t.alphaTest,
            doubleSided: t.side === R,
            flipSided: t.side === L,
            depthPacking: void 0 !== t.depthPacking && t.depthPacking,
          };
        }),
          (this.getProgramCode = function (t, r) {
            var n = [];
            if (
              (r.shaderID ? n.push(r.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)),
              void 0 !== t.defines)
            )
              for (var i in t.defines) n.push(i), n.push(t.defines[i]);
            for (var o = 0; o < a.length; o++) n.push(r[a[o]]);
            return (
              n.push(t.onBeforeCompile.toString()),
              n.push(e.gammaOutput),
              n.push(e.gammaFactor),
              n.join()
            );
          }),
          (this.acquireProgram = function (i, a, o, s) {
            for (var c, u = 0, l = n.length; u < l; u++) {
              var h = n[u];
              if (h.code === s) {
                ++(c = h).usedTimes;
                break;
              }
            }
            return void 0 === c && ((c = new ji(e, t, s, i, a, o, r)), n.push(c)), c;
          }),
          (this.releaseProgram = function (e) {
            if (0 == --e.usedTimes) {
              var t = n.indexOf(e);
              (n[t] = n[n.length - 1]), n.pop(), e.destroy();
            }
          }),
          (this.programs = n);
      }
      function qi() {
        var e = new WeakMap();
        return {
          get: function (t) {
            var r = e.get(t);
            return void 0 === r && ((r = {}), e.set(t, r)), r;
          },
          remove: function (t) {
            e.delete(t);
          },
          update: function (t, r, n) {
            e.get(t)[r] = n;
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function Xi(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.program && t.program && e.program !== t.program
          ? e.program.id - t.program.id
          : e.material.id !== t.material.id
          ? e.material.id - t.material.id
          : e.z !== t.z
          ? e.z - t.z
          : e.id - t.id;
      }
      function Yi(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.z !== t.z
          ? t.z - e.z
          : e.id - t.id;
      }
      function Ji() {
        var e = [],
          t = 0,
          r = [],
          n = [];
        function i(r, n, i, a, o, s) {
          var c = e[t];
          return (
            void 0 === c
              ? ((c = {
                  id: r.id,
                  object: r,
                  geometry: n,
                  material: i,
                  program: i.program,
                  groupOrder: a,
                  renderOrder: r.renderOrder,
                  z: o,
                  group: s,
                }),
                (e[t] = c))
              : ((c.id = r.id),
                (c.object = r),
                (c.geometry = n),
                (c.material = i),
                (c.program = i.program),
                (c.groupOrder = a),
                (c.renderOrder = r.renderOrder),
                (c.z = o),
                (c.group = s)),
            t++,
            c
          );
        }
        return {
          opaque: r,
          transparent: n,
          init: function () {
            (t = 0), (r.length = 0), (n.length = 0);
          },
          push: function (e, t, a, o, s, c) {
            var u = i(e, t, a, o, s, c);
            (!0 === a.transparent ? n : r).push(u);
          },
          unshift: function (e, t, a, o, s, c) {
            var u = i(e, t, a, o, s, c);
            (!0 === a.transparent ? n : r).unshift(u);
          },
          sort: function () {
            r.length > 1 && r.sort(Xi), n.length > 1 && n.sort(Yi);
          },
        };
      }
      function Zi() {
        var e = {};
        function t(r) {
          var n = r.target;
          n.removeEventListener('dispose', t), delete e[n.id];
        }
        return {
          get: function (r, n) {
            var i,
              a = e[r.id];
            return (
              void 0 === a
                ? ((i = new Ji()),
                  (e[r.id] = {}),
                  (e[r.id][n.id] = i),
                  r.addEventListener('dispose', t))
                : void 0 === (i = a[n.id]) && ((i = new Ji()), (a[n.id] = i)),
              i
            );
          },
          dispose: function () {
            e = {};
          },
        };
      }
      function Ki() {
        var e = {};
        return {
          get: function (t) {
            if (void 0 !== e[t.id]) return e[t.id];
            var r;
            switch (t.type) {
              case 'DirectionalLight':
                r = {
                  direction: new tr(),
                  color: new Lr(),
                  shadow: !1,
                  shadowBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Qt(),
                };
                break;
              case 'SpotLight':
                r = {
                  position: new tr(),
                  direction: new tr(),
                  color: new Lr(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                  shadow: !1,
                  shadowBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Qt(),
                };
                break;
              case 'PointLight':
                r = {
                  position: new tr(),
                  color: new Lr(),
                  distance: 0,
                  decay: 0,
                  shadow: !1,
                  shadowBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Qt(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
                break;
              case 'HemisphereLight':
                r = { direction: new tr(), skyColor: new Lr(), groundColor: new Lr() };
                break;
              case 'RectAreaLight':
                r = {
                  color: new Lr(),
                  position: new tr(),
                  halfWidth: new tr(),
                  halfHeight: new tr(),
                };
            }
            return (e[t.id] = r), r;
          },
        };
      }
      var Qi = 0;
      function $i() {
        var e = new Ki(),
          t = {
            id: Qi++,
            hash: {
              stateID: -1,
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              shadowsLength: -1,
            },
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          },
          r = new tr(),
          n = new $t(),
          i = new $t();
        return {
          setup: function (a, o, s) {
            for (
              var c = 0,
                u = 0,
                l = 0,
                h = 0,
                d = 0,
                p = 0,
                f = 0,
                m = 0,
                v = s.matrixWorldInverse,
                g = 0,
                y = a.length;
              g < y;
              g++
            ) {
              var x = a[g],
                b = x.color,
                w = x.intensity,
                _ = x.distance,
                M = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
              if (x.isAmbientLight) (c += b.r * w), (u += b.g * w), (l += b.b * w);
              else if (x.isDirectionalLight) {
                if (
                  ((E = e.get(x)).color.copy(x.color).multiplyScalar(x.intensity),
                  E.direction.setFromMatrixPosition(x.matrixWorld),
                  r.setFromMatrixPosition(x.target.matrixWorld),
                  E.direction.sub(r),
                  E.direction.transformDirection(v),
                  (E.shadow = x.castShadow),
                  x.castShadow)
                ) {
                  var S = x.shadow;
                  (E.shadowBias = S.bias),
                    (E.shadowRadius = S.radius),
                    (E.shadowMapSize = S.mapSize);
                }
                (t.directionalShadowMap[h] = M),
                  (t.directionalShadowMatrix[h] = x.shadow.matrix),
                  (t.directional[h] = E),
                  h++;
              } else if (x.isSpotLight)
                (E = e.get(x)).position.setFromMatrixPosition(x.matrixWorld),
                  E.position.applyMatrix4(v),
                  E.color.copy(b).multiplyScalar(w),
                  (E.distance = _),
                  E.direction.setFromMatrixPosition(x.matrixWorld),
                  r.setFromMatrixPosition(x.target.matrixWorld),
                  E.direction.sub(r),
                  E.direction.transformDirection(v),
                  (E.coneCos = Math.cos(x.angle)),
                  (E.penumbraCos = Math.cos(x.angle * (1 - x.penumbra))),
                  (E.decay = x.decay),
                  (E.shadow = x.castShadow),
                  x.castShadow &&
                    ((S = x.shadow),
                    (E.shadowBias = S.bias),
                    (E.shadowRadius = S.radius),
                    (E.shadowMapSize = S.mapSize)),
                  (t.spotShadowMap[p] = M),
                  (t.spotShadowMatrix[p] = x.shadow.matrix),
                  (t.spot[p] = E),
                  p++;
              else if (x.isRectAreaLight)
                (E = e.get(x)).color.copy(b).multiplyScalar(w),
                  E.position.setFromMatrixPosition(x.matrixWorld),
                  E.position.applyMatrix4(v),
                  i.identity(),
                  n.copy(x.matrixWorld),
                  n.premultiply(v),
                  i.extractRotation(n),
                  E.halfWidth.set(0.5 * x.width, 0, 0),
                  E.halfHeight.set(0, 0.5 * x.height, 0),
                  E.halfWidth.applyMatrix4(i),
                  E.halfHeight.applyMatrix4(i),
                  (t.rectArea[f] = E),
                  f++;
              else if (x.isPointLight)
                (E = e.get(x)).position.setFromMatrixPosition(x.matrixWorld),
                  E.position.applyMatrix4(v),
                  E.color.copy(x.color).multiplyScalar(x.intensity),
                  (E.distance = x.distance),
                  (E.decay = x.decay),
                  (E.shadow = x.castShadow),
                  x.castShadow &&
                    ((S = x.shadow),
                    (E.shadowBias = S.bias),
                    (E.shadowRadius = S.radius),
                    (E.shadowMapSize = S.mapSize),
                    (E.shadowCameraNear = S.camera.near),
                    (E.shadowCameraFar = S.camera.far)),
                  (t.pointShadowMap[d] = M),
                  (t.pointShadowMatrix[d] = x.shadow.matrix),
                  (t.point[d] = E),
                  d++;
              else if (x.isHemisphereLight) {
                var E;
                (E = e.get(x)).direction.setFromMatrixPosition(x.matrixWorld),
                  E.direction.transformDirection(v),
                  E.direction.normalize(),
                  E.skyColor.copy(x.color).multiplyScalar(w),
                  E.groundColor.copy(x.groundColor).multiplyScalar(w),
                  (t.hemi[m] = E),
                  m++;
              }
            }
            (t.ambient[0] = c),
              (t.ambient[1] = u),
              (t.ambient[2] = l),
              (t.directional.length = h),
              (t.spot.length = p),
              (t.rectArea.length = f),
              (t.point.length = d),
              (t.hemi.length = m),
              (t.hash.stateID = t.id),
              (t.hash.directionalLength = h),
              (t.hash.pointLength = d),
              (t.hash.spotLength = p),
              (t.hash.rectAreaLength = f),
              (t.hash.hemiLength = m),
              (t.hash.shadowsLength = o.length);
          },
          state: t,
        };
      }
      function ea() {
        var e = new $i(),
          t = [],
          r = [];
        return {
          init: function () {
            (t.length = 0), (r.length = 0);
          },
          state: { lightsArray: t, shadowsArray: r, lights: e },
          setupLights: function (n) {
            e.setup(t, r, n);
          },
          pushLight: function (e) {
            t.push(e);
          },
          pushShadow: function (e) {
            r.push(e);
          },
        };
      }
      function ta() {
        var e = {};
        function t(r) {
          var n = r.target;
          n.removeEventListener('dispose', t), delete e[n.id];
        }
        return {
          get: function (r, n) {
            var i;
            return (
              void 0 === e[r.id]
                ? ((i = new ea()),
                  (e[r.id] = {}),
                  (e[r.id][n.id] = i),
                  r.addEventListener('dispose', t))
                : void 0 === e[r.id][n.id]
                ? ((i = new ea()), (e[r.id][n.id] = i))
                : (i = e[r.id][n.id]),
              i
            );
          },
          dispose: function () {
            e = {};
          },
        };
      }
      function ra(e) {
        En.call(this),
          (this.type = 'MeshDepthMaterial'),
          (this.depthPacking = Xt),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          this.setValues(e);
      }
      function na(e) {
        En.call(this),
          (this.type = 'MeshDistanceMaterial'),
          (this.referencePosition = new tr()),
          (this.nearDistance = 1),
          (this.farDistance = 1e3),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.fog = !1),
          (this.lights = !1),
          this.setValues(e);
      }
      function ia(e, t, r) {
        for (
          var n = new xr(),
            i = new $t(),
            a = new Qt(),
            o = new Qt(r, r),
            s = new tr(),
            c = new tr(),
            u = 1,
            l = 2,
            h = 1 + (u | l),
            d = new Array(h),
            p = new Array(h),
            f = {},
            m = { 0: L, 1: A, 2: R },
            v = [
              new tr(1, 0, 0),
              new tr(-1, 0, 0),
              new tr(0, 0, 1),
              new tr(0, 0, -1),
              new tr(0, 1, 0),
              new tr(0, -1, 0),
            ],
            g = [
              new tr(0, 1, 0),
              new tr(0, 1, 0),
              new tr(0, 1, 0),
              new tr(0, 1, 0),
              new tr(0, 0, 1),
              new tr(0, 0, -1),
            ],
            y = [new hr(), new hr(), new hr(), new hr(), new hr(), new hr()],
            x = 0;
          x !== h;
          ++x
        ) {
          var b = 0 != (x & u),
            w = 0 != (x & l),
            _ = new ra({ depthPacking: Yt, morphTargets: b, skinning: w });
          d[x] = _;
          var M = new na({ morphTargets: b, skinning: w });
          p[x] = M;
        }
        var S = this;
        function T(t, r, n, i, a, o) {
          var s = t.geometry,
            c = null,
            h = d,
            v = t.customDepthMaterial;
          if ((n && ((h = p), (v = t.customDistanceMaterial)), v)) c = v;
          else {
            var g = !1;
            r.morphTargets &&
              (s && s.isBufferGeometry
                ? (g =
                    s.morphAttributes &&
                    s.morphAttributes.position &&
                    s.morphAttributes.position.length > 0)
                : s && s.isGeometry && (g = s.morphTargets && s.morphTargets.length > 0)),
              t.isSkinnedMesh &&
                !1 === r.skinning &&
                console.warn(
                  'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',
                  t,
                );
            var y = t.isSkinnedMesh && r.skinning,
              x = 0;
            g && (x |= u), y && (x |= l), (c = h[x]);
          }
          if (e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) {
            var b = c.uuid,
              w = r.uuid,
              _ = f[b];
            void 0 === _ && ((_ = {}), (f[b] = _));
            var M = _[w];
            void 0 === M && ((M = c.clone()), (_[w] = M)), (c = M);
          }
          return (
            (c.visible = r.visible),
            (c.wireframe = r.wireframe),
            (c.side = null != r.shadowSide ? r.shadowSide : m[r.side]),
            (c.clipShadows = r.clipShadows),
            (c.clippingPlanes = r.clippingPlanes),
            (c.clipIntersection = r.clipIntersection),
            (c.wireframeLinewidth = r.wireframeLinewidth),
            (c.linewidth = r.linewidth),
            n &&
              c.isMeshDistanceMaterial &&
              (c.referencePosition.copy(i), (c.nearDistance = a), (c.farDistance = o)),
            c
          );
        }
        function C(r, i, a, o) {
          if (!1 !== r.visible) {
            if (
              r.layers.test(i.layers) &&
              (r.isMesh || r.isLine || r.isPoints) &&
              r.castShadow &&
              (!r.frustumCulled || n.intersectsObject(r))
            ) {
              r.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, r.matrixWorld);
              var s = t.update(r),
                u = r.material;
              if (Array.isArray(u))
                for (var l = s.groups, h = 0, d = l.length; h < d; h++) {
                  var p = l[h],
                    f = u[p.materialIndex];
                  if (f && f.visible) {
                    var m = T(r, f, o, c, a.near, a.far);
                    e.renderBufferDirect(a, null, s, m, r, p);
                  }
                }
              else if (u.visible) {
                m = T(r, u, o, c, a.near, a.far);
                e.renderBufferDirect(a, null, s, m, r, null);
              }
            }
            for (var v = r.children, g = 0, y = v.length; g < y; g++) C(v[g], i, a, o);
          }
        }
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = E),
          (this.render = function (t, r, u) {
            if (
              !1 !== S.enabled &&
              (!1 !== S.autoUpdate || !1 !== S.needsUpdate) &&
              0 !== t.length
            ) {
              var l,
                h = e.state;
              h.setBlending(B),
                h.buffers.color.setClear(1, 1, 1, 1),
                h.buffers.depth.setTest(!0),
                h.setScissorTest(!1);
              for (var d = 0, p = t.length; d < p; d++) {
                var f = t[d],
                  m = f.shadow,
                  x = f && f.isPointLight;
                if (void 0 !== m) {
                  var b = m.camera;
                  if ((a.copy(m.mapSize), a.min(o), x)) {
                    var w = a.x,
                      _ = a.y;
                    y[0].set(2 * w, _, w, _),
                      y[1].set(0, _, w, _),
                      y[2].set(3 * w, _, w, _),
                      y[3].set(w, _, w, _),
                      y[4].set(3 * w, 0, w, _),
                      y[5].set(w, 0, w, _),
                      (a.x *= 4),
                      (a.y *= 2);
                  }
                  if (null === m.map) {
                    var M = { minFilter: Pe, magFilter: Pe, format: Ke };
                    (m.map = new dr(a.x, a.y, M)),
                      (m.map.texture.name = f.name + '.shadowMap'),
                      b.updateProjectionMatrix();
                  }
                  m.isSpotLightShadow && m.update(f);
                  var E = m.map,
                    T = m.matrix;
                  c.setFromMatrixPosition(f.matrixWorld),
                    b.position.copy(c),
                    x
                      ? ((l = 6), T.makeTranslation(-c.x, -c.y, -c.z))
                      : ((l = 1),
                        s.setFromMatrixPosition(f.target.matrixWorld),
                        b.lookAt(s),
                        b.updateMatrixWorld(),
                        T.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
                        T.multiply(b.projectionMatrix),
                        T.multiply(b.matrixWorldInverse)),
                    e.setRenderTarget(E),
                    e.clear();
                  for (var A = 0; A < l; A++) {
                    if (x) {
                      s.copy(b.position),
                        s.add(v[A]),
                        b.up.copy(g[A]),
                        b.lookAt(s),
                        b.updateMatrixWorld();
                      var L = y[A];
                      h.viewport(L);
                    }
                    i.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse),
                      n.setFromMatrix(i),
                      C(r, u, b, x);
                  }
                } else console.warn('THREE.WebGLShadowMap:', f, 'has no shadow.');
              }
              S.needsUpdate = !1;
            }
          });
      }
      function aa(e, t, r, n) {
        var i = new (function () {
            var t = !1,
              r = new hr(),
              n = null,
              i = new hr(0, 0, 0, 0);
            return {
              setMask: function (r) {
                n === r || t || (e.colorMask(r, r, r, r), (n = r));
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t, n, a, o, s) {
                !0 === s && ((t *= o), (n *= o), (a *= o)),
                  r.set(t, n, a, o),
                  !1 === i.equals(r) && (e.clearColor(t, n, a, o), i.copy(r));
              },
              reset: function () {
                (t = !1), (n = null), i.set(-1, 0, 0, 0);
              },
            };
          })(),
          a = new (function () {
            var t = !1,
              r = null,
              n = null,
              i = null;
            return {
              setTest: function (e) {
                e ? K(2929) : Q(2929);
              },
              setMask: function (n) {
                r === n || t || (e.depthMask(n), (r = n));
              },
              setFunc: function (t) {
                if (n !== t) {
                  if (t)
                    switch (t) {
                      case ne:
                        e.depthFunc(512);
                        break;
                      case ie:
                        e.depthFunc(519);
                        break;
                      case ae:
                        e.depthFunc(513);
                        break;
                      case oe:
                        e.depthFunc(515);
                        break;
                      case se:
                        e.depthFunc(514);
                        break;
                      case ce:
                        e.depthFunc(518);
                        break;
                      case ue:
                        e.depthFunc(516);
                        break;
                      case le:
                        e.depthFunc(517);
                        break;
                      default:
                        e.depthFunc(515);
                    }
                  else e.depthFunc(515);
                  n = t;
                }
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t) {
                i !== t && (e.clearDepth(t), (i = t));
              },
              reset: function () {
                (t = !1), (r = null), (n = null), (i = null);
              },
            };
          })(),
          o = new (function () {
            var t = !1,
              r = null,
              n = null,
              i = null,
              a = null,
              o = null,
              s = null,
              c = null,
              u = null;
            return {
              setTest: function (e) {
                e ? K(2960) : Q(2960);
              },
              setMask: function (n) {
                r === n || t || (e.stencilMask(n), (r = n));
              },
              setFunc: function (t, r, o) {
                (n === t && i === r && a === o) ||
                  (e.stencilFunc(t, r, o), (n = t), (i = r), (a = o));
              },
              setOp: function (t, r, n) {
                (o === t && s === r && c === n) ||
                  (e.stencilOp(t, r, n), (o = t), (s = r), (c = n));
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t) {
                u !== t && (e.clearStencil(t), (u = t));
              },
              reset: function () {
                (t = !1),
                  (r = null),
                  (n = null),
                  (i = null),
                  (a = null),
                  (o = null),
                  (s = null),
                  (c = null),
                  (u = null);
              },
            };
          })(),
          s = e.getParameter(34921),
          c = new Uint8Array(s),
          u = new Uint8Array(s),
          l = new Uint8Array(s),
          h = {},
          d = null,
          p = null,
          f = null,
          m = null,
          v = null,
          g = null,
          w = null,
          _ = null,
          M = null,
          S = null,
          E = !1,
          T = null,
          A = null,
          C = null,
          P = null,
          O = null,
          I = e.getParameter(35661),
          D = !1,
          k = 0,
          V = e.getParameter(7938);
        -1 !== V.indexOf('WebGL')
          ? ((k = parseFloat(/^WebGL\ ([0-9])/.exec(V)[1])), (D = k >= 1))
          : -1 !== V.indexOf('OpenGL ES') &&
            ((k = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(V)[1])), (D = k >= 2));
        var j = null,
          W = {},
          q = new hr(),
          X = new hr();
        function Y(t, r, n) {
          var i = new Uint8Array(4),
            a = e.createTexture();
          e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
          for (var o = 0; o < n; o++) e.texImage2D(r + o, 0, 6408, 1, 1, 0, 6408, 5121, i);
          return a;
        }
        var J = {};
        function Z(r, i) {
          ((c[r] = 1), 0 === u[r] && (e.enableVertexAttribArray(r), (u[r] = 1)), l[r] !== i) &&
            ((n.isWebGL2 ? e : t.get('ANGLE_instanced_arrays'))[
              n.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
            ](r, i),
            (l[r] = i));
        }
        function K(t) {
          !0 !== h[t] && (e.enable(t), (h[t] = !0));
        }
        function Q(t) {
          !1 !== h[t] && (e.disable(t), (h[t] = !1));
        }
        function $(t, n, i, a, o, s, c, u) {
          if (t !== B) {
            if ((f || (K(3042), (f = !0)), t === z))
              (o = o || n),
                (s = s || i),
                (c = c || a),
                (n === v && o === _) ||
                  (e.blendEquationSeparate(r.convert(n), r.convert(o)), (v = n), (_ = o)),
                (i === g && a === w && s === M && c === S) ||
                  (e.blendFuncSeparate(r.convert(i), r.convert(a), r.convert(s), r.convert(c)),
                  (g = i),
                  (w = a),
                  (M = s),
                  (S = c)),
                (m = t),
                (E = null);
            else if (t !== m || u !== E) {
              if (((v === H && _ === H) || (e.blendEquation(32774), (v = H), (_ = H)), u))
                switch (t) {
                  case N:
                    e.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case U:
                    e.blendFunc(1, 1);
                    break;
                  case G:
                    e.blendFuncSeparate(0, 0, 769, 771);
                    break;
                  case F:
                    e.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error('THREE.WebGLState: Invalid blending: ', t);
                }
              else
                switch (t) {
                  case N:
                    e.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case U:
                    e.blendFunc(770, 1);
                    break;
                  case G:
                    e.blendFunc(0, 769);
                    break;
                  case F:
                    e.blendFunc(0, 768);
                    break;
                  default:
                    console.error('THREE.WebGLState: Invalid blending: ', t);
                }
              (g = null), (w = null), (M = null), (S = null), (m = t), (E = u);
            }
          } else f && (Q(3042), (f = !1));
        }
        function ee(t) {
          T !== t && (t ? e.frontFace(2304) : e.frontFace(2305), (T = t));
        }
        function te(t) {
          t !== y
            ? (K(2884),
              t !== A &&
                (t === x ? e.cullFace(1029) : t === b ? e.cullFace(1028) : e.cullFace(1032)))
            : Q(2884),
            (A = t);
        }
        function re(t, r, n) {
          t
            ? (K(32823), (P === r && O === n) || (e.polygonOffset(r, n), (P = r), (O = n)))
            : Q(32823);
        }
        function he(t) {
          void 0 === t && (t = 33984 + I - 1), j !== t && (e.activeTexture(t), (j = t));
        }
        return (
          (J[3553] = Y(3553, 3553, 1)),
          (J[34067] = Y(34067, 34069, 6)),
          i.setClear(0, 0, 0, 1),
          a.setClear(1),
          o.setClear(0),
          K(2929),
          a.setFunc(oe),
          ee(!1),
          te(x),
          K(2884),
          $(B),
          {
            buffers: { color: i, depth: a, stencil: o },
            initAttributes: function () {
              for (var e = 0, t = c.length; e < t; e++) c[e] = 0;
            },
            enableAttribute: function (e) {
              Z(e, 0);
            },
            enableAttributeAndDivisor: Z,
            disableUnusedAttributes: function () {
              for (var t = 0, r = u.length; t !== r; ++t)
                u[t] !== c[t] && (e.disableVertexAttribArray(t), (u[t] = 0));
            },
            enable: K,
            disable: Q,
            getCompressedTextureFormats: function () {
              if (
                null === d &&
                ((d = []),
                t.get('WEBGL_compressed_texture_pvrtc') ||
                  t.get('WEBGL_compressed_texture_s3tc') ||
                  t.get('WEBGL_compressed_texture_etc1') ||
                  t.get('WEBGL_compressed_texture_astc'))
              )
                for (var r = e.getParameter(34467), n = 0; n < r.length; n++) d.push(r[n]);
              return d;
            },
            useProgram: function (t) {
              return p !== t && (e.useProgram(t), (p = t), !0);
            },
            setBlending: $,
            setMaterial: function (e, t) {
              e.side === R ? Q(2884) : K(2884);
              var r = e.side === L;
              t && (r = !r),
                ee(r),
                e.blending === N && !1 === e.transparent
                  ? $(B)
                  : $(
                      e.blending,
                      e.blendEquation,
                      e.blendSrc,
                      e.blendDst,
                      e.blendEquationAlpha,
                      e.blendSrcAlpha,
                      e.blendDstAlpha,
                      e.premultipliedAlpha,
                    ),
                a.setFunc(e.depthFunc),
                a.setTest(e.depthTest),
                a.setMask(e.depthWrite),
                i.setMask(e.colorWrite),
                re(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits);
            },
            setFlipSided: ee,
            setCullFace: te,
            setLineWidth: function (t) {
              t !== C && (D && e.lineWidth(t), (C = t));
            },
            setPolygonOffset: re,
            setScissorTest: function (e) {
              e ? K(3089) : Q(3089);
            },
            activeTexture: he,
            bindTexture: function (t, r) {
              null === j && he();
              var n = W[j];
              void 0 === n && ((n = { type: void 0, texture: void 0 }), (W[j] = n)),
                (n.type === t && n.texture === r) ||
                  (e.bindTexture(t, r || J[t]), (n.type = t), (n.texture = r));
            },
            compressedTexImage2D: function () {
              try {
                e.compressedTexImage2D.apply(e, arguments);
              } catch (e) {
                console.error('THREE.WebGLState:', e);
              }
            },
            texImage2D: function () {
              try {
                e.texImage2D.apply(e, arguments);
              } catch (e) {
                console.error('THREE.WebGLState:', e);
              }
            },
            texImage3D: function () {
              try {
                e.texImage3D.apply(e, arguments);
              } catch (e) {
                console.error('THREE.WebGLState:', e);
              }
            },
            scissor: function (t) {
              !1 === q.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), q.copy(t));
            },
            viewport: function (t) {
              !1 === X.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), X.copy(t));
            },
            reset: function () {
              for (var t = 0; t < u.length; t++)
                1 === u[t] && (e.disableVertexAttribArray(t), (u[t] = 0));
              (h = {}),
                (d = null),
                (j = null),
                (W = {}),
                (p = null),
                (m = null),
                (T = null),
                (A = null),
                i.reset(),
                a.reset(),
                o.reset();
            },
          }
        );
      }
      function oa(e, t, r, n, i, a, o) {
        var s,
          c = {};
        function u(e, t, r, n) {
          var i = 1;
          if (
            ((e.width > n || e.height > n) && (i = n / Math.max(e.width, e.height)),
            i < 1 || !0 === t)
          ) {
            if (
              e instanceof HTMLImageElement ||
              e instanceof HTMLCanvasElement ||
              e instanceof ImageBitmap
            ) {
              void 0 === s &&
                (s = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'));
              var a = r ? document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas') : s,
                o = t ? Kt.floorPowerOfTwo : Math.floor;
              return (
                (a.width = o(i * e.width)),
                (a.height = o(i * e.height)),
                a.getContext('2d').drawImage(e, 0, 0, a.width, a.height),
                console.warn(
                  'THREE.WebGLRenderer: Texture has been resized from (' +
                    e.width +
                    'x' +
                    e.height +
                    ') to (' +
                    a.width +
                    'x' +
                    a.height +
                    ').',
                ),
                a
              );
            }
            return (
              'data' in e &&
                console.warn(
                  'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                    e.width +
                    'x' +
                    e.height +
                    ').',
                ),
              e
            );
          }
          return e;
        }
        function l(e) {
          return Kt.isPowerOfTwo(e.width) && Kt.isPowerOfTwo(e.height);
        }
        function h(e, t) {
          return e.generateMipmaps && t && e.minFilter !== Pe && e.minFilter !== De;
        }
        function d(t, r, i, a) {
          e.generateMipmap(t), (n.get(r).__maxMipLevel = Math.log(Math.max(i, a)) * Math.LOG2E);
        }
        function p(e, r) {
          if (!i.isWebGL2) return e;
          var n = e;
          return (
            6403 === e &&
              (5126 === r && (n = 33326), 5131 === r && (n = 33325), 5121 === r && (n = 33321)),
            6407 === e &&
              (5126 === r && (n = 34837), 5131 === r && (n = 34843), 5121 === r && (n = 32849)),
            6408 === e &&
              (5126 === r && (n = 34836), 5131 === r && (n = 34842), 5121 === r && (n = 32856)),
            33325 === n || 33326 === n || 34842 === n || 34836 === n
              ? t.get('EXT_color_buffer_float')
              : (34843 !== n && 34837 !== n) ||
                console.warn(
                  'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.',
                ),
            n
          );
        }
        function f(e) {
          return e === Pe || e === Oe || e === Ie ? 9728 : 9729;
        }
        function m(t) {
          var r = t.target;
          r.removeEventListener('dispose', m),
            (function (t) {
              var r = n.get(t);
              if (t.image && r.__image__webglTextureCube)
                e.deleteTexture(r.__image__webglTextureCube);
              else {
                if (void 0 === r.__webglInit) return;
                e.deleteTexture(r.__webglTexture);
              }
              n.remove(t);
            })(r),
            r.isVideoTexture && delete c[r.id],
            o.memory.textures--;
        }
        function v(t) {
          var r = t.target;
          r.removeEventListener('dispose', v),
            (function (t) {
              var r = n.get(t),
                i = n.get(t.texture);
              if (!t) return;
              void 0 !== i.__webglTexture && e.deleteTexture(i.__webglTexture);
              t.depthTexture && t.depthTexture.dispose();
              if (t.isWebGLRenderTargetCube)
                for (var a = 0; a < 6; a++)
                  e.deleteFramebuffer(r.__webglFramebuffer[a]),
                    r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[a]);
              else
                e.deleteFramebuffer(r.__webglFramebuffer),
                  r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer);
              n.remove(t.texture), n.remove(t);
            })(r),
            o.memory.textures--;
        }
        function g(e, t) {
          var i = n.get(e);
          if (
            (e.isVideoTexture &&
              (function (e) {
                var t = e.id,
                  r = o.render.frame;
                c[t] !== r && ((c[t] = r), e.update());
              })(e),
            e.version > 0 && i.__version !== e.version)
          ) {
            var a = e.image;
            if (void 0 === a)
              console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
            else {
              if (!1 !== a.complete) return void x(i, e, t);
              console.warn(
                'THREE.WebGLRenderer: Texture marked for update but image is incomplete',
              );
            }
          }
          r.activeTexture(33984 + t), r.bindTexture(3553, i.__webglTexture);
        }
        function y(r, o, s) {
          var c;
          if (
            (s
              ? (e.texParameteri(r, 10242, a.convert(o.wrapS)),
                e.texParameteri(r, 10243, a.convert(o.wrapT)),
                e.texParameteri(r, 10240, a.convert(o.magFilter)),
                e.texParameteri(r, 10241, a.convert(o.minFilter)))
              : (e.texParameteri(r, 10242, 33071),
                e.texParameteri(r, 10243, 33071),
                (o.wrapS === Re && o.wrapT === Re) ||
                  console.warn(
                    'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',
                  ),
                e.texParameteri(r, 10240, f(o.magFilter)),
                e.texParameteri(r, 10241, f(o.minFilter)),
                o.minFilter !== Pe &&
                  o.minFilter !== De &&
                  console.warn(
                    'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',
                  )),
            (c = t.get('EXT_texture_filter_anisotropic')))
          ) {
            if (o.type === Ve && null === t.get('OES_texture_float_linear')) return;
            if (o.type === je && null === (i.isWebGL2 || t.get('OES_texture_half_float_linear')))
              return;
            (o.anisotropy > 1 || n.get(o).__currentAnisotropy) &&
              (e.texParameterf(
                r,
                c.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(o.anisotropy, i.getMaxAnisotropy()),
              ),
              (n.get(o).__currentAnisotropy = o.anisotropy));
          }
        }
        function x(t, n, s) {
          var c;
          (c = n.isDataTexture3D ? 32879 : 3553),
            void 0 === t.__webglInit &&
              ((t.__webglInit = !0),
              n.addEventListener('dispose', m),
              (t.__webglTexture = e.createTexture()),
              o.memory.textures++),
            r.activeTexture(33984 + s),
            r.bindTexture(c, t.__webglTexture),
            e.pixelStorei(37440, n.flipY),
            e.pixelStorei(37441, n.premultiplyAlpha),
            e.pixelStorei(3317, n.unpackAlignment);
          var f =
              (function (e) {
                return (
                  !i.isWebGL2 &&
                  (e.wrapS !== Re || e.wrapT !== Re || (e.minFilter !== Pe && e.minFilter !== De))
                );
              })(n) && !1 === l(n.image),
            v = u(n.image, f, !1, i.maxTextureSize),
            g = l(v) || i.isWebGL2,
            x = a.convert(n.format),
            b = a.convert(n.type),
            w = p(x, b);
          y(c, n, g);
          var _,
            M = n.mipmaps;
          if (n.isDepthTexture) {
            if (((w = 6402), n.type === Ve)) {
              if (!i.isWebGL2) throw new Error('Float Depth Texture only supported in WebGL2.0');
              w = 36012;
            } else i.isWebGL2 && (w = 33189);
            n.format === tt &&
              6402 === w &&
              n.type !== ze &&
              n.type !== ke &&
              (console.warn(
                'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.',
              ),
              (n.type = ze),
              (b = a.convert(n.type))),
              n.format === rt &&
                ((w = 34041),
                n.type !== Ye &&
                  (console.warn(
                    'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.',
                  ),
                  (n.type = Ye),
                  (b = a.convert(n.type)))),
              r.texImage2D(3553, 0, w, v.width, v.height, 0, x, b, null);
          } else if (n.isDataTexture)
            if (M.length > 0 && g) {
              for (var S = 0, E = M.length; S < E; S++)
                (_ = M[S]), r.texImage2D(3553, S, w, _.width, _.height, 0, x, b, _.data);
              (n.generateMipmaps = !1), (t.__maxMipLevel = M.length - 1);
            } else
              r.texImage2D(3553, 0, w, v.width, v.height, 0, x, b, v.data), (t.__maxMipLevel = 0);
          else if (n.isCompressedTexture) {
            for (S = 0, E = M.length; S < E; S++)
              (_ = M[S]),
                n.format !== Ke && n.format !== Ze
                  ? r.getCompressedTextureFormats().indexOf(x) > -1
                    ? r.compressedTexImage2D(3553, S, w, _.width, _.height, 0, _.data)
                    : console.warn(
                        'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                      )
                  : r.texImage2D(3553, S, w, _.width, _.height, 0, x, b, _.data);
            t.__maxMipLevel = M.length - 1;
          } else if (n.isDataTexture3D)
            r.texImage3D(32879, 0, w, v.width, v.height, v.depth, 0, x, b, v.data),
              (t.__maxMipLevel = 0);
          else if (M.length > 0 && g) {
            for (S = 0, E = M.length; S < E; S++) (_ = M[S]), r.texImage2D(3553, S, w, x, b, _);
            (n.generateMipmaps = !1), (t.__maxMipLevel = M.length - 1);
          } else r.texImage2D(3553, 0, w, x, b, v), (t.__maxMipLevel = 0);
          h(n, g) && d(3553, n, v.width, v.height),
            (t.__version = n.version),
            n.onUpdate && n.onUpdate(n);
        }
        function b(t, i, o, s) {
          var c = a.convert(i.texture.format),
            u = a.convert(i.texture.type),
            l = p(c, u);
          r.texImage2D(s, 0, l, i.width, i.height, 0, c, u, null),
            e.bindFramebuffer(36160, t),
            e.framebufferTexture2D(36160, o, s, n.get(i.texture).__webglTexture, 0),
            e.bindFramebuffer(36160, null);
        }
        function w(t, r, n) {
          if ((e.bindRenderbuffer(36161, t), r.depthBuffer && !r.stencilBuffer)) {
            if (n) {
              var i = M(r);
              e.renderbufferStorageMultisample(36161, i, 33189, r.width, r.height);
            } else e.renderbufferStorage(36161, 33189, r.width, r.height);
            e.framebufferRenderbuffer(36160, 36096, 36161, t);
          } else if (r.depthBuffer && r.stencilBuffer) {
            if (n) {
              i = M(r);
              e.renderbufferStorageMultisample(36161, i, 34041, r.width, r.height);
            } else e.renderbufferStorage(36161, 34041, r.width, r.height);
            e.framebufferRenderbuffer(36160, 33306, 36161, t);
          } else {
            var o = p(a.convert(r.texture.format), a.convert(r.texture.type));
            if (n) {
              i = M(r);
              e.renderbufferStorageMultisample(36161, i, o, r.width, r.height);
            } else e.renderbufferStorage(36161, o, r.width, r.height);
          }
          e.bindRenderbuffer(36161, null);
        }
        function _(t) {
          var r = n.get(t),
            i = !0 === t.isWebGLRenderTargetCube;
          if (t.depthTexture) {
            if (i) throw new Error('target.depthTexture not supported in Cube render targets');
            !(function (t, r) {
              if (r && r.isWebGLRenderTargetCube)
                throw new Error('Depth Texture with cube render targets is not supported');
              if ((e.bindFramebuffer(36160, t), !r.depthTexture || !r.depthTexture.isDepthTexture))
                throw new Error(
                  'renderTarget.depthTexture must be an instance of THREE.DepthTexture',
                );
              (n.get(r.depthTexture).__webglTexture &&
                r.depthTexture.image.width === r.width &&
                r.depthTexture.image.height === r.height) ||
                ((r.depthTexture.image.width = r.width),
                (r.depthTexture.image.height = r.height),
                (r.depthTexture.needsUpdate = !0)),
                g(r.depthTexture, 0);
              var i = n.get(r.depthTexture).__webglTexture;
              if (r.depthTexture.format === tt) e.framebufferTexture2D(36160, 36096, 3553, i, 0);
              else {
                if (r.depthTexture.format !== rt) throw new Error('Unknown depthTexture format');
                e.framebufferTexture2D(36160, 33306, 3553, i, 0);
              }
            })(r.__webglFramebuffer, t);
          } else if (i) {
            r.__webglDepthbuffer = [];
            for (var a = 0; a < 6; a++)
              e.bindFramebuffer(36160, r.__webglFramebuffer[a]),
                (r.__webglDepthbuffer[a] = e.createRenderbuffer()),
                w(r.__webglDepthbuffer[a], t);
          } else
            e.bindFramebuffer(36160, r.__webglFramebuffer),
              (r.__webglDepthbuffer = e.createRenderbuffer()),
              w(r.__webglDepthbuffer, t);
          e.bindFramebuffer(36160, null);
        }
        function M(e) {
          return i.isWebGL2 && e.isWebGLMultisampleRenderTarget
            ? Math.min(i.maxSamples, e.samples)
            : 0;
        }
        (this.setTexture2D = g),
          (this.setTexture3D = function (e, t) {
            var i = n.get(e);
            e.version > 0 && i.__version !== e.version
              ? x(i, e, t)
              : (r.activeTexture(33984 + t), r.bindTexture(32879, i.__webglTexture));
          }),
          (this.setTextureCube = function (t, s) {
            var c = n.get(t);
            if (6 === t.image.length)
              if (t.version > 0 && c.__version !== t.version) {
                c.__image__webglTextureCube ||
                  (t.addEventListener('dispose', m),
                  (c.__image__webglTextureCube = e.createTexture()),
                  o.memory.textures++),
                  r.activeTexture(33984 + s),
                  r.bindTexture(34067, c.__image__webglTextureCube),
                  e.pixelStorei(37440, t.flipY);
                for (
                  var f = t && t.isCompressedTexture,
                    v = t.image[0] && t.image[0].isDataTexture,
                    g = [],
                    x = 0;
                  x < 6;
                  x++
                )
                  g[x] =
                    f || v
                      ? v
                        ? t.image[x].image
                        : t.image[x]
                      : u(t.image[x], !1, !0, i.maxCubemapSize);
                var b = g[0],
                  w = l(b) || i.isWebGL2,
                  _ = a.convert(t.format),
                  M = a.convert(t.type),
                  S = p(_, M);
                for (y(34067, t, w), x = 0; x < 6; x++)
                  if (f)
                    for (var E, T = g[x].mipmaps, A = 0, L = T.length; A < L; A++)
                      (E = T[A]),
                        t.format !== Ke && t.format !== Ze
                          ? r.getCompressedTextureFormats().indexOf(_) > -1
                            ? r.compressedTexImage2D(34069 + x, A, S, E.width, E.height, 0, E.data)
                            : console.warn(
                                'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',
                              )
                          : r.texImage2D(34069 + x, A, S, E.width, E.height, 0, _, M, E.data);
                  else
                    v
                      ? r.texImage2D(34069 + x, 0, S, g[x].width, g[x].height, 0, _, M, g[x].data)
                      : r.texImage2D(34069 + x, 0, S, _, M, g[x]);
                (c.__maxMipLevel = f ? T.length - 1 : 0),
                  h(t, w) && d(34067, t, b.width, b.height),
                  (c.__version = t.version),
                  t.onUpdate && t.onUpdate(t);
              } else r.activeTexture(33984 + s), r.bindTexture(34067, c.__image__webglTextureCube);
          }),
          (this.setTextureCubeDynamic = function (e, t) {
            r.activeTexture(33984 + t), r.bindTexture(34067, n.get(e).__webglTexture);
          }),
          (this.setupRenderTarget = function (t) {
            var s = n.get(t),
              c = n.get(t.texture);
            t.addEventListener('dispose', v),
              (c.__webglTexture = e.createTexture()),
              o.memory.textures++;
            var u = !0 === t.isWebGLRenderTargetCube,
              f = !0 === t.isWebGLMultisampleRenderTarget,
              m = l(t) || i.isWebGL2;
            if (u) {
              s.__webglFramebuffer = [];
              for (var g = 0; g < 6; g++) s.__webglFramebuffer[g] = e.createFramebuffer();
            } else if (((s.__webglFramebuffer = e.createFramebuffer()), f))
              if (i.isWebGL2) {
                (s.__webglMultisampledFramebuffer = e.createFramebuffer()),
                  (s.__webglColorRenderbuffer = e.createRenderbuffer()),
                  e.bindRenderbuffer(36161, s.__webglColorRenderbuffer);
                var x = p(a.convert(t.texture.format), a.convert(t.texture.type)),
                  S = M(t);
                e.renderbufferStorageMultisample(36161, S, x, t.width, t.height),
                  e.bindFramebuffer(36160, s.__webglMultisampledFramebuffer),
                  e.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer),
                  e.bindRenderbuffer(36161, null),
                  t.depthBuffer &&
                    ((s.__webglDepthRenderbuffer = e.createRenderbuffer()),
                    w(s.__webglDepthRenderbuffer, t, !0)),
                  e.bindFramebuffer(36160, null);
              } else
                console.warn(
                  'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
                );
            if (u) {
              for (
                r.bindTexture(34067, c.__webglTexture), y(34067, t.texture, m), g = 0;
                g < 6;
                g++
              )
                b(s.__webglFramebuffer[g], t, 36064, 34069 + g);
              h(t.texture, m) && d(34067, t.texture, t.width, t.height), r.bindTexture(34067, null);
            } else
              r.bindTexture(3553, c.__webglTexture),
                y(3553, t.texture, m),
                b(s.__webglFramebuffer, t, 36064, 3553),
                h(t.texture, m) && d(3553, t.texture, t.width, t.height),
                r.bindTexture(3553, null);
            t.depthBuffer && _(t);
          }),
          (this.updateRenderTargetMipmap = function (e) {
            var t = e.texture;
            if (h(t, l(e) || i.isWebGL2)) {
              var a = e.isWebGLRenderTargetCube ? 34067 : 3553,
                o = n.get(t).__webglTexture;
              r.bindTexture(a, o), d(a, t, e.width, e.height), r.bindTexture(a, null);
            }
          }),
          (this.updateMultisampleRenderTarget = function (t) {
            if (t.isWebGLMultisampleRenderTarget)
              if (i.isWebGL2) {
                var r = n.get(t);
                e.bindFramebuffer(36008, r.__webglMultisampledFramebuffer),
                  e.bindFramebuffer(36009, r.__webglFramebuffer);
                var a = t.width,
                  o = t.height,
                  s = 16384;
                t.depthBuffer && (s |= 256),
                  t.stencilBuffer && (s |= 1024),
                  e.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, 9728);
              } else
                console.warn(
                  'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
                );
          });
      }
      function sa(e, t, r) {
        return {
          convert: function (e) {
            var n;
            if (e === Le) return 10497;
            if (e === Re) return 33071;
            if (e === Ce) return 33648;
            if (e === Pe) return 9728;
            if (e === Oe) return 9984;
            if (e === Ie) return 9986;
            if (e === De) return 9729;
            if (e === Be) return 9985;
            if (e === Ne) return 9987;
            if (e === Ue) return 5121;
            if (e === We) return 32819;
            if (e === qe) return 32820;
            if (e === Xe) return 33635;
            if (e === Ge) return 5120;
            if (e === Fe) return 5122;
            if (e === ze) return 5123;
            if (e === He) return 5124;
            if (e === ke) return 5125;
            if (e === Ve) return 5126;
            if (e === je) {
              if (r.isWebGL2) return 5131;
              if (null !== (n = t.get('OES_texture_half_float'))) return n.HALF_FLOAT_OES;
            }
            if (e === Je) return 6406;
            if (e === Ze) return 6407;
            if (e === Ke) return 6408;
            if (e === Qe) return 6409;
            if (e === $e) return 6410;
            if (e === tt) return 6402;
            if (e === rt) return 34041;
            if (e === nt) return 6403;
            if (e === H) return 32774;
            if (e === k) return 32778;
            if (e === V) return 32779;
            if (e === q) return 0;
            if (e === X) return 1;
            if (e === Y) return 768;
            if (e === J) return 769;
            if (e === Z) return 770;
            if (e === K) return 771;
            if (e === Q) return 772;
            if (e === $) return 773;
            if (e === ee) return 774;
            if (e === te) return 775;
            if (e === re) return 776;
            if (
              (e === it || e === at || e === ot || e === st) &&
              null !== (n = t.get('WEBGL_compressed_texture_s3tc'))
            ) {
              if (e === it) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (e === at) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (e === ot) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (e === st) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
            if (
              (e === ct || e === ut || e === lt || e === ht) &&
              null !== (n = t.get('WEBGL_compressed_texture_pvrtc'))
            ) {
              if (e === ct) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (e === ut) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (e === lt) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (e === ht) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (e === dt && null !== (n = t.get('WEBGL_compressed_texture_etc1')))
              return n.COMPRESSED_RGB_ETC1_WEBGL;
            if (
              (e === pt ||
                e === ft ||
                e === mt ||
                e === vt ||
                e === gt ||
                e === yt ||
                e === xt ||
                e === bt ||
                e === wt ||
                e === _t ||
                e === Mt ||
                e === St ||
                e === Et ||
                e === Tt) &&
              null !== (n = t.get('WEBGL_compressed_texture_astc'))
            )
              return e;
            if (e === j || e === W) {
              if (r.isWebGL2) {
                if (e === j) return 32775;
                if (e === W) return 32776;
              }
              if (null !== (n = t.get('EXT_blend_minmax'))) {
                if (e === j) return n.MIN_EXT;
                if (e === W) return n.MAX_EXT;
              }
            }
            if (e === Ye) {
              if (r.isWebGL2) return 34042;
              if (null !== (n = t.get('WEBGL_depth_texture'))) return n.UNSIGNED_INT_24_8_WEBGL;
            }
            return 0;
          },
        };
      }
      function ca() {
        kr.call(this), (this.type = 'Group');
      }
      function ua() {
        kr.call(this),
          (this.type = 'Camera'),
          (this.matrixWorldInverse = new $t()),
          (this.projectionMatrix = new $t()),
          (this.projectionMatrixInverse = new $t());
      }
      function la(e, t, r, n) {
        ua.call(this),
          (this.type = 'PerspectiveCamera'),
          (this.fov = void 0 !== e ? e : 50),
          (this.zoom = 1),
          (this.near = void 0 !== r ? r : 0.1),
          (this.far = void 0 !== n ? n : 2e3),
          (this.focus = 10),
          (this.aspect = void 0 !== t ? t : 1),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      function ha(e) {
        la.call(this), (this.cameras = e || []);
      }
      (ra.prototype = Object.create(En.prototype)),
        (ra.prototype.constructor = ra),
        (ra.prototype.isMeshDepthMaterial = !0),
        (ra.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            (this.depthPacking = e.depthPacking),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }),
        (na.prototype = Object.create(En.prototype)),
        (na.prototype.constructor = na),
        (na.prototype.isMeshDistanceMaterial = !0),
        (na.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            this.referencePosition.copy(e.referencePosition),
            (this.nearDistance = e.nearDistance),
            (this.farDistance = e.farDistance),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }),
        (ca.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: ca,
          isGroup: !0,
        })),
        (ua.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: ua,
          isCamera: !0,
          copy: function (e, t) {
            return (
              kr.prototype.copy.call(this, e, t),
              this.matrixWorldInverse.copy(e.matrixWorldInverse),
              this.projectionMatrix.copy(e.projectionMatrix),
              this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
              this
            );
          },
          getWorldDirection: function (e) {
            void 0 === e &&
              (console.warn('THREE.Camera: .getWorldDirection() target is now required'),
              (e = new tr())),
              this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize();
          },
          updateMatrixWorld: function (e) {
            kr.prototype.updateMatrixWorld.call(this, e),
              this.matrixWorldInverse.getInverse(this.matrixWorld);
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
        })),
        (la.prototype = Object.assign(Object.create(ua.prototype), {
          constructor: la,
          isPerspectiveCamera: !0,
          copy: function (e, t) {
            return (
              ua.prototype.copy.call(this, e, t),
              (this.fov = e.fov),
              (this.zoom = e.zoom),
              (this.near = e.near),
              (this.far = e.far),
              (this.focus = e.focus),
              (this.aspect = e.aspect),
              (this.view = null === e.view ? null : Object.assign({}, e.view)),
              (this.filmGauge = e.filmGauge),
              (this.filmOffset = e.filmOffset),
              this
            );
          },
          setFocalLength: function (e) {
            var t = (0.5 * this.getFilmHeight()) / e;
            (this.fov = 2 * Kt.RAD2DEG * Math.atan(t)), this.updateProjectionMatrix();
          },
          getFocalLength: function () {
            var e = Math.tan(0.5 * Kt.DEG2RAD * this.fov);
            return (0.5 * this.getFilmHeight()) / e;
          },
          getEffectiveFOV: function () {
            return 2 * Kt.RAD2DEG * Math.atan(Math.tan(0.5 * Kt.DEG2RAD * this.fov) / this.zoom);
          },
          getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1);
          },
          getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1);
          },
          setViewOffset: function (e, t, r, n, i, a) {
            (this.aspect = e / t),
              null === this.view &&
                (this.view = {
                  enabled: !0,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1,
                }),
              (this.view.enabled = !0),
              (this.view.fullWidth = e),
              (this.view.fullHeight = t),
              (this.view.offsetX = r),
              (this.view.offsetY = n),
              (this.view.width = i),
              (this.view.height = a),
              this.updateProjectionMatrix();
          },
          clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
          },
          updateProjectionMatrix: function () {
            var e = this.near,
              t = (e * Math.tan(0.5 * Kt.DEG2RAD * this.fov)) / this.zoom,
              r = 2 * t,
              n = this.aspect * r,
              i = -0.5 * n,
              a = this.view;
            if (null !== this.view && this.view.enabled) {
              var o = a.fullWidth,
                s = a.fullHeight;
              (i += (a.offsetX * n) / o),
                (t -= (a.offsetY * r) / s),
                (n *= a.width / o),
                (r *= a.height / s);
            }
            var c = this.filmOffset;
            0 !== c && (i += (e * c) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(i, i + n, t, t - r, e, this.far),
              this.projectionMatrixInverse.getInverse(this.projectionMatrix);
          },
          toJSON: function (e) {
            var t = kr.prototype.toJSON.call(this, e);
            return (
              (t.object.fov = this.fov),
              (t.object.zoom = this.zoom),
              (t.object.near = this.near),
              (t.object.far = this.far),
              (t.object.focus = this.focus),
              (t.object.aspect = this.aspect),
              null !== this.view && (t.object.view = Object.assign({}, this.view)),
              (t.object.filmGauge = this.filmGauge),
              (t.object.filmOffset = this.filmOffset),
              t
            );
          },
        })),
        (ha.prototype = Object.assign(Object.create(la.prototype), {
          constructor: ha,
          isArrayCamera: !0,
        }));
      var da,
        pa,
        fa,
        ma,
        va,
        ga,
        ya = new tr(),
        xa = new tr();
      function ba(e, t, r) {
        ya.setFromMatrixPosition(t.matrixWorld), xa.setFromMatrixPosition(r.matrixWorld);
        var n = ya.distanceTo(xa),
          i = t.projectionMatrix.elements,
          a = r.projectionMatrix.elements,
          o = i[14] / (i[10] - 1),
          s = i[14] / (i[10] + 1),
          c = (i[9] + 1) / i[5],
          u = (i[9] - 1) / i[5],
          l = (i[8] - 1) / i[0],
          h = (a[8] + 1) / a[0],
          d = o * l,
          p = o * h,
          f = n / (-l + h),
          m = f * -l;
        t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
          e.translateX(m),
          e.translateZ(f),
          e.matrixWorld.compose(e.position, e.quaternion, e.scale),
          e.matrixWorldInverse.getInverse(e.matrixWorld);
        var v = o + f,
          g = s + f,
          y = d - m,
          x = p + (n - m),
          b = ((c * s) / g) * v,
          w = ((u * s) / g) * v;
        e.projectionMatrix.makePerspective(y, x, b, w, v, g);
      }
      function wa(e) {
        var t = this,
          r = null,
          n = null,
          i = null,
          a = [],
          o = new $t(),
          s = new $t(),
          c = 1,
          u = 'stage';
        'undefined' != typeof window &&
          'VRFrameData' in window &&
          ((n = new window.VRFrameData()),
          window.addEventListener('vrdisplaypresentchange', x, !1));
        var l = new $t(),
          h = new er(),
          d = new tr(),
          p = new la();
        (p.bounds = new hr(0, 0, 0.5, 1)), p.layers.enable(1);
        var f = new la();
        (f.bounds = new hr(0.5, 0, 0.5, 1)), f.layers.enable(2);
        var m,
          v,
          g = new ha([p, f]);
        function y() {
          return null !== r && !0 === r.isPresenting;
        }
        function x() {
          if (y()) {
            var n = r.getEyeParameters('left'),
              i = n.renderWidth * c,
              a = n.renderHeight * c;
            (v = e.getPixelRatio()),
              (m = e.getSize()),
              e.setDrawingBufferSize(2 * i, a, 1),
              _.start();
          } else t.enabled && e.setDrawingBufferSize(m.width, m.height, v), _.stop();
        }
        g.layers.enable(1), g.layers.enable(2);
        var b = [];
        function w(e) {
          for (
            var t = navigator.getGamepads && navigator.getGamepads(), r = 0, n = 0, i = t.length;
            r < i;
            r++
          ) {
            var a = t[r];
            if (
              a &&
              ('Daydream Controller' === a.id ||
                'Gear VR Controller' === a.id ||
                'Oculus Go Controller' === a.id ||
                'OpenVR Gamepad' === a.id ||
                a.id.startsWith('Oculus Touch') ||
                a.id.startsWith('Spatial Controller'))
            ) {
              if (n === e) return a;
              n++;
            }
          }
        }
        (this.enabled = !1),
          (this.getController = function (e) {
            var t = a[e];
            return (
              void 0 === t &&
                (((t = new ca()).matrixAutoUpdate = !1), (t.visible = !1), (a[e] = t)),
              t
            );
          }),
          (this.getDevice = function () {
            return r;
          }),
          (this.setDevice = function (e) {
            void 0 !== e && (r = e), _.setContext(e);
          }),
          (this.setFramebufferScaleFactor = function (e) {
            c = e;
          }),
          (this.setFrameOfReferenceType = function (e) {
            u = e;
          }),
          (this.setPoseTarget = function (e) {
            void 0 !== e && (i = e);
          }),
          (this.getCamera = function (e) {
            var t = 'stage' === u ? 1.6 : 0;
            if (null === r) return e.position.set(0, t, 0), e;
            if (((r.depthNear = e.near), (r.depthFar = e.far), r.getFrameData(n), 'stage' === u)) {
              var c = r.stageParameters;
              c ? o.fromArray(c.sittingToStandingTransform) : o.makeTranslation(0, t, 0);
            }
            var m = n.pose,
              v = null !== i ? i : e;
            if (
              (v.matrix.copy(o),
              v.matrix.decompose(v.position, v.quaternion, v.scale),
              null !== m.orientation && (h.fromArray(m.orientation), v.quaternion.multiply(h)),
              null !== m.position &&
                (h.setFromRotationMatrix(o),
                d.fromArray(m.position),
                d.applyQuaternion(h),
                v.position.add(d)),
              v.updateMatrixWorld(),
              !1 === r.isPresenting)
            )
              return e;
            (p.near = e.near),
              (f.near = e.near),
              (p.far = e.far),
              (f.far = e.far),
              p.matrixWorldInverse.fromArray(n.leftViewMatrix),
              f.matrixWorldInverse.fromArray(n.rightViewMatrix),
              s.getInverse(o),
              'stage' === u && (p.matrixWorldInverse.multiply(s), f.matrixWorldInverse.multiply(s));
            var y = v.parent;
            null !== y &&
              (l.getInverse(y.matrixWorld),
              p.matrixWorldInverse.multiply(l),
              f.matrixWorldInverse.multiply(l)),
              p.matrixWorld.getInverse(p.matrixWorldInverse),
              f.matrixWorld.getInverse(f.matrixWorldInverse),
              p.projectionMatrix.fromArray(n.leftProjectionMatrix),
              f.projectionMatrix.fromArray(n.rightProjectionMatrix),
              ba(g, p, f);
            var x = r.getLayers();
            if (x.length) {
              var _ = x[0];
              null !== _.leftBounds &&
                4 === _.leftBounds.length &&
                p.bounds.fromArray(_.leftBounds),
                null !== _.rightBounds &&
                  4 === _.rightBounds.length &&
                  f.bounds.fromArray(_.rightBounds);
            }
            return (
              (function () {
                for (var e = 0; e < a.length; e++) {
                  var t = a[e],
                    r = w(e);
                  if (void 0 !== r && void 0 !== r.pose) {
                    if (null === r.pose) return;
                    var n = r.pose;
                    !1 === n.hasPosition && t.position.set(0.2, -0.6, -0.05),
                      null !== n.position && t.position.fromArray(n.position),
                      null !== n.orientation && t.quaternion.fromArray(n.orientation),
                      t.matrix.compose(t.position, t.quaternion, t.scale),
                      t.matrix.premultiply(o),
                      t.matrix.decompose(t.position, t.quaternion, t.scale),
                      (t.matrixWorldNeedsUpdate = !0),
                      (t.visible = !0);
                    var i = 'Daydream Controller' === r.id ? 0 : 1;
                    b[e] !== r.buttons[i].pressed &&
                      ((b[e] = r.buttons[i].pressed),
                      !0 === b[e]
                        ? t.dispatchEvent({ type: 'selectstart' })
                        : (t.dispatchEvent({ type: 'selectend' }),
                          t.dispatchEvent({ type: 'select' })));
                  } else t.visible = !1;
                }
              })(),
              g
            );
          }),
          (this.getStandingMatrix = function () {
            return o;
          }),
          (this.isPresenting = y);
        var _ = new Or();
        (this.setAnimationLoop = function (e) {
          _.setAnimationLoop(e);
        }),
          (this.submitFrame = function () {
            y() && r.submitFrame();
          }),
          (this.dispose = function () {
            'undefined' != typeof window && window.removeEventListener('vrdisplaypresentchange', x);
          });
      }
      function _a(e) {
        var t = e.context,
          r = null,
          n = null,
          i = 1,
          a = null,
          o = 'stage',
          s = null,
          c = [],
          u = [];
        function l() {
          return null !== n && null !== a;
        }
        var h = new la();
        h.layers.enable(1), (h.viewport = new hr());
        var d = new la();
        d.layers.enable(2), (d.viewport = new hr());
        var p = new ha([h, d]);
        function f(e) {
          var t = c[u.indexOf(e.inputSource)];
          t && t.dispatchEvent({ type: e.type });
        }
        function m() {
          e.setFramebuffer(null), y.stop();
        }
        function v(e, t) {
          null === t
            ? e.matrixWorld.copy(e.matrix)
            : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.getInverse(e.matrixWorld);
        }
        p.layers.enable(1),
          p.layers.enable(2),
          (this.enabled = !1),
          (this.getController = function (e) {
            var t = c[e];
            return (
              void 0 === t &&
                (((t = new ca()).matrixAutoUpdate = !1), (t.visible = !1), (c[e] = t)),
              t
            );
          }),
          (this.getDevice = function () {
            return r;
          }),
          (this.setDevice = function (e) {
            void 0 !== e && (r = e), e instanceof XRDevice && t.setCompatibleXRDevice(e);
          }),
          (this.setFramebufferScaleFactor = function (e) {
            i = e;
          }),
          (this.setFrameOfReferenceType = function (e) {
            o = e;
          }),
          (this.setSession = function (r) {
            null !== (n = r) &&
              (n.addEventListener('select', f),
              n.addEventListener('selectstart', f),
              n.addEventListener('selectend', f),
              n.addEventListener('end', m),
              (n.baseLayer = new XRWebGLLayer(n, t, { framebufferScaleFactor: i })),
              n.requestFrameOfReference(o).then(function (t) {
                (a = t), e.setFramebuffer(n.baseLayer.framebuffer), y.setContext(n), y.start();
              }),
              (u = n.getInputSources()),
              n.addEventListener('inputsourceschange', function () {
                (u = n.getInputSources()), console.log(u);
                for (var e = 0; e < c.length; e++) {
                  c[e].userData.inputSource = u[e];
                }
              }));
          }),
          (this.getCamera = function (e) {
            if (l()) {
              var t = e.parent,
                r = p.cameras;
              v(p, t);
              for (var n = 0; n < r.length; n++) v(r[n], t);
              e.matrixWorld.copy(p.matrixWorld);
              for (var i = e.children, a = ((n = 0), i.length); n < a; n++)
                i[n].updateMatrixWorld(!0);
              return ba(p, h, d), p;
            }
            return e;
          }),
          (this.isPresenting = l);
        var g = null;
        var y = new Or();
        y.setAnimationLoop(function (e, t) {
          if (null !== (s = t.getDevicePose(a)))
            for (var r = n.baseLayer, i = t.views, o = 0; o < i.length; o++) {
              var l = i[o],
                h = r.getViewport(l),
                d = s.getViewMatrix(l),
                f = p.cameras[o];
              f.matrix.fromArray(d).getInverse(f.matrix),
                f.projectionMatrix.fromArray(l.projectionMatrix),
                f.viewport.set(h.x, h.y, h.width, h.height),
                0 === o && p.matrix.copy(f.matrix);
            }
          for (o = 0; o < c.length; o++) {
            var m = c[o],
              v = u[o];
            if (v) {
              var y = t.getInputPose(v, a);
              if (null !== y) {
                'targetRay' in y
                  ? (m.matrix.elements = y.targetRay.transformMatrix)
                  : 'pointerMatrix' in y && (m.matrix.elements = y.pointerMatrix),
                  m.matrix.decompose(m.position, m.rotation, m.scale),
                  (m.visible = !0);
                continue;
              }
            }
            m.visible = !1;
          }
          g && g(e);
        }),
          (this.setAnimationLoop = function (e) {
            g = e;
          }),
          (this.dispose = function () {}),
          (this.getStandingMatrix = function () {
            return (
              console.warn('THREE.WebXRManager: getStandingMatrix() is no longer needed.'),
              new THREE.Matrix4()
            );
          }),
          (this.submitFrame = function () {});
      }
      function Ma(e) {
        console.log('THREE.WebGLRenderer', v);
        var t =
            void 0 !== (e = e || {}).canvas
              ? e.canvas
              : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
          r = void 0 !== e.context ? e.context : null,
          n = void 0 !== e.alpha && e.alpha,
          i = void 0 === e.depth || e.depth,
          a = void 0 === e.stencil || e.stencil,
          o = void 0 !== e.antialias && e.antialias,
          s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
          c = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
          u = void 0 !== e.powerPreference ? e.powerPreference : 'default',
          l = null,
          h = null;
        (this.domElement = t),
          (this.context = null),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.gammaFactor = 2),
          (this.gammaInput = !1),
          (this.gammaOutput = !1),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = me),
          (this.toneMappingExposure = 1),
          (this.toneMappingWhitePoint = 1),
          (this.maxMorphTargets = 8),
          (this.maxMorphNormals = 4);
        var d,
          p,
          f,
          m,
          g,
          y,
          x,
          b,
          w,
          _,
          M,
          S,
          E,
          T,
          A,
          R,
          C,
          P,
          O = this,
          I = !1,
          D = null,
          B = null,
          N = null,
          U = -1,
          G = { geometry: null, program: null, wireframe: !1 },
          F = null,
          z = null,
          H = new hr(),
          k = new hr(),
          V = null,
          j = 0,
          W = t.width,
          q = t.height,
          X = 1,
          Y = new hr(0, 0, W, q),
          J = new hr(0, 0, W, q),
          Z = !1,
          K = new xr(),
          Q = new Dn(),
          $ = !1,
          ee = !1,
          te = new $t(),
          re = new tr();
        function ne() {
          return null === B ? X : 1;
        }
        try {
          var ie = {
            alpha: n,
            depth: i,
            stencil: a,
            antialias: o,
            premultipliedAlpha: s,
            preserveDrawingBuffer: c,
            powerPreference: u,
          };
          if (
            (t.addEventListener('webglcontextlost', ce, !1),
            t.addEventListener('webglcontextrestored', ue, !1),
            null === (d = r || t.getContext('webgl', ie) || t.getContext('experimental-webgl', ie)))
          )
            throw null !== t.getContext('webgl')
              ? new Error('Error creating WebGL context with your selected attributes.')
              : new Error('Error creating WebGL context.');
          void 0 === d.getShaderPrecisionFormat &&
            (d.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (e) {
          console.error('THREE.WebGLRenderer: ' + e.message);
        }
        function ae() {
          (p = new Bn(d)),
            (f = new In(d, p, e)).isWebGL2 ||
              (p.get('WEBGL_depth_texture'),
              p.get('OES_texture_float'),
              p.get('OES_texture_half_float'),
              p.get('OES_texture_half_float_linear'),
              p.get('OES_standard_derivatives'),
              p.get('OES_element_index_uint'),
              p.get('ANGLE_instanced_arrays')),
            p.get('OES_texture_float_linear'),
            (P = new sa(d, p, f)),
            (m = new aa(d, p, P, f)).scissor(k.copy(J).multiplyScalar(X)),
            m.viewport(H.copy(Y).multiplyScalar(X)),
            (g = new Gn(d)),
            (y = new qi()),
            (x = new oa(d, p, m, y, f, P, g)),
            (b = new Ir(d)),
            (w = new Nn(d, b, g)),
            (_ = new Hn(w, g)),
            (A = new zn(d)),
            (M = new Wi(O, p, f)),
            (S = new Zi()),
            (E = new ta()),
            (T = new Pn(O, m, _, s)),
            (R = new On(d, p, g, f)),
            (C = new Un(d, p, g, f)),
            (g.programs = M.programs),
            (O.context = d),
            (O.capabilities = f),
            (O.extensions = p),
            (O.properties = y),
            (O.renderLists = S),
            (O.state = m),
            (O.info = g);
        }
        ae();
        var oe = null;
        'undefined' != typeof navigator && (oe = 'xr' in navigator ? new _a(O) : new wa(O)),
          (this.vr = oe);
        var se = new ia(O, _, f.maxTextureSize);
        function ce(e) {
          e.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), (I = !0);
        }
        function ue() {
          console.log('THREE.WebGLRenderer: Context Restored.'), (I = !1), ae();
        }
        function le(e) {
          var t = e.target;
          t.removeEventListener('dispose', le),
            (function (e) {
              he(e), y.remove(e);
            })(t);
        }
        function he(e) {
          var t = y.get(e).program;
          (e.program = void 0), void 0 !== t && M.releaseProgram(t);
        }
        (this.shadowMap = se),
          (this.getContext = function () {
            return d;
          }),
          (this.getContextAttributes = function () {
            return d.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            var e = p.get('WEBGL_lose_context');
            e && e.loseContext();
          }),
          (this.forceContextRestore = function () {
            var e = p.get('WEBGL_lose_context');
            e && e.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return X;
          }),
          (this.setPixelRatio = function (e) {
            void 0 !== e && ((X = e), this.setSize(W, q, !1));
          }),
          (this.getSize = function () {
            return { width: W, height: q };
          }),
          (this.setSize = function (e, r, n) {
            oe.isPresenting()
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
                )
              : ((W = e),
                (q = r),
                (t.width = e * X),
                (t.height = r * X),
                !1 !== n && ((t.style.width = e + 'px'), (t.style.height = r + 'px')),
                this.setViewport(0, 0, e, r));
          }),
          (this.getDrawingBufferSize = function () {
            return { width: W * X, height: q * X };
          }),
          (this.setDrawingBufferSize = function (e, r, n) {
            (W = e),
              (q = r),
              (X = n),
              (t.width = e * n),
              (t.height = r * n),
              this.setViewport(0, 0, e, r);
          }),
          (this.getCurrentViewport = function () {
            return H;
          }),
          (this.setViewport = function (e, t, r, n) {
            Y.set(e, q - t - n, r, n), m.viewport(H.copy(Y).multiplyScalar(X));
          }),
          (this.setScissor = function (e, t, r, n) {
            J.set(e, q - t - n, r, n), m.scissor(k.copy(J).multiplyScalar(X));
          }),
          (this.setScissorTest = function (e) {
            m.setScissorTest((Z = e));
          }),
          (this.getClearColor = function () {
            return T.getClearColor();
          }),
          (this.setClearColor = function () {
            T.setClearColor.apply(T, arguments);
          }),
          (this.getClearAlpha = function () {
            return T.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            T.setClearAlpha.apply(T, arguments);
          }),
          (this.clear = function (e, t, r) {
            var n = 0;
            (void 0 === e || e) && (n |= 16384),
              (void 0 === t || t) && (n |= 256),
              (void 0 === r || r) && (n |= 1024),
              d.clear(n);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            t.removeEventListener('webglcontextlost', ce, !1),
              t.removeEventListener('webglcontextrestored', ue, !1),
              S.dispose(),
              E.dispose(),
              y.dispose(),
              _.dispose(),
              oe.dispose(),
              fe.stop();
          }),
          (this.renderBufferImmediate = function (e, t) {
            m.initAttributes();
            var r = y.get(e);
            e.hasPositions && !r.position && (r.position = d.createBuffer()),
              e.hasNormals && !r.normal && (r.normal = d.createBuffer()),
              e.hasUvs && !r.uv && (r.uv = d.createBuffer()),
              e.hasColors && !r.color && (r.color = d.createBuffer());
            var n = t.getAttributes();
            e.hasPositions &&
              (d.bindBuffer(34962, r.position),
              d.bufferData(34962, e.positionArray, 35048),
              m.enableAttribute(n.position),
              d.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)),
              e.hasNormals &&
                (d.bindBuffer(34962, r.normal),
                d.bufferData(34962, e.normalArray, 35048),
                m.enableAttribute(n.normal),
                d.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)),
              e.hasUvs &&
                (d.bindBuffer(34962, r.uv),
                d.bufferData(34962, e.uvArray, 35048),
                m.enableAttribute(n.uv),
                d.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)),
              e.hasColors &&
                (d.bindBuffer(34962, r.color),
                d.bufferData(34962, e.colorArray, 35048),
                m.enableAttribute(n.color),
                d.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)),
              m.disableUnusedAttributes(),
              d.drawArrays(4, 0, e.count),
              (e.count = 0);
          }),
          (this.renderBufferDirect = function (e, t, r, n, i, a) {
            var o = i.isMesh && i.normalMatrix.determinant() < 0;
            m.setMaterial(n, o);
            var s = xe(e, t, n, i),
              c = !1;
            (G.geometry === r.id && G.program === s.id && G.wireframe === (!0 === n.wireframe)) ||
              ((G.geometry = r.id),
              (G.program = s.id),
              (G.wireframe = !0 === n.wireframe),
              (c = !0)),
              i.morphTargetInfluences && (A.update(i, r, n, s), (c = !0));
            var u,
              l = r.index,
              h = r.attributes.position,
              v = 1;
            !0 === n.wireframe && ((l = w.getWireframeAttribute(r)), (v = 2));
            var g = R;
            null !== l && ((u = b.get(l)), (g = C).setIndex(u)),
              c &&
                (!(function (e, t, r) {
                  if (
                    r &&
                    r.isInstancedBufferGeometry & !f.isWebGL2 &&
                    null === p.get('ANGLE_instanced_arrays')
                  )
                    return void console.error(
                      'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
                    );
                  m.initAttributes();
                  var n = r.attributes,
                    i = t.getAttributes(),
                    a = e.defaultAttributeValues;
                  for (var o in i) {
                    var s = i[o];
                    if (s >= 0) {
                      var c = n[o];
                      if (void 0 !== c) {
                        var u = c.normalized,
                          l = c.itemSize,
                          h = b.get(c);
                        if (void 0 === h) continue;
                        var v = h.buffer,
                          g = h.type,
                          y = h.bytesPerElement;
                        if (c.isInterleavedBufferAttribute) {
                          var x = c.data,
                            w = x.stride,
                            _ = c.offset;
                          x && x.isInstancedInterleavedBuffer
                            ? (m.enableAttributeAndDivisor(s, x.meshPerAttribute),
                              void 0 === r.maxInstancedCount &&
                                (r.maxInstancedCount = x.meshPerAttribute * x.count))
                            : m.enableAttribute(s),
                            d.bindBuffer(34962, v),
                            d.vertexAttribPointer(s, l, g, u, w * y, _ * y);
                        } else
                          c.isInstancedBufferAttribute
                            ? (m.enableAttributeAndDivisor(s, c.meshPerAttribute),
                              void 0 === r.maxInstancedCount &&
                                (r.maxInstancedCount = c.meshPerAttribute * c.count))
                            : m.enableAttribute(s),
                            d.bindBuffer(34962, v),
                            d.vertexAttribPointer(s, l, g, u, 0, 0);
                      } else if (void 0 !== a) {
                        var M = a[o];
                        if (void 0 !== M)
                          switch (M.length) {
                            case 2:
                              d.vertexAttrib2fv(s, M);
                              break;
                            case 3:
                              d.vertexAttrib3fv(s, M);
                              break;
                            case 4:
                              d.vertexAttrib4fv(s, M);
                              break;
                            default:
                              d.vertexAttrib1fv(s, M);
                          }
                      }
                    }
                  }
                  m.disableUnusedAttributes();
                })(n, s, r),
                null !== l && d.bindBuffer(34963, u.buffer));
            var y = 1 / 0;
            null !== l ? (y = l.count) : void 0 !== h && (y = h.count);
            var x = r.drawRange.start * v,
              _ = r.drawRange.count * v,
              M = null !== a ? a.start * v : 0,
              S = null !== a ? a.count * v : 1 / 0,
              E = Math.max(x, M),
              T = Math.min(y, x + _, M + S) - 1,
              L = Math.max(0, T - E + 1);
            if (0 !== L) {
              if (i.isMesh)
                if (!0 === n.wireframe) m.setLineWidth(n.wireframeLinewidth * ne()), g.setMode(1);
                else
                  switch (i.drawMode) {
                    case Nt:
                      g.setMode(4);
                      break;
                    case Ut:
                      g.setMode(5);
                      break;
                    case Gt:
                      g.setMode(6);
                  }
              else if (i.isLine) {
                var P = n.linewidth;
                void 0 === P && (P = 1),
                  m.setLineWidth(P * ne()),
                  i.isLineSegments ? g.setMode(1) : i.isLineLoop ? g.setMode(2) : g.setMode(3);
              } else i.isPoints ? g.setMode(0) : i.isSprite && g.setMode(4);
              r && r.isInstancedBufferGeometry
                ? r.maxInstancedCount > 0 && g.renderInstances(r, E, L)
                : g.render(E, L);
            }
          }),
          (this.compile = function (e, t) {
            (h = E.get(e, t)).init(),
              e.traverse(function (e) {
                e.isLight && (h.pushLight(e), e.castShadow && h.pushShadow(e));
              }),
              h.setupLights(t),
              e.traverse(function (t) {
                if (t.material)
                  if (Array.isArray(t.material))
                    for (var r = 0; r < t.material.length; r++) ye(t.material[r], e.fog, t);
                  else ye(t.material, e.fog, t);
              });
          });
        var de = null;
        var pe,
          fe = new Or();
        function ve(e, t, r, n) {
          for (var i = 0, a = e.length; i < a; i++) {
            var o = e[i],
              s = o.object,
              c = o.geometry,
              u = void 0 === n ? o.material : n,
              l = o.group;
            if (r.isArrayCamera) {
              z = r;
              for (var d = r.cameras, p = 0, f = d.length; p < f; p++) {
                var v = d[p];
                if (s.layers.test(v.layers)) {
                  if ('viewport' in v) m.viewport(H.copy(v.viewport));
                  else {
                    var g = v.bounds,
                      y = g.x * W,
                      x = g.y * q,
                      b = g.z * W,
                      w = g.w * q;
                    m.viewport(H.set(y, x, b, w).multiplyScalar(X));
                  }
                  h.setupLights(v), ge(s, t, v, c, u, l);
                }
              }
            } else (z = null), ge(s, t, r, c, u, l);
          }
        }
        function ge(e, t, r, n, i, a) {
          if (
            (e.onBeforeRender(O, t, r, n, i, a),
            (h = E.get(t, z || r)),
            e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            e.isImmediateRenderObject)
          ) {
            m.setMaterial(i);
            var o = xe(r, t.fog, i, e);
            (G.geometry = null),
              (G.program = null),
              (G.wireframe = !1),
              (function (e, t) {
                e.render(function (e) {
                  O.renderBufferImmediate(e, t);
                });
              })(e, o);
          } else O.renderBufferDirect(r, t.fog, n, i, e, a);
          e.onAfterRender(O, t, r, n, i, a), (h = E.get(t, z || r));
        }
        function ye(e, t, r) {
          var n = y.get(e),
            i = h.state.lights,
            a = h.state.shadowsArray,
            o = n.lightsHash,
            s = i.state.hash,
            c = M.getParameters(e, i.state, a, t, Q.numPlanes, Q.numIntersection, r),
            u = M.getProgramCode(e, c),
            l = n.program,
            d = !0;
          if (void 0 === l) e.addEventListener('dispose', le);
          else if (l.code !== u) he(e);
          else if (
            o.stateID !== s.stateID ||
            o.directionalLength !== s.directionalLength ||
            o.pointLength !== s.pointLength ||
            o.spotLength !== s.spotLength ||
            o.rectAreaLength !== s.rectAreaLength ||
            o.hemiLength !== s.hemiLength ||
            o.shadowsLength !== s.shadowsLength
          )
            (o.stateID = s.stateID),
              (o.directionalLength = s.directionalLength),
              (o.pointLength = s.pointLength),
              (o.spotLength = s.spotLength),
              (o.rectAreaLength = s.rectAreaLength),
              (o.hemiLength = s.hemiLength),
              (o.shadowsLength = s.shadowsLength),
              (d = !1);
          else {
            if (void 0 !== c.shaderID) return;
            d = !1;
          }
          if (d) {
            if (c.shaderID) {
              var p = Pr[c.shaderID];
              n.shader = {
                name: e.type,
                uniforms: wr(p.uniforms),
                vertexShader: p.vertexShader,
                fragmentShader: p.fragmentShader,
              };
            } else
              n.shader = {
                name: e.type,
                uniforms: e.uniforms,
                vertexShader: e.vertexShader,
                fragmentShader: e.fragmentShader,
              };
            e.onBeforeCompile(n.shader, O),
              (u = M.getProgramCode(e, c)),
              (l = M.acquireProgram(e, n.shader, c, u)),
              (n.program = l),
              (e.program = l);
          }
          var f = l.getAttributes();
          if (e.morphTargets) {
            e.numSupportedMorphTargets = 0;
            for (var m = 0; m < O.maxMorphTargets; m++)
              f['morphTarget' + m] >= 0 && e.numSupportedMorphTargets++;
          }
          if (e.morphNormals) {
            e.numSupportedMorphNormals = 0;
            for (m = 0; m < O.maxMorphNormals; m++)
              f['morphNormal' + m] >= 0 && e.numSupportedMorphNormals++;
          }
          var v = n.shader.uniforms;
          ((e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping) ||
            ((n.numClippingPlanes = Q.numPlanes),
            (n.numIntersection = Q.numIntersection),
            (v.clippingPlanes = Q.uniform)),
            (n.fog = t),
            void 0 === o && (n.lightsHash = o = {}),
            (o.stateID = s.stateID),
            (o.directionalLength = s.directionalLength),
            (o.pointLength = s.pointLength),
            (o.spotLength = s.spotLength),
            (o.rectAreaLength = s.rectAreaLength),
            (o.hemiLength = s.hemiLength),
            (o.shadowsLength = s.shadowsLength),
            e.lights &&
              ((v.ambientLightColor.value = i.state.ambient),
              (v.directionalLights.value = i.state.directional),
              (v.spotLights.value = i.state.spot),
              (v.rectAreaLights.value = i.state.rectArea),
              (v.pointLights.value = i.state.point),
              (v.hemisphereLights.value = i.state.hemi),
              (v.directionalShadowMap.value = i.state.directionalShadowMap),
              (v.directionalShadowMatrix.value = i.state.directionalShadowMatrix),
              (v.spotShadowMap.value = i.state.spotShadowMap),
              (v.spotShadowMatrix.value = i.state.spotShadowMatrix),
              (v.pointShadowMap.value = i.state.pointShadowMap),
              (v.pointShadowMatrix.value = i.state.pointShadowMatrix));
          var g = n.program.getUniforms(),
            x = Ii.seqWithValue(g.seq, v);
          n.uniformsList = x;
        }
        function xe(e, t, r, n) {
          j = 0;
          var i = y.get(r),
            a = h.state.lights,
            o = i.lightsHash,
            s = a.state.hash;
          if ($ && (ee || e !== F)) {
            var c = e === F && r.id === U;
            Q.setState(r.clippingPlanes, r.clipIntersection, r.clipShadows, e, i, c);
          }
          !1 === r.needsUpdate &&
            (void 0 === i.program
              ? (r.needsUpdate = !0)
              : r.fog && i.fog !== t
              ? (r.needsUpdate = !0)
              : ((!r.lights ||
                  (o.stateID === s.stateID &&
                    o.directionalLength === s.directionalLength &&
                    o.pointLength === s.pointLength &&
                    o.spotLength === s.spotLength &&
                    o.rectAreaLength === s.rectAreaLength &&
                    o.hemiLength === s.hemiLength &&
                    o.shadowsLength === s.shadowsLength)) &&
                  (void 0 === i.numClippingPlanes ||
                    (i.numClippingPlanes === Q.numPlanes &&
                      i.numIntersection === Q.numIntersection))) ||
                (r.needsUpdate = !0)),
            r.needsUpdate && (ye(r, t, n), (r.needsUpdate = !1));
          var u,
            l,
            p = !1,
            v = !1,
            g = !1,
            x = i.program,
            b = x.getUniforms(),
            w = i.shader.uniforms;
          if (
            (m.useProgram(x.program) && ((p = !0), (v = !0), (g = !0)),
            r.id !== U && ((U = r.id), (v = !0)),
            p || F !== e)
          ) {
            if (
              (b.setValue(d, 'projectionMatrix', e.projectionMatrix),
              f.logarithmicDepthBuffer &&
                b.setValue(d, 'logDepthBufFC', 2 / (Math.log(e.far + 1) / Math.LN2)),
              F !== e && ((F = e), (v = !0), (g = !0)),
              r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshStandardMaterial || r.envMap)
            ) {
              var _ = b.map.cameraPosition;
              void 0 !== _ && _.setValue(d, re.setFromMatrixPosition(e.matrixWorld));
            }
            (r.isMeshPhongMaterial ||
              r.isMeshLambertMaterial ||
              r.isMeshBasicMaterial ||
              r.isMeshStandardMaterial ||
              r.isShaderMaterial ||
              r.skinning) &&
              b.setValue(d, 'viewMatrix', e.matrixWorldInverse);
          }
          if (r.skinning) {
            b.setOptional(d, n, 'bindMatrix'), b.setOptional(d, n, 'bindMatrixInverse');
            var M = n.skeleton;
            if (M) {
              var S = M.bones;
              if (f.floatVertexTextures) {
                if (void 0 === M.boneTexture) {
                  var E = Math.sqrt(4 * S.length);
                  (E = Kt.ceilPowerOfTwo(E)), (E = Math.max(E, 4));
                  var T = new Float32Array(E * E * 4);
                  T.set(M.boneMatrices);
                  var A = new mr(T, E, E, Ke, Ve);
                  (A.needsUpdate = !0),
                    (M.boneMatrices = T),
                    (M.boneTexture = A),
                    (M.boneTextureSize = E);
                }
                b.setValue(d, 'boneTexture', M.boneTexture),
                  b.setValue(d, 'boneTextureSize', M.boneTextureSize);
              } else b.setOptional(d, M, 'boneMatrices');
            }
          }
          return (
            v &&
              (b.setValue(d, 'toneMappingExposure', O.toneMappingExposure),
              b.setValue(d, 'toneMappingWhitePoint', O.toneMappingWhitePoint),
              r.lights &&
                ((l = g),
                ((u = w).ambientLightColor.needsUpdate = l),
                (u.directionalLights.needsUpdate = l),
                (u.pointLights.needsUpdate = l),
                (u.spotLights.needsUpdate = l),
                (u.rectAreaLights.needsUpdate = l),
                (u.hemisphereLights.needsUpdate = l)),
              t &&
                r.fog &&
                (function (e, t) {
                  (e.fogColor.value = t.color),
                    t.isFog
                      ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
                      : t.isFogExp2 && (e.fogDensity.value = t.density);
                })(w, t),
              r.isMeshBasicMaterial
                ? be(w, r)
                : r.isMeshLambertMaterial
                ? (be(w, r),
                  (function (e, t) {
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                  })(w, r))
                : r.isMeshPhongMaterial
                ? (be(w, r),
                  r.isMeshToonMaterial
                    ? (function (e, t) {
                        we(e, t), t.gradientMap && (e.gradientMap.value = t.gradientMap);
                      })(w, r)
                    : we(w, r))
                : r.isMeshStandardMaterial
                ? (be(w, r),
                  r.isMeshPhysicalMaterial
                    ? (function (e, t) {
                        _e(e, t),
                          (e.reflectivity.value = t.reflectivity),
                          (e.clearCoat.value = t.clearCoat),
                          (e.clearCoatRoughness.value = t.clearCoatRoughness);
                      })(w, r)
                    : _e(w, r))
                : r.isMeshMatcapMaterial
                ? (be(w, r),
                  (function (e, t) {
                    t.matcap && (e.matcap.value = t.matcap);
                    t.bumpMap &&
                      ((e.bumpMap.value = t.bumpMap),
                      (e.bumpScale.value = t.bumpScale),
                      t.side === L && (e.bumpScale.value *= -1));
                    t.normalMap &&
                      ((e.normalMap.value = t.normalMap),
                      e.normalScale.value.copy(t.normalScale),
                      t.side === L && e.normalScale.value.negate());
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                  })(w, r))
                : r.isMeshDepthMaterial
                ? (be(w, r),
                  (function (e, t) {
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                  })(w, r))
                : r.isMeshDistanceMaterial
                ? (be(w, r),
                  (function (e, t) {
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                    e.referencePosition.value.copy(t.referencePosition),
                      (e.nearDistance.value = t.nearDistance),
                      (e.farDistance.value = t.farDistance);
                  })(w, r))
                : r.isMeshNormalMaterial
                ? (be(w, r),
                  (function (e, t) {
                    t.bumpMap &&
                      ((e.bumpMap.value = t.bumpMap),
                      (e.bumpScale.value = t.bumpScale),
                      t.side === L && (e.bumpScale.value *= -1));
                    t.normalMap &&
                      ((e.normalMap.value = t.normalMap),
                      e.normalScale.value.copy(t.normalScale),
                      t.side === L && e.normalScale.value.negate());
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                  })(w, r))
                : r.isLineBasicMaterial
                ? ((function (e, t) {
                    (e.diffuse.value = t.color), (e.opacity.value = t.opacity);
                  })(w, r),
                  r.isLineDashedMaterial &&
                    (function (e, t) {
                      (e.dashSize.value = t.dashSize),
                        (e.totalSize.value = t.dashSize + t.gapSize),
                        (e.scale.value = t.scale);
                    })(w, r))
                : r.isPointsMaterial
                ? (function (e, t) {
                    (e.diffuse.value = t.color),
                      (e.opacity.value = t.opacity),
                      (e.size.value = t.size * X),
                      (e.scale.value = 0.5 * q),
                      (e.map.value = t.map),
                      null !== t.map &&
                        (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(),
                        e.uvTransform.value.copy(t.map.matrix));
                  })(w, r)
                : r.isSpriteMaterial
                ? (function (e, t) {
                    (e.diffuse.value = t.color),
                      (e.opacity.value = t.opacity),
                      (e.rotation.value = t.rotation),
                      (e.map.value = t.map),
                      null !== t.map &&
                        (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(),
                        e.uvTransform.value.copy(t.map.matrix));
                  })(w, r)
                : r.isShadowMaterial && ((w.color.value = r.color), (w.opacity.value = r.opacity)),
              void 0 !== w.ltc_1 && (w.ltc_1.value = Cr.LTC_1),
              void 0 !== w.ltc_2 && (w.ltc_2.value = Cr.LTC_2),
              Ii.upload(d, i.uniformsList, w, O)),
            r.isShaderMaterial &&
              !0 === r.uniformsNeedUpdate &&
              (Ii.upload(d, i.uniformsList, w, O), (r.uniformsNeedUpdate = !1)),
            r.isSpriteMaterial && b.setValue(d, 'center', n.center),
            b.setValue(d, 'modelViewMatrix', n.modelViewMatrix),
            b.setValue(d, 'normalMatrix', n.normalMatrix),
            b.setValue(d, 'modelMatrix', n.matrixWorld),
            x
          );
        }
        function be(e, t) {
          var r;
          (e.opacity.value = t.opacity),
            t.color && (e.diffuse.value = t.color),
            t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity),
            t.map && (e.map.value = t.map),
            t.alphaMap && (e.alphaMap.value = t.alphaMap),
            t.specularMap && (e.specularMap.value = t.specularMap),
            t.envMap &&
              ((e.envMap.value = t.envMap),
              (e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1),
              (e.reflectivity.value = t.reflectivity),
              (e.refractionRatio.value = t.refractionRatio),
              (e.maxMipLevel.value = y.get(t.envMap).__maxMipLevel)),
            t.lightMap &&
              ((e.lightMap.value = t.lightMap), (e.lightMapIntensity.value = t.lightMapIntensity)),
            t.aoMap && ((e.aoMap.value = t.aoMap), (e.aoMapIntensity.value = t.aoMapIntensity)),
            t.map
              ? (r = t.map)
              : t.specularMap
              ? (r = t.specularMap)
              : t.displacementMap
              ? (r = t.displacementMap)
              : t.normalMap
              ? (r = t.normalMap)
              : t.bumpMap
              ? (r = t.bumpMap)
              : t.roughnessMap
              ? (r = t.roughnessMap)
              : t.metalnessMap
              ? (r = t.metalnessMap)
              : t.alphaMap
              ? (r = t.alphaMap)
              : t.emissiveMap && (r = t.emissiveMap),
            void 0 !== r &&
              (r.isWebGLRenderTarget && (r = r.texture),
              !0 === r.matrixAutoUpdate && r.updateMatrix(),
              e.uvTransform.value.copy(r.matrix));
        }
        function we(e, t) {
          (e.specular.value = t.specular),
            (e.shininess.value = Math.max(t.shininess, 1e-4)),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap &&
              ((e.bumpMap.value = t.bumpMap),
              (e.bumpScale.value = t.bumpScale),
              t.side === L && (e.bumpScale.value *= -1)),
            t.normalMap &&
              ((e.normalMap.value = t.normalMap),
              e.normalScale.value.copy(t.normalScale),
              t.side === L && e.normalScale.value.negate()),
            t.displacementMap &&
              ((e.displacementMap.value = t.displacementMap),
              (e.displacementScale.value = t.displacementScale),
              (e.displacementBias.value = t.displacementBias));
        }
        function _e(e, t) {
          (e.roughness.value = t.roughness),
            (e.metalness.value = t.metalness),
            t.roughnessMap && (e.roughnessMap.value = t.roughnessMap),
            t.metalnessMap && (e.metalnessMap.value = t.metalnessMap),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap &&
              ((e.bumpMap.value = t.bumpMap),
              (e.bumpScale.value = t.bumpScale),
              t.side === L && (e.bumpScale.value *= -1)),
            t.normalMap &&
              ((e.normalMap.value = t.normalMap),
              e.normalScale.value.copy(t.normalScale),
              t.side === L && e.normalScale.value.negate()),
            t.displacementMap &&
              ((e.displacementMap.value = t.displacementMap),
              (e.displacementScale.value = t.displacementScale),
              (e.displacementBias.value = t.displacementBias)),
            t.envMap && (e.envMapIntensity.value = t.envMapIntensity);
        }
        fe.setAnimationLoop(function (e) {
          oe.isPresenting() || (de && de(e));
        }),
          'undefined' != typeof window && fe.setContext(window),
          (this.setAnimationLoop = function (e) {
            (de = e), oe.setAnimationLoop(e), fe.start();
          }),
          (this.render = function (e, t, r, n) {
            if (t && t.isCamera) {
              if (!I) {
                (G.geometry = null),
                  (G.program = null),
                  (G.wireframe = !1),
                  (U = -1),
                  (F = null),
                  !0 === e.autoUpdate && e.updateMatrixWorld(),
                  null === t.parent && t.updateMatrixWorld(),
                  oe.enabled && (t = oe.getCamera(t)),
                  (h = E.get(e, t)).init(),
                  e.onBeforeRender(O, e, t, r),
                  te.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                  K.setFromMatrix(te),
                  (ee = this.localClippingEnabled),
                  ($ = Q.init(this.clippingPlanes, ee, t)),
                  (l = S.get(e, t)).init(),
                  (function e(t, r, n, i) {
                    if (!1 === t.visible) return;
                    var a = t.layers.test(r.layers);
                    if (a)
                      if (t.isGroup) n = t.renderOrder;
                      else if (t.isLight) h.pushLight(t), t.castShadow && h.pushShadow(t);
                      else if (t.isSprite) {
                        if (!t.frustumCulled || K.intersectsSprite(t)) {
                          i && re.setFromMatrixPosition(t.matrixWorld).applyMatrix4(te);
                          var o = _.update(t),
                            s = t.material;
                          l.push(t, o, s, n, re.z, null);
                        }
                      } else if (t.isImmediateRenderObject)
                        i && re.setFromMatrixPosition(t.matrixWorld).applyMatrix4(te),
                          l.push(t, null, t.material, n, re.z, null);
                      else if (
                        (t.isMesh || t.isLine || t.isPoints) &&
                        (t.isSkinnedMesh && t.skeleton.update(),
                        !t.frustumCulled || K.intersectsObject(t))
                      ) {
                        i && re.setFromMatrixPosition(t.matrixWorld).applyMatrix4(te);
                        var o = _.update(t),
                          s = t.material;
                        if (Array.isArray(s))
                          for (var c = o.groups, u = 0, d = c.length; u < d; u++) {
                            var p = c[u],
                              f = s[p.materialIndex];
                            f && f.visible && l.push(t, o, f, n, re.z, p);
                          }
                        else s.visible && l.push(t, o, s, n, re.z, null);
                      }
                    var m = t.children;
                    for (var u = 0, d = m.length; u < d; u++) e(m[u], r, n, i);
                  })(e, t, 0, O.sortObjects),
                  !0 === O.sortObjects && l.sort(),
                  $ && Q.beginShadows();
                var i = h.state.shadowsArray;
                se.render(i, e, t),
                  h.setupLights(t),
                  $ && Q.endShadows(),
                  this.info.autoReset && this.info.reset(),
                  void 0 === r && (r = null),
                  this.setRenderTarget(r),
                  T.render(l, e, t, n);
                var a = l.opaque,
                  o = l.transparent;
                if (e.overrideMaterial) {
                  var s = e.overrideMaterial;
                  a.length && ve(a, e, t, s), o.length && ve(o, e, t, s);
                } else a.length && ve(a, e, t), o.length && ve(o, e, t);
                r && (x.updateRenderTargetMipmap(r), x.updateMultisampleRenderTarget(r)),
                  m.buffers.depth.setTest(!0),
                  m.buffers.depth.setMask(!0),
                  m.buffers.color.setMask(!0),
                  m.setPolygonOffset(!1),
                  e.onAfterRender(O, e, t),
                  oe.enabled && oe.submitFrame(),
                  (l = null),
                  (h = null);
              }
            } else
              console.error(
                'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.',
              );
          }),
          (this.allocTextureUnit = function () {
            var e = j;
            return (
              e >= f.maxTextures &&
                console.warn(
                  'THREE.WebGLRenderer: Trying to use ' +
                    e +
                    ' texture units while this GPU supports only ' +
                    f.maxTextures,
                ),
              (j += 1),
              e
            );
          }),
          (this.setTexture2D =
            ((pe = !1),
            function (e, t) {
              e &&
                e.isWebGLRenderTarget &&
                (pe ||
                  (console.warn(
                    "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.",
                  ),
                  (pe = !0)),
                (e = e.texture)),
                x.setTexture2D(e, t);
            })),
          (this.setTexture3D = function (e, t) {
            x.setTexture3D(e, t);
          }),
          (this.setTexture = (function () {
            var e = !1;
            return function (t, r) {
              e ||
                (console.warn(
                  'THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.',
                ),
                (e = !0)),
                x.setTexture2D(t, r);
            };
          })()),
          (this.setTextureCube = (function () {
            var e = !1;
            return function (t, r) {
              t &&
                t.isWebGLRenderTargetCube &&
                (e ||
                  (console.warn(
                    "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.",
                  ),
                  (e = !0)),
                (t = t.texture)),
                (t && t.isCubeTexture) || (Array.isArray(t.image) && 6 === t.image.length)
                  ? x.setTextureCube(t, r)
                  : x.setTextureCubeDynamic(t, r);
            };
          })()),
          (this.setFramebuffer = function (e) {
            D = e;
          }),
          (this.getRenderTarget = function () {
            return B;
          }),
          (this.setRenderTarget = function (e) {
            (B = e), e && void 0 === y.get(e).__webglFramebuffer && x.setupRenderTarget(e);
            var t = D,
              r = !1;
            if (e) {
              var n = y.get(e).__webglFramebuffer;
              e.isWebGLRenderTargetCube
                ? ((t = n[e.activeCubeFace]), (r = !0))
                : (t = e.isWebGLMultisampleRenderTarget
                    ? y.get(e).__webglMultisampledFramebuffer
                    : n),
                H.copy(e.viewport),
                k.copy(e.scissor),
                (V = e.scissorTest);
            } else H.copy(Y).multiplyScalar(X), k.copy(J).multiplyScalar(X), (V = Z);
            if (
              (N !== t && (d.bindFramebuffer(36160, t), (N = t)),
              m.viewport(H),
              m.scissor(k),
              m.setScissorTest(V),
              r)
            ) {
              var i = y.get(e.texture);
              d.framebufferTexture2D(
                36160,
                36064,
                34069 + e.activeCubeFace,
                i.__webglTexture,
                e.activeMipMapLevel,
              );
            }
          }),
          (this.readRenderTargetPixels = function (e, t, r, n, i, a) {
            if (e && e.isWebGLRenderTarget) {
              var o = y.get(e).__webglFramebuffer;
              if (o) {
                var s = !1;
                o !== N && (d.bindFramebuffer(36160, o), (s = !0));
                try {
                  var c = e.texture,
                    u = c.format,
                    l = c.type;
                  if (u !== Ke && P.convert(u) !== d.getParameter(35739))
                    return void console.error(
                      'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',
                    );
                  if (
                    !(
                      l === Ue ||
                      P.convert(l) === d.getParameter(35738) ||
                      (l === Ve &&
                        (f.isWebGL2 ||
                          p.get('OES_texture_float') ||
                          p.get('WEBGL_color_buffer_float'))) ||
                      (l === je &&
                        (f.isWebGL2
                          ? p.get('EXT_color_buffer_float')
                          : p.get('EXT_color_buffer_half_float')))
                    )
                  )
                    return void console.error(
                      'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',
                    );
                  36053 === d.checkFramebufferStatus(36160)
                    ? t >= 0 &&
                      t <= e.width - n &&
                      r >= 0 &&
                      r <= e.height - i &&
                      d.readPixels(t, r, n, i, P.convert(u), P.convert(l), a)
                    : console.error(
                        'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.',
                      );
                } finally {
                  s && d.bindFramebuffer(36160, N);
                }
              }
            } else
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
              );
          }),
          (this.copyFramebufferToTexture = function (e, t, r) {
            var n = t.image.width,
              i = t.image.height,
              a = P.convert(t.format);
            this.setTexture2D(t, 0), d.copyTexImage2D(3553, r || 0, a, e.x, e.y, n, i, 0);
          }),
          (this.copyTextureToTexture = function (e, t, r, n) {
            var i = t.image.width,
              a = t.image.height,
              o = P.convert(r.format),
              s = P.convert(r.type);
            this.setTexture2D(r, 0),
              t.isDataTexture
                ? d.texSubImage2D(3553, n || 0, e.x, e.y, i, a, o, s, t.image.data)
                : d.texSubImage2D(3553, n || 0, e.x, e.y, o, s, t.image);
          });
      }
      function Sa(e, t) {
        (this.name = ''), (this.color = new Lr(e)), (this.density = void 0 !== t ? t : 25e-5);
      }
      function Ea(e, t, r) {
        (this.name = ''),
          (this.color = new Lr(e)),
          (this.near = void 0 !== t ? t : 1),
          (this.far = void 0 !== r ? r : 1e3);
      }
      function Ta() {
        kr.call(this),
          (this.type = 'Scene'),
          (this.background = null),
          (this.fog = null),
          (this.overrideMaterial = null),
          (this.autoUpdate = !0);
      }
      function Aa(e, t) {
        (this.array = e),
          (this.stride = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.dynamic = !1),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0);
      }
      function La(e, t, r, n) {
        (this.data = e), (this.itemSize = t), (this.offset = r), (this.normalized = !0 === n);
      }
      function Ra(e) {
        En.call(this),
          (this.type = 'SpriteMaterial'),
          (this.color = new Lr(16777215)),
          (this.map = null),
          (this.rotation = 0),
          (this.sizeAttenuation = !0),
          (this.lights = !1),
          (this.transparent = !0),
          this.setValues(e);
      }
      function Ca(e) {
        if ((kr.call(this), (this.type = 'Sprite'), void 0 === da)) {
          da = new sn();
          var t = new Aa(
            new Float32Array([
              -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1,
            ]),
            5,
          );
          da.setIndex([0, 1, 2, 0, 2, 3]),
            da.addAttribute('position', new La(t, 3, 0, !1)),
            da.addAttribute('uv', new La(t, 2, 3, !1));
        }
        (this.geometry = da),
          (this.material = void 0 !== e ? e : new Ra()),
          (this.center = new Qt(0.5, 0.5));
      }
      function Pa() {
        kr.call(this),
          (this.type = 'LOD'),
          Object.defineProperties(this, { levels: { enumerable: !0, value: [] } });
      }
      function Oa(e, t) {
        e &&
          e.isGeometry &&
          console.error(
            'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
          ),
          Cn.call(this, e, t),
          (this.type = 'SkinnedMesh'),
          (this.bindMode = 'attached'),
          (this.bindMatrix = new $t()),
          (this.bindMatrixInverse = new $t());
      }
      function Ia(e, t) {
        if (
          ((e = e || []),
          (this.bones = e.slice(0)),
          (this.boneMatrices = new Float32Array(16 * this.bones.length)),
          void 0 === t)
        )
          this.calculateInverses();
        else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
        else {
          console.warn('THREE.Skeleton boneInverses is the wrong length.'),
            (this.boneInverses = []);
          for (var r = 0, n = this.bones.length; r < n; r++) this.boneInverses.push(new $t());
        }
      }
      function Da() {
        kr.call(this), (this.type = 'Bone');
      }
      function Ba(e) {
        En.call(this),
          (this.type = 'LineBasicMaterial'),
          (this.color = new Lr(16777215)),
          (this.linewidth = 1),
          (this.linecap = 'round'),
          (this.linejoin = 'round'),
          (this.lights = !1),
          this.setValues(e);
      }
      function Na(e, t, r) {
        1 === r &&
          console.error(
            'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.',
          ),
          kr.call(this),
          (this.type = 'Line'),
          (this.geometry = void 0 !== e ? e : new sn()),
          (this.material = void 0 !== t ? t : new Ba({ color: 16777215 * Math.random() }));
      }
      function Ua(e, t) {
        Na.call(this, e, t), (this.type = 'LineSegments');
      }
      function Ga(e, t) {
        Na.call(this, e, t), (this.type = 'LineLoop');
      }
      function Fa(e) {
        En.call(this),
          (this.type = 'PointsMaterial'),
          (this.color = new Lr(16777215)),
          (this.map = null),
          (this.size = 1),
          (this.sizeAttenuation = !0),
          (this.morphTargets = !1),
          (this.lights = !1),
          this.setValues(e);
      }
      function za(e, t) {
        kr.call(this),
          (this.type = 'Points'),
          (this.geometry = void 0 !== e ? e : new sn()),
          (this.material = void 0 !== t ? t : new Fa({ color: 16777215 * Math.random() }));
      }
      function Ha(e, t, r, n, i, a, o, s, c) {
        lr.call(this, e, t, r, n, i, a, o, s, c),
          (this.format = void 0 !== o ? o : Ze),
          (this.minFilter = void 0 !== a ? a : De),
          (this.magFilter = void 0 !== i ? i : De),
          (this.generateMipmaps = !1);
      }
      function ka(e, t, r, n, i, a, o, s, c, u, l, h) {
        lr.call(this, null, a, o, s, c, u, n, i, l, h),
          (this.image = { width: t, height: r }),
          (this.mipmaps = e),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
      function Va(e, t, r, n, i, a, o, s, c) {
        lr.call(this, e, t, r, n, i, a, o, s, c), (this.needsUpdate = !0);
      }
      function ja(e, t, r, n, i, a, o, s, c, u) {
        if ((u = void 0 !== u ? u : tt) !== tt && u !== rt)
          throw new Error(
            'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',
          );
        void 0 === r && u === tt && (r = ze),
          void 0 === r && u === rt && (r = Ye),
          lr.call(this, null, n, i, a, o, s, u, r, c),
          (this.image = { width: e, height: t }),
          (this.magFilter = void 0 !== o ? o : Pe),
          (this.minFilter = void 0 !== s ? s : Pe),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
      function Wa(e) {
        sn.call(this), (this.type = 'WireframeGeometry');
        var t,
          r,
          n,
          i,
          a,
          o,
          s,
          c,
          u,
          l,
          h = [],
          d = [0, 0],
          p = {},
          f = ['a', 'b', 'c'];
        if (e && e.isGeometry) {
          var m = e.faces;
          for (t = 0, n = m.length; t < n; t++) {
            var v = m[t];
            for (r = 0; r < 3; r++)
              (s = v[f[r]]),
                (c = v[f[(r + 1) % 3]]),
                (d[0] = Math.min(s, c)),
                (d[1] = Math.max(s, c)),
                void 0 === p[(u = d[0] + ',' + d[1])] && (p[u] = { index1: d[0], index2: d[1] });
          }
          for (u in p)
            (o = p[u]),
              (l = e.vertices[o.index1]),
              h.push(l.x, l.y, l.z),
              (l = e.vertices[o.index2]),
              h.push(l.x, l.y, l.z);
        } else if (e && e.isBufferGeometry) {
          var g, y, x, b, w, _, M;
          if (((l = new tr()), null !== e.index)) {
            for (
              g = e.attributes.position,
                y = e.index,
                0 === (x = e.groups).length &&
                  (x = [{ start: 0, count: y.count, materialIndex: 0 }]),
                i = 0,
                a = x.length;
              i < a;
              ++i
            )
              for (t = w = (b = x[i]).start, n = w + b.count; t < n; t += 3)
                for (r = 0; r < 3; r++)
                  (s = y.getX(t + r)),
                    (c = y.getX(t + ((r + 1) % 3))),
                    (d[0] = Math.min(s, c)),
                    (d[1] = Math.max(s, c)),
                    void 0 === p[(u = d[0] + ',' + d[1])] &&
                      (p[u] = { index1: d[0], index2: d[1] });
            for (u in p)
              (o = p[u]),
                l.fromBufferAttribute(g, o.index1),
                h.push(l.x, l.y, l.z),
                l.fromBufferAttribute(g, o.index2),
                h.push(l.x, l.y, l.z);
          } else
            for (t = 0, n = (g = e.attributes.position).count / 3; t < n; t++)
              for (r = 0; r < 3; r++)
                (_ = 3 * t + r),
                  l.fromBufferAttribute(g, _),
                  h.push(l.x, l.y, l.z),
                  (M = 3 * t + ((r + 1) % 3)),
                  l.fromBufferAttribute(g, M),
                  h.push(l.x, l.y, l.z);
        }
        this.addAttribute('position', new tn(h, 3));
      }
      function qa(e, t, r) {
        qr.call(this),
          (this.type = 'ParametricGeometry'),
          (this.parameters = { func: e, slices: t, stacks: r }),
          this.fromBufferGeometry(new Xa(e, t, r)),
          this.mergeVertices();
      }
      function Xa(e, t, r) {
        sn.call(this),
          (this.type = 'ParametricBufferGeometry'),
          (this.parameters = { func: e, slices: t, stacks: r });
        var n,
          i,
          a = [],
          o = [],
          s = [],
          c = [],
          u = new tr(),
          l = new tr(),
          h = new tr(),
          d = new tr(),
          p = new tr();
        e.length < 3 &&
          console.error(
            'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.',
          );
        var f = t + 1;
        for (n = 0; n <= r; n++) {
          var m = n / r;
          for (i = 0; i <= t; i++) {
            var v = i / t;
            e(v, m, l),
              o.push(l.x, l.y, l.z),
              v - 1e-5 >= 0
                ? (e(v - 1e-5, m, h), d.subVectors(l, h))
                : (e(v + 1e-5, m, h), d.subVectors(h, l)),
              m - 1e-5 >= 0
                ? (e(v, m - 1e-5, h), p.subVectors(l, h))
                : (e(v, m + 1e-5, h), p.subVectors(h, l)),
              u.crossVectors(d, p).normalize(),
              s.push(u.x, u.y, u.z),
              c.push(v, m);
          }
        }
        for (n = 0; n < r; n++)
          for (i = 0; i < t; i++) {
            var g = n * f + i,
              y = n * f + i + 1,
              x = (n + 1) * f + i + 1,
              b = (n + 1) * f + i;
            a.push(g, y, b), a.push(y, x, b);
          }
        this.setIndex(a),
          this.addAttribute('position', new tn(o, 3)),
          this.addAttribute('normal', new tn(s, 3)),
          this.addAttribute('uv', new tn(c, 2));
      }
      function Ya(e, t, r, n) {
        qr.call(this),
          (this.type = 'PolyhedronGeometry'),
          (this.parameters = { vertices: e, indices: t, radius: r, detail: n }),
          this.fromBufferGeometry(new Ja(e, t, r, n)),
          this.mergeVertices();
      }
      function Ja(e, t, r, n) {
        sn.call(this),
          (this.type = 'PolyhedronBufferGeometry'),
          (this.parameters = { vertices: e, indices: t, radius: r, detail: n }),
          (r = r || 1);
        var i = [],
          a = [];
        function o(e, t, r, n) {
          var i,
            a,
            o = Math.pow(2, n),
            c = [];
          for (i = 0; i <= o; i++) {
            c[i] = [];
            var u = e.clone().lerp(r, i / o),
              l = t.clone().lerp(r, i / o),
              h = o - i;
            for (a = 0; a <= h; a++) c[i][a] = 0 === a && i === o ? u : u.clone().lerp(l, a / h);
          }
          for (i = 0; i < o; i++)
            for (a = 0; a < 2 * (o - i) - 1; a++) {
              var d = Math.floor(a / 2);
              a % 2 == 0
                ? (s(c[i][d + 1]), s(c[i + 1][d]), s(c[i][d]))
                : (s(c[i][d + 1]), s(c[i + 1][d + 1]), s(c[i + 1][d]));
            }
        }
        function s(e) {
          i.push(e.x, e.y, e.z);
        }
        function c(t, r) {
          var n = 3 * t;
          (r.x = e[n + 0]), (r.y = e[n + 1]), (r.z = e[n + 2]);
        }
        function u(e, t, r, n) {
          n < 0 && 1 === e.x && (a[t] = e.x - 1),
            0 === r.x && 0 === r.z && (a[t] = n / 2 / Math.PI + 0.5);
        }
        function l(e) {
          return Math.atan2(e.z, -e.x);
        }
        !(function (e) {
          for (var r = new tr(), n = new tr(), i = new tr(), a = 0; a < t.length; a += 3)
            c(t[a + 0], r), c(t[a + 1], n), c(t[a + 2], i), o(r, n, i, e);
        })((n = n || 0)),
          (function (e) {
            for (var t = new tr(), r = 0; r < i.length; r += 3)
              (t.x = i[r + 0]),
                (t.y = i[r + 1]),
                (t.z = i[r + 2]),
                t.normalize().multiplyScalar(e),
                (i[r + 0] = t.x),
                (i[r + 1] = t.y),
                (i[r + 2] = t.z);
          })(r),
          (function () {
            for (var e = new tr(), t = 0; t < i.length; t += 3) {
              (e.x = i[t + 0]), (e.y = i[t + 1]), (e.z = i[t + 2]);
              var r = l(e) / 2 / Math.PI + 0.5,
                n = ((o = e), Math.atan2(-o.y, Math.sqrt(o.x * o.x + o.z * o.z)) / Math.PI + 0.5);
              a.push(r, 1 - n);
            }
            var o;
            (function () {
              for (
                var e = new tr(),
                  t = new tr(),
                  r = new tr(),
                  n = new tr(),
                  o = new Qt(),
                  s = new Qt(),
                  c = new Qt(),
                  h = 0,
                  d = 0;
                h < i.length;
                h += 9, d += 6
              ) {
                e.set(i[h + 0], i[h + 1], i[h + 2]),
                  t.set(i[h + 3], i[h + 4], i[h + 5]),
                  r.set(i[h + 6], i[h + 7], i[h + 8]),
                  o.set(a[d + 0], a[d + 1]),
                  s.set(a[d + 2], a[d + 3]),
                  c.set(a[d + 4], a[d + 5]),
                  n.copy(e).add(t).add(r).divideScalar(3);
                var p = l(n);
                u(o, d + 0, e, p), u(s, d + 2, t, p), u(c, d + 4, r, p);
              }
            })(),
              (function () {
                for (var e = 0; e < a.length; e += 6) {
                  var t = a[e + 0],
                    r = a[e + 2],
                    n = a[e + 4],
                    i = Math.max(t, r, n),
                    o = Math.min(t, r, n);
                  i > 0.9 &&
                    o < 0.1 &&
                    (t < 0.2 && (a[e + 0] += 1),
                    r < 0.2 && (a[e + 2] += 1),
                    n < 0.2 && (a[e + 4] += 1));
                }
              })();
          })(),
          this.addAttribute('position', new tn(i, 3)),
          this.addAttribute('normal', new tn(i.slice(), 3)),
          this.addAttribute('uv', new tn(a, 2)),
          0 === n ? this.computeVertexNormals() : this.normalizeNormals();
      }
      function Za(e, t) {
        qr.call(this),
          (this.type = 'TetrahedronGeometry'),
          (this.parameters = { radius: e, detail: t }),
          this.fromBufferGeometry(new Ka(e, t)),
          this.mergeVertices();
      }
      function Ka(e, t) {
        Ja.call(
          this,
          [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
          [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
          e,
          t,
        ),
          (this.type = 'TetrahedronBufferGeometry'),
          (this.parameters = { radius: e, detail: t });
      }
      function Qa(e, t) {
        qr.call(this),
          (this.type = 'OctahedronGeometry'),
          (this.parameters = { radius: e, detail: t }),
          this.fromBufferGeometry(new $a(e, t)),
          this.mergeVertices();
      }
      function $a(e, t) {
        Ja.call(
          this,
          [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
          [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
          e,
          t,
        ),
          (this.type = 'OctahedronBufferGeometry'),
          (this.parameters = { radius: e, detail: t });
      }
      function eo(e, t) {
        qr.call(this),
          (this.type = 'IcosahedronGeometry'),
          (this.parameters = { radius: e, detail: t }),
          this.fromBufferGeometry(new to(e, t)),
          this.mergeVertices();
      }
      function to(e, t) {
        var r = (1 + Math.sqrt(5)) / 2,
          n = [
            -1,
            r,
            0,
            1,
            r,
            0,
            -1,
            -r,
            0,
            1,
            -r,
            0,
            0,
            -1,
            r,
            0,
            1,
            r,
            0,
            -1,
            -r,
            0,
            1,
            -r,
            r,
            0,
            -1,
            r,
            0,
            1,
            -r,
            0,
            -1,
            -r,
            0,
            1,
          ];
        Ja.call(
          this,
          n,
          [
            0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6,
            7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6,
            7, 9, 8, 1,
          ],
          e,
          t,
        ),
          (this.type = 'IcosahedronBufferGeometry'),
          (this.parameters = { radius: e, detail: t });
      }
      function ro(e, t) {
        qr.call(this),
          (this.type = 'DodecahedronGeometry'),
          (this.parameters = { radius: e, detail: t }),
          this.fromBufferGeometry(new no(e, t)),
          this.mergeVertices();
      }
      function no(e, t) {
        var r = (1 + Math.sqrt(5)) / 2,
          n = 1 / r,
          i = [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -n,
            -r,
            0,
            -n,
            r,
            0,
            n,
            -r,
            0,
            n,
            r,
            -n,
            -r,
            0,
            -n,
            r,
            0,
            n,
            -r,
            0,
            n,
            r,
            0,
            -r,
            0,
            -n,
            r,
            0,
            -n,
            -r,
            0,
            n,
            r,
            0,
            n,
          ];
        Ja.call(
          this,
          i,
          [
            3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17,
            10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13,
            6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4,
            12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12,
            14, 1, 14, 5, 1, 5, 9,
          ],
          e,
          t,
        ),
          (this.type = 'DodecahedronBufferGeometry'),
          (this.parameters = { radius: e, detail: t });
      }
      function io(e, t, r, n, i, a) {
        qr.call(this),
          (this.type = 'TubeGeometry'),
          (this.parameters = {
            path: e,
            tubularSegments: t,
            radius: r,
            radialSegments: n,
            closed: i,
          }),
          void 0 !== a && console.warn('THREE.TubeGeometry: taper has been removed.');
        var o = new ao(e, t, r, n, i);
        (this.tangents = o.tangents),
          (this.normals = o.normals),
          (this.binormals = o.binormals),
          this.fromBufferGeometry(o),
          this.mergeVertices();
      }
      function ao(e, t, r, n, i) {
        sn.call(this),
          (this.type = 'TubeBufferGeometry'),
          (this.parameters = {
            path: e,
            tubularSegments: t,
            radius: r,
            radialSegments: n,
            closed: i,
          }),
          (t = t || 64),
          (r = r || 1),
          (n = n || 8),
          (i = i || !1);
        var a = e.computeFrenetFrames(t, i);
        (this.tangents = a.tangents), (this.normals = a.normals), (this.binormals = a.binormals);
        var o,
          s,
          c = new tr(),
          u = new tr(),
          l = new Qt(),
          h = new tr(),
          d = [],
          p = [],
          f = [],
          m = [];
        function v(i) {
          h = e.getPointAt(i / t, h);
          var o = a.normals[i],
            l = a.binormals[i];
          for (s = 0; s <= n; s++) {
            var f = (s / n) * Math.PI * 2,
              m = Math.sin(f),
              v = -Math.cos(f);
            (u.x = v * o.x + m * l.x),
              (u.y = v * o.y + m * l.y),
              (u.z = v * o.z + m * l.z),
              u.normalize(),
              p.push(u.x, u.y, u.z),
              (c.x = h.x + r * u.x),
              (c.y = h.y + r * u.y),
              (c.z = h.z + r * u.z),
              d.push(c.x, c.y, c.z);
          }
        }
        !(function () {
          for (o = 0; o < t; o++) v(o);
          v(!1 === i ? t : 0),
            (function () {
              for (o = 0; o <= t; o++)
                for (s = 0; s <= n; s++) (l.x = o / t), (l.y = s / n), f.push(l.x, l.y);
            })(),
            (function () {
              for (s = 1; s <= t; s++)
                for (o = 1; o <= n; o++) {
                  var e = (n + 1) * (s - 1) + (o - 1),
                    r = (n + 1) * s + (o - 1),
                    i = (n + 1) * s + o,
                    a = (n + 1) * (s - 1) + o;
                  m.push(e, r, a), m.push(r, i, a);
                }
            })();
        })(),
          this.setIndex(m),
          this.addAttribute('position', new tn(d, 3)),
          this.addAttribute('normal', new tn(p, 3)),
          this.addAttribute('uv', new tn(f, 2));
      }
      function oo(e, t, r, n, i, a, o) {
        qr.call(this),
          (this.type = 'TorusKnotGeometry'),
          (this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: r,
            radialSegments: n,
            p: i,
            q: a,
          }),
          void 0 !== o &&
            console.warn(
              'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.',
            ),
          this.fromBufferGeometry(new so(e, t, r, n, i, a)),
          this.mergeVertices();
      }
      function so(e, t, r, n, i, a) {
        sn.call(this),
          (this.type = 'TorusKnotBufferGeometry'),
          (this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: r,
            radialSegments: n,
            p: i,
            q: a,
          }),
          (e = e || 1),
          (t = t || 0.4),
          (r = Math.floor(r) || 64),
          (n = Math.floor(n) || 8),
          (i = i || 2),
          (a = a || 3);
        var o,
          s,
          c = [],
          u = [],
          l = [],
          h = [],
          d = new tr(),
          p = new tr(),
          f = new tr(),
          m = new tr(),
          v = new tr(),
          g = new tr(),
          y = new tr();
        for (o = 0; o <= r; ++o) {
          var x = (o / r) * i * Math.PI * 2;
          for (
            A(x, i, a, e, f),
              A(x + 0.01, i, a, e, m),
              g.subVectors(m, f),
              y.addVectors(m, f),
              v.crossVectors(g, y),
              y.crossVectors(v, g),
              v.normalize(),
              y.normalize(),
              s = 0;
            s <= n;
            ++s
          ) {
            var b = (s / n) * Math.PI * 2,
              w = -t * Math.cos(b),
              _ = t * Math.sin(b);
            (d.x = f.x + (w * y.x + _ * v.x)),
              (d.y = f.y + (w * y.y + _ * v.y)),
              (d.z = f.z + (w * y.z + _ * v.z)),
              u.push(d.x, d.y, d.z),
              p.subVectors(d, f).normalize(),
              l.push(p.x, p.y, p.z),
              h.push(o / r),
              h.push(s / n);
          }
        }
        for (s = 1; s <= r; s++)
          for (o = 1; o <= n; o++) {
            var M = (n + 1) * (s - 1) + (o - 1),
              S = (n + 1) * s + (o - 1),
              E = (n + 1) * s + o,
              T = (n + 1) * (s - 1) + o;
            c.push(M, S, T), c.push(S, E, T);
          }
        function A(e, t, r, n, i) {
          var a = Math.cos(e),
            o = Math.sin(e),
            s = (r / t) * e,
            c = Math.cos(s);
          (i.x = n * (2 + c) * 0.5 * a),
            (i.y = n * (2 + c) * o * 0.5),
            (i.z = n * Math.sin(s) * 0.5);
        }
        this.setIndex(c),
          this.addAttribute('position', new tn(u, 3)),
          this.addAttribute('normal', new tn(l, 3)),
          this.addAttribute('uv', new tn(h, 2));
      }
      function co(e, t, r, n, i) {
        qr.call(this),
          (this.type = 'TorusGeometry'),
          (this.parameters = { radius: e, tube: t, radialSegments: r, tubularSegments: n, arc: i }),
          this.fromBufferGeometry(new uo(e, t, r, n, i)),
          this.mergeVertices();
      }
      function uo(e, t, r, n, i) {
        sn.call(this),
          (this.type = 'TorusBufferGeometry'),
          (this.parameters = { radius: e, tube: t, radialSegments: r, tubularSegments: n, arc: i }),
          (e = e || 1),
          (t = t || 0.4),
          (r = Math.floor(r) || 8),
          (n = Math.floor(n) || 6),
          (i = i || 2 * Math.PI);
        var a,
          o,
          s = [],
          c = [],
          u = [],
          l = [],
          h = new tr(),
          d = new tr(),
          p = new tr();
        for (a = 0; a <= r; a++)
          for (o = 0; o <= n; o++) {
            var f = (o / n) * i,
              m = (a / r) * Math.PI * 2;
            (d.x = (e + t * Math.cos(m)) * Math.cos(f)),
              (d.y = (e + t * Math.cos(m)) * Math.sin(f)),
              (d.z = t * Math.sin(m)),
              c.push(d.x, d.y, d.z),
              (h.x = e * Math.cos(f)),
              (h.y = e * Math.sin(f)),
              p.subVectors(d, h).normalize(),
              u.push(p.x, p.y, p.z),
              l.push(o / n),
              l.push(a / r);
          }
        for (a = 1; a <= r; a++)
          for (o = 1; o <= n; o++) {
            var v = (n + 1) * a + o - 1,
              g = (n + 1) * (a - 1) + o - 1,
              y = (n + 1) * (a - 1) + o,
              x = (n + 1) * a + o;
            s.push(v, g, x), s.push(g, y, x);
          }
        this.setIndex(s),
          this.addAttribute('position', new tn(c, 3)),
          this.addAttribute('normal', new tn(u, 3)),
          this.addAttribute('uv', new tn(l, 2));
      }
      (Sa.prototype.isFogExp2 = !0),
        (Sa.prototype.clone = function () {
          return new Sa(this.color, this.density);
        }),
        (Sa.prototype.toJSON = function () {
          return { type: 'FogExp2', color: this.color.getHex(), density: this.density };
        }),
        (Ea.prototype.isFog = !0),
        (Ea.prototype.clone = function () {
          return new Ea(this.color, this.near, this.far);
        }),
        (Ea.prototype.toJSON = function () {
          return { type: 'Fog', color: this.color.getHex(), near: this.near, far: this.far };
        }),
        (Ta.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: Ta,
          isScene: !0,
          copy: function (e, t) {
            return (
              kr.prototype.copy.call(this, e, t),
              null !== e.background && (this.background = e.background.clone()),
              null !== e.fog && (this.fog = e.fog.clone()),
              null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
              (this.autoUpdate = e.autoUpdate),
              (this.matrixAutoUpdate = e.matrixAutoUpdate),
              this
            );
          },
          toJSON: function (e) {
            var t = kr.prototype.toJSON.call(this, e);
            return (
              null !== this.background && (t.object.background = this.background.toJSON(e)),
              null !== this.fog && (t.object.fog = this.fog.toJSON()),
              t
            );
          },
          dispose: function () {
            this.dispatchEvent({ type: 'dispose' });
          },
        })),
        Object.defineProperty(Aa.prototype, 'needsUpdate', {
          set: function (e) {
            !0 === e && this.version++;
          },
        }),
        Object.assign(Aa.prototype, {
          isInterleavedBuffer: !0,
          onUploadCallback: function () {},
          setArray: function (e) {
            if (Array.isArray(e))
              throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            return (this.count = void 0 !== e ? e.length / this.stride : 0), (this.array = e), this;
          },
          setDynamic: function (e) {
            return (this.dynamic = e), this;
          },
          copy: function (e) {
            return (
              (this.array = new e.array.constructor(e.array)),
              (this.count = e.count),
              (this.stride = e.stride),
              (this.dynamic = e.dynamic),
              this
            );
          },
          copyAt: function (e, t, r) {
            (e *= this.stride), (r *= t.stride);
            for (var n = 0, i = this.stride; n < i; n++) this.array[e + n] = t.array[r + n];
            return this;
          },
          set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          onUpload: function (e) {
            return (this.onUploadCallback = e), this;
          },
        }),
        Object.defineProperties(La.prototype, {
          count: {
            get: function () {
              return this.data.count;
            },
          },
          array: {
            get: function () {
              return this.data.array;
            },
          },
        }),
        Object.assign(La.prototype, {
          isInterleavedBufferAttribute: !0,
          setX: function (e, t) {
            return (this.data.array[e * this.data.stride + this.offset] = t), this;
          },
          setY: function (e, t) {
            return (this.data.array[e * this.data.stride + this.offset + 1] = t), this;
          },
          setZ: function (e, t) {
            return (this.data.array[e * this.data.stride + this.offset + 2] = t), this;
          },
          setW: function (e, t) {
            return (this.data.array[e * this.data.stride + this.offset + 3] = t), this;
          },
          getX: function (e) {
            return this.data.array[e * this.data.stride + this.offset];
          },
          getY: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 1];
          },
          getZ: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 2];
          },
          getW: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 3];
          },
          setXY: function (e, t, r) {
            return (
              (e = e * this.data.stride + this.offset),
              (this.data.array[e + 0] = t),
              (this.data.array[e + 1] = r),
              this
            );
          },
          setXYZ: function (e, t, r, n) {
            return (
              (e = e * this.data.stride + this.offset),
              (this.data.array[e + 0] = t),
              (this.data.array[e + 1] = r),
              (this.data.array[e + 2] = n),
              this
            );
          },
          setXYZW: function (e, t, r, n, i) {
            return (
              (e = e * this.data.stride + this.offset),
              (this.data.array[e + 0] = t),
              (this.data.array[e + 1] = r),
              (this.data.array[e + 2] = n),
              (this.data.array[e + 3] = i),
              this
            );
          },
        }),
        (Ra.prototype = Object.create(En.prototype)),
        (Ra.prototype.constructor = Ra),
        (Ra.prototype.isSpriteMaterial = !0),
        (Ra.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            this
          );
        }),
        (Ca.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: Ca,
          isSprite: !0,
          raycast: (function () {
            var e = new tr(),
              t = new tr(),
              r = new tr(),
              n = new Qt(),
              i = new Qt(),
              a = new $t(),
              o = new tr(),
              s = new tr(),
              c = new tr(),
              u = new Qt(),
              l = new Qt(),
              h = new Qt();
            function d(e, t, r, o, s, c) {
              n.subVectors(e, r).addScalar(0.5).multiply(o),
                void 0 !== s ? ((i.x = c * n.x - s * n.y), (i.y = s * n.x + c * n.y)) : i.copy(n),
                e.copy(t),
                (e.x += i.x),
                (e.y += i.y),
                e.applyMatrix4(a);
            }
            return function (n, i) {
              t.setFromMatrixScale(this.matrixWorld),
                a.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld),
                r.setFromMatrixPosition(this.modelViewMatrix);
              var p,
                f,
                m = this.material.rotation;
              0 !== m && ((f = Math.cos(m)), (p = Math.sin(m)));
              var v = this.center;
              d(o.set(-0.5, -0.5, 0), r, v, t, p, f),
                d(s.set(0.5, -0.5, 0), r, v, t, p, f),
                d(c.set(0.5, 0.5, 0), r, v, t, p, f),
                u.set(0, 0),
                l.set(1, 0),
                h.set(1, 1);
              var g = n.ray.intersectTriangle(o, s, c, !1, e);
              if (
                null !== g ||
                (d(s.set(-0.5, 0.5, 0), r, v, t, p, f),
                l.set(0, 1),
                null !== (g = n.ray.intersectTriangle(o, c, s, !1, e)))
              ) {
                var y = n.ray.origin.distanceTo(e);
                y < n.near ||
                  y > n.far ||
                  i.push({
                    distance: y,
                    point: e.clone(),
                    uv: Ln.getUV(e, o, s, c, u, l, h, new Qt()),
                    face: null,
                    object: this,
                  });
              }
            };
          })(),
          clone: function () {
            return new this.constructor(this.material).copy(this);
          },
          copy: function (e) {
            return (
              kr.prototype.copy.call(this, e),
              void 0 !== e.center && this.center.copy(e.center),
              this
            );
          },
        })),
        (Pa.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: Pa,
          copy: function (e) {
            kr.prototype.copy.call(this, e, !1);
            for (var t = e.levels, r = 0, n = t.length; r < n; r++) {
              var i = t[r];
              this.addLevel(i.object.clone(), i.distance);
            }
            return this;
          },
          addLevel: function (e, t) {
            void 0 === t && (t = 0), (t = Math.abs(t));
            for (var r = this.levels, n = 0; n < r.length && !(t < r[n].distance); n++);
            r.splice(n, 0, { distance: t, object: e }), this.add(e);
          },
          getObjectForDistance: function (e) {
            for (var t = this.levels, r = 1, n = t.length; r < n && !(e < t[r].distance); r++);
            return t[r - 1].object;
          },
          raycast:
            ((pa = new tr()),
            function (e, t) {
              pa.setFromMatrixPosition(this.matrixWorld);
              var r = e.ray.origin.distanceTo(pa);
              this.getObjectForDistance(r).raycast(e, t);
            }),
          update: (function () {
            var e = new tr(),
              t = new tr();
            return function (r) {
              var n = this.levels;
              if (n.length > 1) {
                e.setFromMatrixPosition(r.matrixWorld), t.setFromMatrixPosition(this.matrixWorld);
                var i = e.distanceTo(t);
                n[0].object.visible = !0;
                for (var a = 1, o = n.length; a < o && i >= n[a].distance; a++)
                  (n[a - 1].object.visible = !1), (n[a].object.visible = !0);
                for (; a < o; a++) n[a].object.visible = !1;
              }
            };
          })(),
          toJSON: function (e) {
            var t = kr.prototype.toJSON.call(this, e);
            t.object.levels = [];
            for (var r = this.levels, n = 0, i = r.length; n < i; n++) {
              var a = r[n];
              t.object.levels.push({ object: a.object.uuid, distance: a.distance });
            }
            return t;
          },
        })),
        (Oa.prototype = Object.assign(Object.create(Cn.prototype), {
          constructor: Oa,
          isSkinnedMesh: !0,
          bind: function (e, t) {
            (this.skeleton = e),
              void 0 === t &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (t = this.matrixWorld)),
              this.bindMatrix.copy(t),
              this.bindMatrixInverse.getInverse(t);
          },
          pose: function () {
            this.skeleton.pose();
          },
          normalizeSkinWeights: function () {
            for (
              var e = new hr(), t = this.geometry.attributes.skinWeight, r = 0, n = t.count;
              r < n;
              r++
            ) {
              (e.x = t.getX(r)), (e.y = t.getY(r)), (e.z = t.getZ(r)), (e.w = t.getW(r));
              var i = 1 / e.manhattanLength();
              i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
                t.setXYZW(r, e.x, e.y, e.z, e.w);
            }
          },
          updateMatrixWorld: function (e) {
            Cn.prototype.updateMatrixWorld.call(this, e),
              'attached' === this.bindMode
                ? this.bindMatrixInverse.getInverse(this.matrixWorld)
                : 'detached' === this.bindMode
                ? this.bindMatrixInverse.getInverse(this.bindMatrix)
                : console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
          },
          clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this);
          },
        })),
        Object.assign(Ia.prototype, {
          calculateInverses: function () {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
              var r = new $t();
              this.bones[e] && r.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(r);
            }
          },
          pose: function () {
            var e, t, r;
            for (t = 0, r = this.bones.length; t < r; t++)
              (e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
            for (t = 0, r = this.bones.length; t < r; t++)
              (e = this.bones[t]) &&
                (e.parent && e.parent.isBone
                  ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld))
                  : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale));
          },
          update:
            ((fa = new $t()),
            (ma = new $t()),
            function () {
              for (
                var e = this.bones,
                  t = this.boneInverses,
                  r = this.boneMatrices,
                  n = this.boneTexture,
                  i = 0,
                  a = e.length;
                i < a;
                i++
              ) {
                var o = e[i] ? e[i].matrixWorld : ma;
                fa.multiplyMatrices(o, t[i]), fa.toArray(r, 16 * i);
              }
              void 0 !== n && (n.needsUpdate = !0);
            }),
          clone: function () {
            return new Ia(this.bones, this.boneInverses);
          },
          getBoneByName: function (e) {
            for (var t = 0, r = this.bones.length; t < r; t++) {
              var n = this.bones[t];
              if (n.name === e) return n;
            }
          },
        }),
        (Da.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: Da,
          isBone: !0,
        })),
        (Ba.prototype = Object.create(En.prototype)),
        (Ba.prototype.constructor = Ba),
        (Ba.prototype.isLineBasicMaterial = !0),
        (Ba.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            this
          );
        }),
        (Na.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: Na,
          isLine: !0,
          computeLineDistances:
            ((va = new tr()),
            (ga = new tr()),
            function () {
              var e = this.geometry;
              if (e.isBufferGeometry)
                if (null === e.index) {
                  for (var t = e.attributes.position, r = [0], n = 1, i = t.count; n < i; n++)
                    va.fromBufferAttribute(t, n - 1),
                      ga.fromBufferAttribute(t, n),
                      (r[n] = r[n - 1]),
                      (r[n] += va.distanceTo(ga));
                  e.addAttribute('lineDistance', new tn(r, 1));
                } else
                  console.warn(
                    'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
                  );
              else if (e.isGeometry) {
                var a = e.vertices;
                for ((r = e.lineDistances)[0] = 0, n = 1, i = a.length; n < i; n++)
                  (r[n] = r[n - 1]), (r[n] += a[n - 1].distanceTo(a[n]));
              }
              return this;
            }),
          raycast: (function () {
            var e = new $t(),
              t = new An(),
              r = new gr();
            return function (n, i) {
              var a = n.linePrecision,
                o = this.geometry,
                s = this.matrixWorld;
              if (
                (null === o.boundingSphere && o.computeBoundingSphere(),
                r.copy(o.boundingSphere),
                r.applyMatrix4(s),
                (r.radius += a),
                !1 !== n.ray.intersectsSphere(r))
              ) {
                e.getInverse(s), t.copy(n.ray).applyMatrix4(e);
                var c = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                  u = c * c,
                  l = new tr(),
                  h = new tr(),
                  d = new tr(),
                  p = new tr(),
                  f = this && this.isLineSegments ? 2 : 1;
                if (o.isBufferGeometry) {
                  var m = o.index,
                    v = o.attributes.position.array;
                  if (null !== m)
                    for (var g = m.array, y = 0, x = g.length - 1; y < x; y += f) {
                      var b = g[y],
                        w = g[y + 1];
                      if (
                        (l.fromArray(v, 3 * b),
                        h.fromArray(v, 3 * w),
                        !(t.distanceSqToSegment(l, h, p, d) > u))
                      )
                        p.applyMatrix4(this.matrixWorld),
                          (S = n.ray.origin.distanceTo(p)) < n.near ||
                            S > n.far ||
                            i.push({
                              distance: S,
                              point: d.clone().applyMatrix4(this.matrixWorld),
                              index: y,
                              face: null,
                              faceIndex: null,
                              object: this,
                            });
                    }
                  else
                    for (y = 0, x = v.length / 3 - 1; y < x; y += f) {
                      if (
                        (l.fromArray(v, 3 * y),
                        h.fromArray(v, 3 * y + 3),
                        !(t.distanceSqToSegment(l, h, p, d) > u))
                      )
                        p.applyMatrix4(this.matrixWorld),
                          (S = n.ray.origin.distanceTo(p)) < n.near ||
                            S > n.far ||
                            i.push({
                              distance: S,
                              point: d.clone().applyMatrix4(this.matrixWorld),
                              index: y,
                              face: null,
                              faceIndex: null,
                              object: this,
                            });
                    }
                } else if (o.isGeometry) {
                  var _ = o.vertices,
                    M = _.length;
                  for (y = 0; y < M - 1; y += f) {
                    var S;
                    if (!(t.distanceSqToSegment(_[y], _[y + 1], p, d) > u))
                      p.applyMatrix4(this.matrixWorld),
                        (S = n.ray.origin.distanceTo(p)) < n.near ||
                          S > n.far ||
                          i.push({
                            distance: S,
                            point: d.clone().applyMatrix4(this.matrixWorld),
                            index: y,
                            face: null,
                            faceIndex: null,
                            object: this,
                          });
                  }
                }
              }
            };
          })(),
          copy: function (e) {
            return (
              kr.prototype.copy.call(this, e),
              this.geometry.copy(e.geometry),
              this.material.copy(e.material),
              this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
        })),
        (Ua.prototype = Object.assign(Object.create(Na.prototype), {
          constructor: Ua,
          isLineSegments: !0,
          computeLineDistances: (function () {
            var e = new tr(),
              t = new tr();
            return function () {
              var r = this.geometry;
              if (r.isBufferGeometry)
                if (null === r.index) {
                  for (var n = r.attributes.position, i = [], a = 0, o = n.count; a < o; a += 2)
                    e.fromBufferAttribute(n, a),
                      t.fromBufferAttribute(n, a + 1),
                      (i[a] = 0 === a ? 0 : i[a - 1]),
                      (i[a + 1] = i[a] + e.distanceTo(t));
                  r.addAttribute('lineDistance', new tn(i, 1));
                } else
                  console.warn(
                    'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
                  );
              else if (r.isGeometry) {
                var s = r.vertices;
                for (i = r.lineDistances, a = 0, o = s.length; a < o; a += 2)
                  e.copy(s[a]),
                    t.copy(s[a + 1]),
                    (i[a] = 0 === a ? 0 : i[a - 1]),
                    (i[a + 1] = i[a] + e.distanceTo(t));
              }
              return this;
            };
          })(),
        })),
        (Ga.prototype = Object.assign(Object.create(Na.prototype), {
          constructor: Ga,
          isLineLoop: !0,
        })),
        (Fa.prototype = Object.create(En.prototype)),
        (Fa.prototype.constructor = Fa),
        (Fa.prototype.isPointsMaterial = !0),
        (Fa.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.morphTargets = e.morphTargets),
            this
          );
        }),
        (za.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: za,
          isPoints: !0,
          raycast: (function () {
            var e = new $t(),
              t = new An(),
              r = new gr();
            return function (n, i) {
              var a = this,
                o = this.geometry,
                s = this.matrixWorld,
                c = n.params.Points.threshold;
              if (
                (null === o.boundingSphere && o.computeBoundingSphere(),
                r.copy(o.boundingSphere),
                r.applyMatrix4(s),
                (r.radius += c),
                !1 !== n.ray.intersectsSphere(r))
              ) {
                e.getInverse(s), t.copy(n.ray).applyMatrix4(e);
                var u = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                  l = u * u,
                  h = new tr(),
                  d = new tr();
                if (o.isBufferGeometry) {
                  var p = o.index,
                    f = o.attributes.position.array;
                  if (null !== p)
                    for (var m = p.array, v = 0, g = m.length; v < g; v++) {
                      var y = m[v];
                      h.fromArray(f, 3 * y), w(h, y);
                    }
                  else {
                    v = 0;
                    for (var x = f.length / 3; v < x; v++) h.fromArray(f, 3 * v), w(h, v);
                  }
                } else {
                  var b = o.vertices;
                  for (v = 0, x = b.length; v < x; v++) w(b[v], v);
                }
              }
              function w(e, r) {
                var o = t.distanceSqToPoint(e);
                if (o < l) {
                  t.closestPointToPoint(e, d), d.applyMatrix4(s);
                  var c = n.ray.origin.distanceTo(d);
                  if (c < n.near || c > n.far) return;
                  i.push({
                    distance: c,
                    distanceToRay: Math.sqrt(o),
                    point: d.clone(),
                    index: r,
                    face: null,
                    object: a,
                  });
                }
              }
            };
          })(),
          clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this);
          },
        })),
        (Ha.prototype = Object.assign(Object.create(lr.prototype), {
          constructor: Ha,
          isVideoTexture: !0,
          update: function () {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
          },
        })),
        (ka.prototype = Object.create(lr.prototype)),
        (ka.prototype.constructor = ka),
        (ka.prototype.isCompressedTexture = !0),
        (Va.prototype = Object.create(lr.prototype)),
        (Va.prototype.constructor = Va),
        (Va.prototype.isCanvasTexture = !0),
        (ja.prototype = Object.create(lr.prototype)),
        (ja.prototype.constructor = ja),
        (ja.prototype.isDepthTexture = !0),
        (Wa.prototype = Object.create(sn.prototype)),
        (Wa.prototype.constructor = Wa),
        (qa.prototype = Object.create(qr.prototype)),
        (qa.prototype.constructor = qa),
        (Xa.prototype = Object.create(sn.prototype)),
        (Xa.prototype.constructor = Xa),
        (Ya.prototype = Object.create(qr.prototype)),
        (Ya.prototype.constructor = Ya),
        (Ja.prototype = Object.create(sn.prototype)),
        (Ja.prototype.constructor = Ja),
        (Za.prototype = Object.create(qr.prototype)),
        (Za.prototype.constructor = Za),
        (Ka.prototype = Object.create(Ja.prototype)),
        (Ka.prototype.constructor = Ka),
        (Qa.prototype = Object.create(qr.prototype)),
        (Qa.prototype.constructor = Qa),
        ($a.prototype = Object.create(Ja.prototype)),
        ($a.prototype.constructor = $a),
        (eo.prototype = Object.create(qr.prototype)),
        (eo.prototype.constructor = eo),
        (to.prototype = Object.create(Ja.prototype)),
        (to.prototype.constructor = to),
        (ro.prototype = Object.create(qr.prototype)),
        (ro.prototype.constructor = ro),
        (no.prototype = Object.create(Ja.prototype)),
        (no.prototype.constructor = no),
        (io.prototype = Object.create(qr.prototype)),
        (io.prototype.constructor = io),
        (ao.prototype = Object.create(sn.prototype)),
        (ao.prototype.constructor = ao),
        (oo.prototype = Object.create(qr.prototype)),
        (oo.prototype.constructor = oo),
        (so.prototype = Object.create(sn.prototype)),
        (so.prototype.constructor = so),
        (co.prototype = Object.create(qr.prototype)),
        (co.prototype.constructor = co),
        (uo.prototype = Object.create(sn.prototype)),
        (uo.prototype.constructor = uo);
      var lo = function (e, t, r) {
        r = r || 2;
        var n,
          i,
          a,
          o,
          s,
          c,
          u,
          l = t && t.length,
          h = l ? t[0] * r : e.length,
          d = ho(e, 0, h, r, !0),
          p = [];
        if (!d) return p;
        if (
          (l &&
            (d = (function (e, t, r, n) {
              var i,
                a,
                o,
                s,
                c,
                u = [];
              for (i = 0, a = t.length; i < a; i++)
                (o = t[i] * n),
                  (s = i < a - 1 ? t[i + 1] * n : e.length),
                  (c = ho(e, o, s, n, !1)) === c.next && (c.steiner = !0),
                  u.push(_o(c));
              for (u.sort(xo), i = 0; i < u.length; i++) bo(u[i], r), (r = po(r, r.next));
              return r;
            })(e, t, d, r)),
          e.length > 80 * r)
        ) {
          (n = a = e[0]), (i = o = e[1]);
          for (var f = r; f < h; f += r)
            (s = e[f]) < n && (n = s),
              (c = e[f + 1]) < i && (i = c),
              s > a && (a = s),
              c > o && (o = c);
          u = 0 !== (u = Math.max(a - n, o - i)) ? 1 / u : 0;
        }
        return fo(d, p, r, n, i, u), p;
      };
      function ho(e, t, r, n, i) {
        var a, o;
        if (
          i ===
          (function (e, t, r, n) {
            for (var i = 0, a = t, o = r - n; a < r; a += n)
              (i += (e[o] - e[a]) * (e[a + 1] + e[o + 1])), (o = a);
            return i;
          })(e, t, r, n) >
            0
        )
          for (a = t; a < r; a += n) o = Co(a, e[a], e[a + 1], o);
        else for (a = r - n; a >= t; a -= n) o = Co(a, e[a], e[a + 1], o);
        return o && To(o, o.next) && (Po(o), (o = o.next)), o;
      }
      function po(e, t) {
        if (!e) return e;
        t || (t = e);
        var r,
          n = e;
        do {
          if (((r = !1), n.steiner || (!To(n, n.next) && 0 !== Eo(n.prev, n, n.next)))) n = n.next;
          else {
            if ((Po(n), (n = t = n.prev) === n.next)) break;
            r = !0;
          }
        } while (r || n !== t);
        return t;
      }
      function fo(e, t, r, n, i, a, o) {
        if (e) {
          !o &&
            a &&
            (function (e, t, r, n) {
              var i = e;
              do {
                null === i.z && (i.z = wo(i.x, i.y, t, r, n)),
                  (i.prevZ = i.prev),
                  (i.nextZ = i.next),
                  (i = i.next);
              } while (i !== e);
              (i.prevZ.nextZ = null),
                (i.prevZ = null),
                (function (e) {
                  var t,
                    r,
                    n,
                    i,
                    a,
                    o,
                    s,
                    c,
                    u = 1;
                  do {
                    for (r = e, e = null, a = null, o = 0; r; ) {
                      for (o++, n = r, s = 0, t = 0; t < u && (s++, (n = n.nextZ)); t++);
                      for (c = u; s > 0 || (c > 0 && n); )
                        0 !== s && (0 === c || !n || r.z <= n.z)
                          ? ((i = r), (r = r.nextZ), s--)
                          : ((i = n), (n = n.nextZ), c--),
                          a ? (a.nextZ = i) : (e = i),
                          (i.prevZ = a),
                          (a = i);
                      r = n;
                    }
                    (a.nextZ = null), (u *= 2);
                  } while (o > 1);
                })(i);
            })(e, n, i, a);
          for (var s, c, u = e; e.prev !== e.next; )
            if (((s = e.prev), (c = e.next), a ? vo(e, n, i, a) : mo(e)))
              t.push(s.i / r), t.push(e.i / r), t.push(c.i / r), Po(e), (e = c.next), (u = c.next);
            else if ((e = c) === u) {
              o
                ? 1 === o
                  ? fo((e = go(e, t, r)), t, r, n, i, a, 2)
                  : 2 === o && yo(e, t, r, n, i, a)
                : fo(po(e), t, r, n, i, a, 1);
              break;
            }
        }
      }
      function mo(e) {
        var t = e.prev,
          r = e,
          n = e.next;
        if (Eo(t, r, n) >= 0) return !1;
        for (var i = e.next.next; i !== e.prev; ) {
          if (Mo(t.x, t.y, r.x, r.y, n.x, n.y, i.x, i.y) && Eo(i.prev, i, i.next) >= 0) return !1;
          i = i.next;
        }
        return !0;
      }
      function vo(e, t, r, n) {
        var i = e.prev,
          a = e,
          o = e.next;
        if (Eo(i, a, o) >= 0) return !1;
        for (
          var s = i.x < a.x ? (i.x < o.x ? i.x : o.x) : a.x < o.x ? a.x : o.x,
            c = i.y < a.y ? (i.y < o.y ? i.y : o.y) : a.y < o.y ? a.y : o.y,
            u = i.x > a.x ? (i.x > o.x ? i.x : o.x) : a.x > o.x ? a.x : o.x,
            l = i.y > a.y ? (i.y > o.y ? i.y : o.y) : a.y > o.y ? a.y : o.y,
            h = wo(s, c, t, r, n),
            d = wo(u, l, t, r, n),
            p = e.nextZ;
          p && p.z <= d;

        ) {
          if (
            p !== e.prev &&
            p !== e.next &&
            Mo(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
            Eo(p.prev, p, p.next) >= 0
          )
            return !1;
          p = p.nextZ;
        }
        for (p = e.prevZ; p && p.z >= h; ) {
          if (
            p !== e.prev &&
            p !== e.next &&
            Mo(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
            Eo(p.prev, p, p.next) >= 0
          )
            return !1;
          p = p.prevZ;
        }
        return !0;
      }
      function go(e, t, r) {
        var n = e;
        do {
          var i = n.prev,
            a = n.next.next;
          !To(i, a) &&
            Ao(i, n, n.next, a) &&
            Lo(i, a) &&
            Lo(a, i) &&
            (t.push(i.i / r), t.push(n.i / r), t.push(a.i / r), Po(n), Po(n.next), (n = e = a)),
            (n = n.next);
        } while (n !== e);
        return n;
      }
      function yo(e, t, r, n, i, a) {
        var o = e;
        do {
          for (var s = o.next.next; s !== o.prev; ) {
            if (o.i !== s.i && So(o, s)) {
              var c = Ro(o, s);
              return (
                (o = po(o, o.next)),
                (c = po(c, c.next)),
                fo(o, t, r, n, i, a),
                void fo(c, t, r, n, i, a)
              );
            }
            s = s.next;
          }
          o = o.next;
        } while (o !== e);
      }
      function xo(e, t) {
        return e.x - t.x;
      }
      function bo(e, t) {
        if (
          (t = (function (e, t) {
            var r,
              n = t,
              i = e.x,
              a = e.y,
              o = -1 / 0;
            do {
              if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
                var s = n.x + ((a - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
                if (s <= i && s > o) {
                  if (((o = s), s === i)) {
                    if (a === n.y) return n;
                    if (a === n.next.y) return n.next;
                  }
                  r = n.x < n.next.x ? n : n.next;
                }
              }
              n = n.next;
            } while (n !== t);
            if (!r) return null;
            if (i === o) return r.prev;
            var c,
              u = r,
              l = r.x,
              h = r.y,
              d = 1 / 0;
            n = r.next;
            for (; n !== u; )
              i >= n.x &&
                n.x >= l &&
                i !== n.x &&
                Mo(a < h ? i : o, a, l, h, a < h ? o : i, a, n.x, n.y) &&
                ((c = Math.abs(a - n.y) / (i - n.x)) < d || (c === d && n.x > r.x)) &&
                Lo(n, e) &&
                ((r = n), (d = c)),
                (n = n.next);
            return r;
          })(e, t))
        ) {
          var r = Ro(t, e);
          po(r, r.next);
        }
      }
      function wo(e, t, r, n, i) {
        return (
          (e =
            1431655765 &
            ((e =
              858993459 &
              ((e =
                252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | (e << 8))) | (e << 4))) |
                (e << 2))) |
              (e << 1))) |
          ((t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | (t << 8))) | (t << 4))) |
                (t << 2))) |
              (t << 1))) <<
            1)
        );
      }
      function _o(e) {
        var t = e,
          r = e;
        do {
          t.x < r.x && (r = t), (t = t.next);
        } while (t !== e);
        return r;
      }
      function Mo(e, t, r, n, i, a, o, s) {
        return (
          (i - o) * (t - s) - (e - o) * (a - s) >= 0 &&
          (e - o) * (n - s) - (r - o) * (t - s) >= 0 &&
          (r - o) * (a - s) - (i - o) * (n - s) >= 0
        );
      }
      function So(e, t) {
        return (
          e.next.i !== t.i &&
          e.prev.i !== t.i &&
          !(function (e, t) {
            var r = e;
            do {
              if (
                r.i !== e.i &&
                r.next.i !== e.i &&
                r.i !== t.i &&
                r.next.i !== t.i &&
                Ao(r, r.next, e, t)
              )
                return !0;
              r = r.next;
            } while (r !== e);
            return !1;
          })(e, t) &&
          Lo(e, t) &&
          Lo(t, e) &&
          (function (e, t) {
            var r = e,
              n = !1,
              i = (e.x + t.x) / 2,
              a = (e.y + t.y) / 2;
            do {
              r.y > a != r.next.y > a &&
                r.next.y !== r.y &&
                i < ((r.next.x - r.x) * (a - r.y)) / (r.next.y - r.y) + r.x &&
                (n = !n),
                (r = r.next);
            } while (r !== e);
            return n;
          })(e, t)
        );
      }
      function Eo(e, t, r) {
        return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y);
      }
      function To(e, t) {
        return e.x === t.x && e.y === t.y;
      }
      function Ao(e, t, r, n) {
        return (
          !!((To(e, t) && To(r, n)) || (To(e, n) && To(r, t))) ||
          (Eo(e, t, r) > 0 != Eo(e, t, n) > 0 && Eo(r, n, e) > 0 != Eo(r, n, t) > 0)
        );
      }
      function Lo(e, t) {
        return Eo(e.prev, e, e.next) < 0
          ? Eo(e, t, e.next) >= 0 && Eo(e, e.prev, t) >= 0
          : Eo(e, t, e.prev) < 0 || Eo(e, e.next, t) < 0;
      }
      function Ro(e, t) {
        var r = new Oo(e.i, e.x, e.y),
          n = new Oo(t.i, t.x, t.y),
          i = e.next,
          a = t.prev;
        return (
          (e.next = t),
          (t.prev = e),
          (r.next = i),
          (i.prev = r),
          (n.next = r),
          (r.prev = n),
          (a.next = n),
          (n.prev = a),
          n
        );
      }
      function Co(e, t, r, n) {
        var i = new Oo(e, t, r);
        return (
          n
            ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
            : ((i.prev = i), (i.next = i)),
          i
        );
      }
      function Po(e) {
        (e.next.prev = e.prev),
          (e.prev.next = e.next),
          e.prevZ && (e.prevZ.nextZ = e.nextZ),
          e.nextZ && (e.nextZ.prevZ = e.prevZ);
      }
      function Oo(e, t, r) {
        (this.i = e),
          (this.x = t),
          (this.y = r),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      var Io = {
        area: function (e) {
          for (var t = e.length, r = 0, n = t - 1, i = 0; i < t; n = i++)
            r += e[n].x * e[i].y - e[i].x * e[n].y;
          return 0.5 * r;
        },
        isClockWise: function (e) {
          return Io.area(e) < 0;
        },
        triangulateShape: function (e, t) {
          var r = [],
            n = [],
            i = [];
          Do(e), Bo(r, e);
          var a = e.length;
          t.forEach(Do);
          for (var o = 0; o < t.length; o++) n.push(a), (a += t[o].length), Bo(r, t[o]);
          var s = lo(r, n);
          for (o = 0; o < s.length; o += 3) i.push(s.slice(o, o + 3));
          return i;
        },
      };
      function Do(e) {
        var t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop();
      }
      function Bo(e, t) {
        for (var r = 0; r < t.length; r++) e.push(t[r].x), e.push(t[r].y);
      }
      function No(e, t) {
        qr.call(this),
          (this.type = 'ExtrudeGeometry'),
          (this.parameters = { shapes: e, options: t }),
          this.fromBufferGeometry(new Uo(e, t)),
          this.mergeVertices();
      }
      function Uo(e, t) {
        sn.call(this),
          (this.type = 'ExtrudeBufferGeometry'),
          (this.parameters = { shapes: e, options: t }),
          (e = Array.isArray(e) ? e : [e]);
        for (var r = this, n = [], i = [], a = 0, o = e.length; a < o; a++) {
          s(e[a]);
        }
        function s(e) {
          var a = [],
            o = void 0 !== t.curveSegments ? t.curveSegments : 12,
            s = void 0 !== t.steps ? t.steps : 1,
            c = void 0 !== t.depth ? t.depth : 100,
            u = void 0 === t.bevelEnabled || t.bevelEnabled,
            l = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
            h = void 0 !== t.bevelSize ? t.bevelSize : l - 2,
            d = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
            p = t.extrudePath,
            f = void 0 !== t.UVGenerator ? t.UVGenerator : Go;
          void 0 !== t.amount &&
            (console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.'),
            (c = t.amount));
          var m,
            v,
            g,
            y,
            x,
            b,
            w,
            _,
            M = !1;
          p &&
            ((m = p.getSpacedPoints(s)),
            (M = !0),
            (u = !1),
            (v = p.computeFrenetFrames(s, !1)),
            (g = new tr()),
            (y = new tr()),
            (x = new tr())),
            u || ((d = 0), (l = 0), (h = 0));
          var S = e.extractPoints(o),
            E = S.shape,
            T = S.holes;
          if (!Io.isClockWise(E))
            for (E = E.reverse(), w = 0, _ = T.length; w < _; w++)
              (b = T[w]), Io.isClockWise(b) && (T[w] = b.reverse());
          var A = Io.triangulateShape(E, T),
            L = E;
          for (w = 0, _ = T.length; w < _; w++) (b = T[w]), (E = E.concat(b));
          function R(e, t, r) {
            return (
              t || console.error('THREE.ExtrudeGeometry: vec does not exist'),
              t.clone().multiplyScalar(r).add(e)
            );
          }
          var C,
            P,
            O,
            I,
            D,
            B,
            N = E.length,
            U = A.length;
          function G(e, t, r) {
            var n,
              i,
              a,
              o = e.x - t.x,
              s = e.y - t.y,
              c = r.x - e.x,
              u = r.y - e.y,
              l = o * o + s * s,
              h = o * u - s * c;
            if (Math.abs(h) > Number.EPSILON) {
              var d = Math.sqrt(l),
                p = Math.sqrt(c * c + u * u),
                f = t.x - s / d,
                m = t.y + o / d,
                v = ((r.x - u / p - f) * u - (r.y + c / p - m) * c) / (o * u - s * c),
                g = (n = f + o * v - e.x) * n + (i = m + s * v - e.y) * i;
              if (g <= 2) return new Qt(n, i);
              a = Math.sqrt(g / 2);
            } else {
              var y = !1;
              o > Number.EPSILON
                ? c > Number.EPSILON && (y = !0)
                : o < -Number.EPSILON
                ? c < -Number.EPSILON && (y = !0)
                : Math.sign(s) === Math.sign(u) && (y = !0),
                y
                  ? ((n = -s), (i = o), (a = Math.sqrt(l)))
                  : ((n = o), (i = s), (a = Math.sqrt(l / 2)));
            }
            return new Qt(n / a, i / a);
          }
          for (var F = [], z = 0, H = L.length, k = H - 1, V = z + 1; z < H; z++, k++, V++)
            k === H && (k = 0), V === H && (V = 0), (F[z] = G(L[z], L[k], L[V]));
          var j,
            W,
            q = [],
            X = F.concat();
          for (w = 0, _ = T.length; w < _; w++) {
            for (b = T[w], j = [], z = 0, k = (H = b.length) - 1, V = z + 1; z < H; z++, k++, V++)
              k === H && (k = 0), V === H && (V = 0), (j[z] = G(b[z], b[k], b[V]));
            q.push(j), (X = X.concat(j));
          }
          for (C = 0; C < d; C++) {
            for (
              O = C / d,
                I = l * Math.cos((O * Math.PI) / 2),
                P = h * Math.sin((O * Math.PI) / 2),
                z = 0,
                H = L.length;
              z < H;
              z++
            )
              J((D = R(L[z], F[z], P)).x, D.y, -I);
            for (w = 0, _ = T.length; w < _; w++)
              for (b = T[w], j = q[w], z = 0, H = b.length; z < H; z++)
                J((D = R(b[z], j[z], P)).x, D.y, -I);
          }
          for (P = h, z = 0; z < N; z++)
            (D = u ? R(E[z], X[z], P) : E[z]),
              M
                ? (y.copy(v.normals[0]).multiplyScalar(D.x),
                  g.copy(v.binormals[0]).multiplyScalar(D.y),
                  x.copy(m[0]).add(y).add(g),
                  J(x.x, x.y, x.z))
                : J(D.x, D.y, 0);
          for (W = 1; W <= s; W++)
            for (z = 0; z < N; z++)
              (D = u ? R(E[z], X[z], P) : E[z]),
                M
                  ? (y.copy(v.normals[W]).multiplyScalar(D.x),
                    g.copy(v.binormals[W]).multiplyScalar(D.y),
                    x.copy(m[W]).add(y).add(g),
                    J(x.x, x.y, x.z))
                  : J(D.x, D.y, (c / s) * W);
          for (C = d - 1; C >= 0; C--) {
            for (
              O = C / d,
                I = l * Math.cos((O * Math.PI) / 2),
                P = h * Math.sin((O * Math.PI) / 2),
                z = 0,
                H = L.length;
              z < H;
              z++
            )
              J((D = R(L[z], F[z], P)).x, D.y, c + I);
            for (w = 0, _ = T.length; w < _; w++)
              for (b = T[w], j = q[w], z = 0, H = b.length; z < H; z++)
                (D = R(b[z], j[z], P)),
                  M ? J(D.x, D.y + m[s - 1].y, m[s - 1].x + I) : J(D.x, D.y, c + I);
          }
          function Y(e, t) {
            var r, n;
            for (z = e.length; --z >= 0; ) {
              (r = z), (n = z - 1) < 0 && (n = e.length - 1);
              var i = 0,
                a = s + 2 * d;
              for (i = 0; i < a; i++) {
                var o = N * i,
                  c = N * (i + 1);
                K(t + r + o, t + n + o, t + n + c, t + r + c);
              }
            }
          }
          function J(e, t, r) {
            a.push(e), a.push(t), a.push(r);
          }
          function Z(e, t, i) {
            Q(e), Q(t), Q(i);
            var a = n.length / 3,
              o = f.generateTopUV(r, n, a - 3, a - 2, a - 1);
            $(o[0]), $(o[1]), $(o[2]);
          }
          function K(e, t, i, a) {
            Q(e), Q(t), Q(a), Q(t), Q(i), Q(a);
            var o = n.length / 3,
              s = f.generateSideWallUV(r, n, o - 6, o - 3, o - 2, o - 1);
            $(s[0]), $(s[1]), $(s[3]), $(s[1]), $(s[2]), $(s[3]);
          }
          function Q(e) {
            n.push(a[3 * e + 0]), n.push(a[3 * e + 1]), n.push(a[3 * e + 2]);
          }
          function $(e) {
            i.push(e.x), i.push(e.y);
          }
          !(function () {
            var e = n.length / 3;
            if (u) {
              var t = 0,
                i = N * t;
              for (z = 0; z < U; z++) Z((B = A[z])[2] + i, B[1] + i, B[0] + i);
              for (i = N * (t = s + 2 * d), z = 0; z < U; z++)
                Z((B = A[z])[0] + i, B[1] + i, B[2] + i);
            } else {
              for (z = 0; z < U; z++) Z((B = A[z])[2], B[1], B[0]);
              for (z = 0; z < U; z++) Z((B = A[z])[0] + N * s, B[1] + N * s, B[2] + N * s);
            }
            r.addGroup(e, n.length / 3 - e, 0);
          })(),
            (function () {
              var e = n.length / 3,
                t = 0;
              for (Y(L, t), t += L.length, w = 0, _ = T.length; w < _; w++)
                Y((b = T[w]), t), (t += b.length);
              r.addGroup(e, n.length / 3 - e, 1);
            })();
        }
        this.addAttribute('position', new tn(n, 3)),
          this.addAttribute('uv', new tn(i, 2)),
          this.computeVertexNormals();
      }
      (No.prototype = Object.create(qr.prototype)),
        (No.prototype.constructor = No),
        (No.prototype.toJSON = function () {
          var e = qr.prototype.toJSON.call(this);
          return Fo(this.parameters.shapes, this.parameters.options, e);
        }),
        (Uo.prototype = Object.create(sn.prototype)),
        (Uo.prototype.constructor = Uo),
        (Uo.prototype.toJSON = function () {
          var e = sn.prototype.toJSON.call(this);
          return Fo(this.parameters.shapes, this.parameters.options, e);
        });
      var Go = {
        generateTopUV: function (e, t, r, n, i) {
          var a = t[3 * r],
            o = t[3 * r + 1],
            s = t[3 * n],
            c = t[3 * n + 1],
            u = t[3 * i],
            l = t[3 * i + 1];
          return [new Qt(a, o), new Qt(s, c), new Qt(u, l)];
        },
        generateSideWallUV: function (e, t, r, n, i, a) {
          var o = t[3 * r],
            s = t[3 * r + 1],
            c = t[3 * r + 2],
            u = t[3 * n],
            l = t[3 * n + 1],
            h = t[3 * n + 2],
            d = t[3 * i],
            p = t[3 * i + 1],
            f = t[3 * i + 2],
            m = t[3 * a],
            v = t[3 * a + 1],
            g = t[3 * a + 2];
          return Math.abs(s - l) < 0.01
            ? [new Qt(o, 1 - c), new Qt(u, 1 - h), new Qt(d, 1 - f), new Qt(m, 1 - g)]
            : [new Qt(s, 1 - c), new Qt(l, 1 - h), new Qt(p, 1 - f), new Qt(v, 1 - g)];
        },
      };
      function Fo(e, t, r) {
        if (((r.shapes = []), Array.isArray(e)))
          for (var n = 0, i = e.length; n < i; n++) {
            var a = e[n];
            r.shapes.push(a.uuid);
          }
        else r.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (r.options.extrudePath = t.extrudePath.toJSON()), r;
      }
      function zo(e, t) {
        qr.call(this),
          (this.type = 'TextGeometry'),
          (this.parameters = { text: e, parameters: t }),
          this.fromBufferGeometry(new Ho(e, t)),
          this.mergeVertices();
      }
      function Ho(e, t) {
        var r = (t = t || {}).font;
        if (!r || !r.isFont)
          return (
            console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.'),
            new qr()
          );
        var n = r.generateShapes(e, t.size);
        (t.depth = void 0 !== t.height ? t.height : 50),
          void 0 === t.bevelThickness && (t.bevelThickness = 10),
          void 0 === t.bevelSize && (t.bevelSize = 8),
          void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
          Uo.call(this, n, t),
          (this.type = 'TextBufferGeometry');
      }
      function ko(e, t, r, n, i, a, o) {
        qr.call(this),
          (this.type = 'SphereGeometry'),
          (this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: r,
            phiStart: n,
            phiLength: i,
            thetaStart: a,
            thetaLength: o,
          }),
          this.fromBufferGeometry(new Vo(e, t, r, n, i, a, o)),
          this.mergeVertices();
      }
      function Vo(e, t, r, n, i, a, o) {
        sn.call(this),
          (this.type = 'SphereBufferGeometry'),
          (this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: r,
            phiStart: n,
            phiLength: i,
            thetaStart: a,
            thetaLength: o,
          }),
          (e = e || 1),
          (t = Math.max(3, Math.floor(t) || 8)),
          (r = Math.max(2, Math.floor(r) || 6)),
          (n = void 0 !== n ? n : 0),
          (i = void 0 !== i ? i : 2 * Math.PI);
        var s,
          c,
          u = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI),
          l = 0,
          h = [],
          d = new tr(),
          p = new tr(),
          f = [],
          m = [],
          v = [],
          g = [];
        for (c = 0; c <= r; c++) {
          var y = [],
            x = c / r;
          for (s = 0; s <= t; s++) {
            var b = s / t;
            (d.x = -e * Math.cos(n + b * i) * Math.sin(a + x * o)),
              (d.y = e * Math.cos(a + x * o)),
              (d.z = e * Math.sin(n + b * i) * Math.sin(a + x * o)),
              m.push(d.x, d.y, d.z),
              p.set(d.x, d.y, d.z).normalize(),
              v.push(p.x, p.y, p.z),
              g.push(b, 1 - x),
              y.push(l++);
          }
          h.push(y);
        }
        for (c = 0; c < r; c++)
          for (s = 0; s < t; s++) {
            var w = h[c][s + 1],
              _ = h[c][s],
              M = h[c + 1][s],
              S = h[c + 1][s + 1];
            (0 !== c || a > 0) && f.push(w, _, S), (c !== r - 1 || u < Math.PI) && f.push(_, M, S);
          }
        this.setIndex(f),
          this.addAttribute('position', new tn(m, 3)),
          this.addAttribute('normal', new tn(v, 3)),
          this.addAttribute('uv', new tn(g, 2));
      }
      function jo(e, t, r, n, i, a) {
        qr.call(this),
          (this.type = 'RingGeometry'),
          (this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: r,
            phiSegments: n,
            thetaStart: i,
            thetaLength: a,
          }),
          this.fromBufferGeometry(new Wo(e, t, r, n, i, a)),
          this.mergeVertices();
      }
      function Wo(e, t, r, n, i, a) {
        sn.call(this),
          (this.type = 'RingBufferGeometry'),
          (this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: r,
            phiSegments: n,
            thetaStart: i,
            thetaLength: a,
          }),
          (e = e || 0.5),
          (t = t || 1),
          (i = void 0 !== i ? i : 0),
          (a = void 0 !== a ? a : 2 * Math.PI),
          (r = void 0 !== r ? Math.max(3, r) : 8);
        var o,
          s,
          c,
          u = [],
          l = [],
          h = [],
          d = [],
          p = e,
          f = (t - e) / (n = void 0 !== n ? Math.max(1, n) : 1),
          m = new tr(),
          v = new Qt();
        for (s = 0; s <= n; s++) {
          for (c = 0; c <= r; c++)
            (o = i + (c / r) * a),
              (m.x = p * Math.cos(o)),
              (m.y = p * Math.sin(o)),
              l.push(m.x, m.y, m.z),
              h.push(0, 0, 1),
              (v.x = (m.x / t + 1) / 2),
              (v.y = (m.y / t + 1) / 2),
              d.push(v.x, v.y);
          p += f;
        }
        for (s = 0; s < n; s++) {
          var g = s * (r + 1);
          for (c = 0; c < r; c++) {
            var y = (o = c + g),
              x = o + r + 1,
              b = o + r + 2,
              w = o + 1;
            u.push(y, x, w), u.push(x, b, w);
          }
        }
        this.setIndex(u),
          this.addAttribute('position', new tn(l, 3)),
          this.addAttribute('normal', new tn(h, 3)),
          this.addAttribute('uv', new tn(d, 2));
      }
      function qo(e, t, r, n) {
        qr.call(this),
          (this.type = 'LatheGeometry'),
          (this.parameters = { points: e, segments: t, phiStart: r, phiLength: n }),
          this.fromBufferGeometry(new Xo(e, t, r, n)),
          this.mergeVertices();
      }
      function Xo(e, t, r, n) {
        sn.call(this),
          (this.type = 'LatheBufferGeometry'),
          (this.parameters = { points: e, segments: t, phiStart: r, phiLength: n }),
          (t = Math.floor(t) || 12),
          (r = r || 0),
          (n = n || 2 * Math.PI),
          (n = Kt.clamp(n, 0, 2 * Math.PI));
        var i,
          a,
          o,
          s = [],
          c = [],
          u = [],
          l = 1 / t,
          h = new tr(),
          d = new Qt();
        for (a = 0; a <= t; a++) {
          var p = r + a * l * n,
            f = Math.sin(p),
            m = Math.cos(p);
          for (o = 0; o <= e.length - 1; o++)
            (h.x = e[o].x * f),
              (h.y = e[o].y),
              (h.z = e[o].x * m),
              c.push(h.x, h.y, h.z),
              (d.x = a / t),
              (d.y = o / (e.length - 1)),
              u.push(d.x, d.y);
        }
        for (a = 0; a < t; a++)
          for (o = 0; o < e.length - 1; o++) {
            var v = (i = o + a * e.length),
              g = i + e.length,
              y = i + e.length + 1,
              x = i + 1;
            s.push(v, g, x), s.push(g, y, x);
          }
        if (
          (this.setIndex(s),
          this.addAttribute('position', new tn(c, 3)),
          this.addAttribute('uv', new tn(u, 2)),
          this.computeVertexNormals(),
          n === 2 * Math.PI)
        ) {
          var b = this.attributes.normal.array,
            w = new tr(),
            _ = new tr(),
            M = new tr();
          for (i = t * e.length * 3, a = 0, o = 0; a < e.length; a++, o += 3)
            (w.x = b[o + 0]),
              (w.y = b[o + 1]),
              (w.z = b[o + 2]),
              (_.x = b[i + o + 0]),
              (_.y = b[i + o + 1]),
              (_.z = b[i + o + 2]),
              M.addVectors(w, _).normalize(),
              (b[o + 0] = b[i + o + 0] = M.x),
              (b[o + 1] = b[i + o + 1] = M.y),
              (b[o + 2] = b[i + o + 2] = M.z);
        }
      }
      function Yo(e, t) {
        qr.call(this),
          (this.type = 'ShapeGeometry'),
          'object' == typeof t &&
            (console.warn('THREE.ShapeGeometry: Options parameter has been removed.'),
            (t = t.curveSegments)),
          (this.parameters = { shapes: e, curveSegments: t }),
          this.fromBufferGeometry(new Jo(e, t)),
          this.mergeVertices();
      }
      function Jo(e, t) {
        sn.call(this),
          (this.type = 'ShapeBufferGeometry'),
          (this.parameters = { shapes: e, curveSegments: t }),
          (t = t || 12);
        var r = [],
          n = [],
          i = [],
          a = [],
          o = 0,
          s = 0;
        if (!1 === Array.isArray(e)) u(e);
        else for (var c = 0; c < e.length; c++) u(e[c]), this.addGroup(o, s, c), (o += s), (s = 0);
        function u(e) {
          var o,
            c,
            u,
            l = n.length / 3,
            h = e.extractPoints(t),
            d = h.shape,
            p = h.holes;
          for (!1 === Io.isClockWise(d) && (d = d.reverse()), o = 0, c = p.length; o < c; o++)
            (u = p[o]), !0 === Io.isClockWise(u) && (p[o] = u.reverse());
          var f = Io.triangulateShape(d, p);
          for (o = 0, c = p.length; o < c; o++) (u = p[o]), (d = d.concat(u));
          for (o = 0, c = d.length; o < c; o++) {
            var m = d[o];
            n.push(m.x, m.y, 0), i.push(0, 0, 1), a.push(m.x, m.y);
          }
          for (o = 0, c = f.length; o < c; o++) {
            var v = f[o],
              g = v[0] + l,
              y = v[1] + l,
              x = v[2] + l;
            r.push(g, y, x), (s += 3);
          }
        }
        this.setIndex(r),
          this.addAttribute('position', new tn(n, 3)),
          this.addAttribute('normal', new tn(i, 3)),
          this.addAttribute('uv', new tn(a, 2));
      }
      function Zo(e, t) {
        if (((t.shapes = []), Array.isArray(e)))
          for (var r = 0, n = e.length; r < n; r++) {
            var i = e[r];
            t.shapes.push(i.uuid);
          }
        else t.shapes.push(e.uuid);
        return t;
      }
      function Ko(e, t) {
        sn.call(this),
          (this.type = 'EdgesGeometry'),
          (this.parameters = { thresholdAngle: t }),
          (t = void 0 !== t ? t : 1);
        var r,
          n,
          i,
          a,
          o = [],
          s = Math.cos(Kt.DEG2RAD * t),
          c = [0, 0],
          u = {},
          l = ['a', 'b', 'c'];
        e.isBufferGeometry ? (a = new qr()).fromBufferGeometry(e) : (a = e.clone()),
          a.mergeVertices(),
          a.computeFaceNormals();
        for (var h = a.vertices, d = a.faces, p = 0, f = d.length; p < f; p++)
          for (var m = d[p], v = 0; v < 3; v++)
            (r = m[l[v]]),
              (n = m[l[(v + 1) % 3]]),
              (c[0] = Math.min(r, n)),
              (c[1] = Math.max(r, n)),
              void 0 === u[(i = c[0] + ',' + c[1])]
                ? (u[i] = { index1: c[0], index2: c[1], face1: p, face2: void 0 })
                : (u[i].face2 = p);
        for (i in u) {
          var g = u[i];
          if (void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= s) {
            var y = h[g.index1];
            o.push(y.x, y.y, y.z), (y = h[g.index2]), o.push(y.x, y.y, y.z);
          }
        }
        this.addAttribute('position', new tn(o, 3));
      }
      function Qo(e, t, r, n, i, a, o, s) {
        qr.call(this),
          (this.type = 'CylinderGeometry'),
          (this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: r,
            radialSegments: n,
            heightSegments: i,
            openEnded: a,
            thetaStart: o,
            thetaLength: s,
          }),
          this.fromBufferGeometry(new $o(e, t, r, n, i, a, o, s)),
          this.mergeVertices();
      }
      function $o(e, t, r, n, i, a, o, s) {
        sn.call(this),
          (this.type = 'CylinderBufferGeometry'),
          (this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: r,
            radialSegments: n,
            heightSegments: i,
            openEnded: a,
            thetaStart: o,
            thetaLength: s,
          });
        var c = this;
        (e = void 0 !== e ? e : 1),
          (t = void 0 !== t ? t : 1),
          (r = r || 1),
          (n = Math.floor(n) || 8),
          (i = Math.floor(i) || 1),
          (a = void 0 !== a && a),
          (o = void 0 !== o ? o : 0),
          (s = void 0 !== s ? s : 2 * Math.PI);
        var u = [],
          l = [],
          h = [],
          d = [],
          p = 0,
          f = [],
          m = r / 2,
          v = 0;
        function g(r) {
          var i,
            a,
            f,
            g = new Qt(),
            y = new tr(),
            x = 0,
            b = !0 === r ? e : t,
            w = !0 === r ? 1 : -1;
          for (a = p, i = 1; i <= n; i++)
            l.push(0, m * w, 0), h.push(0, w, 0), d.push(0.5, 0.5), p++;
          for (f = p, i = 0; i <= n; i++) {
            var _ = (i / n) * s + o,
              M = Math.cos(_),
              S = Math.sin(_);
            (y.x = b * S),
              (y.y = m * w),
              (y.z = b * M),
              l.push(y.x, y.y, y.z),
              h.push(0, w, 0),
              (g.x = 0.5 * M + 0.5),
              (g.y = 0.5 * S * w + 0.5),
              d.push(g.x, g.y),
              p++;
          }
          for (i = 0; i < n; i++) {
            var E = a + i,
              T = f + i;
            !0 === r ? u.push(T, T + 1, E) : u.push(T + 1, T, E), (x += 3);
          }
          c.addGroup(v, x, !0 === r ? 1 : 2), (v += x);
        }
        !(function () {
          var a,
            g,
            y = new tr(),
            x = new tr(),
            b = 0,
            w = (t - e) / r;
          for (g = 0; g <= i; g++) {
            var _ = [],
              M = g / i,
              S = M * (t - e) + e;
            for (a = 0; a <= n; a++) {
              var E = a / n,
                T = E * s + o,
                A = Math.sin(T),
                L = Math.cos(T);
              (x.x = S * A),
                (x.y = -M * r + m),
                (x.z = S * L),
                l.push(x.x, x.y, x.z),
                y.set(A, w, L).normalize(),
                h.push(y.x, y.y, y.z),
                d.push(E, 1 - M),
                _.push(p++);
            }
            f.push(_);
          }
          for (a = 0; a < n; a++)
            for (g = 0; g < i; g++) {
              var R = f[g][a],
                C = f[g + 1][a],
                P = f[g + 1][a + 1],
                O = f[g][a + 1];
              u.push(R, C, O), u.push(C, P, O), (b += 6);
            }
          c.addGroup(v, b, 0), (v += b);
        })(),
          !1 === a && (e > 0 && g(!0), t > 0 && g(!1)),
          this.setIndex(u),
          this.addAttribute('position', new tn(l, 3)),
          this.addAttribute('normal', new tn(h, 3)),
          this.addAttribute('uv', new tn(d, 2));
      }
      function es(e, t, r, n, i, a, o) {
        Qo.call(this, 0, e, t, r, n, i, a, o),
          (this.type = 'ConeGeometry'),
          (this.parameters = {
            radius: e,
            height: t,
            radialSegments: r,
            heightSegments: n,
            openEnded: i,
            thetaStart: a,
            thetaLength: o,
          });
      }
      function ts(e, t, r, n, i, a, o) {
        $o.call(this, 0, e, t, r, n, i, a, o),
          (this.type = 'ConeBufferGeometry'),
          (this.parameters = {
            radius: e,
            height: t,
            radialSegments: r,
            heightSegments: n,
            openEnded: i,
            thetaStart: a,
            thetaLength: o,
          });
      }
      function rs(e, t, r, n) {
        qr.call(this),
          (this.type = 'CircleGeometry'),
          (this.parameters = { radius: e, segments: t, thetaStart: r, thetaLength: n }),
          this.fromBufferGeometry(new ns(e, t, r, n)),
          this.mergeVertices();
      }
      function ns(e, t, r, n) {
        sn.call(this),
          (this.type = 'CircleBufferGeometry'),
          (this.parameters = { radius: e, segments: t, thetaStart: r, thetaLength: n }),
          (e = e || 1),
          (t = void 0 !== t ? Math.max(3, t) : 8),
          (r = void 0 !== r ? r : 0),
          (n = void 0 !== n ? n : 2 * Math.PI);
        var i,
          a,
          o = [],
          s = [],
          c = [],
          u = [],
          l = new tr(),
          h = new Qt();
        for (
          s.push(0, 0, 0), c.push(0, 0, 1), u.push(0.5, 0.5), a = 0, i = 3;
          a <= t;
          a++, i += 3
        ) {
          var d = r + (a / t) * n;
          (l.x = e * Math.cos(d)),
            (l.y = e * Math.sin(d)),
            s.push(l.x, l.y, l.z),
            c.push(0, 0, 1),
            (h.x = (s[i] / e + 1) / 2),
            (h.y = (s[i + 1] / e + 1) / 2),
            u.push(h.x, h.y);
        }
        for (i = 1; i <= t; i++) o.push(i, i + 1, 0);
        this.setIndex(o),
          this.addAttribute('position', new tn(s, 3)),
          this.addAttribute('normal', new tn(c, 3)),
          this.addAttribute('uv', new tn(u, 2));
      }
      (zo.prototype = Object.create(qr.prototype)),
        (zo.prototype.constructor = zo),
        (Ho.prototype = Object.create(Uo.prototype)),
        (Ho.prototype.constructor = Ho),
        (ko.prototype = Object.create(qr.prototype)),
        (ko.prototype.constructor = ko),
        (Vo.prototype = Object.create(sn.prototype)),
        (Vo.prototype.constructor = Vo),
        (jo.prototype = Object.create(qr.prototype)),
        (jo.prototype.constructor = jo),
        (Wo.prototype = Object.create(sn.prototype)),
        (Wo.prototype.constructor = Wo),
        (qo.prototype = Object.create(qr.prototype)),
        (qo.prototype.constructor = qo),
        (Xo.prototype = Object.create(sn.prototype)),
        (Xo.prototype.constructor = Xo),
        (Yo.prototype = Object.create(qr.prototype)),
        (Yo.prototype.constructor = Yo),
        (Yo.prototype.toJSON = function () {
          var e = qr.prototype.toJSON.call(this);
          return Zo(this.parameters.shapes, e);
        }),
        (Jo.prototype = Object.create(sn.prototype)),
        (Jo.prototype.constructor = Jo),
        (Jo.prototype.toJSON = function () {
          var e = sn.prototype.toJSON.call(this);
          return Zo(this.parameters.shapes, e);
        }),
        (Ko.prototype = Object.create(sn.prototype)),
        (Ko.prototype.constructor = Ko),
        (Qo.prototype = Object.create(qr.prototype)),
        (Qo.prototype.constructor = Qo),
        ($o.prototype = Object.create(sn.prototype)),
        ($o.prototype.constructor = $o),
        (es.prototype = Object.create(Qo.prototype)),
        (es.prototype.constructor = es),
        (ts.prototype = Object.create($o.prototype)),
        (ts.prototype.constructor = ts),
        (rs.prototype = Object.create(qr.prototype)),
        (rs.prototype.constructor = rs),
        (ns.prototype = Object.create(sn.prototype)),
        (ns.prototype.constructor = ns);
      var is = Object.freeze({
        WireframeGeometry: Wa,
        ParametricGeometry: qa,
        ParametricBufferGeometry: Xa,
        TetrahedronGeometry: Za,
        TetrahedronBufferGeometry: Ka,
        OctahedronGeometry: Qa,
        OctahedronBufferGeometry: $a,
        IcosahedronGeometry: eo,
        IcosahedronBufferGeometry: to,
        DodecahedronGeometry: ro,
        DodecahedronBufferGeometry: no,
        PolyhedronGeometry: Ya,
        PolyhedronBufferGeometry: Ja,
        TubeGeometry: io,
        TubeBufferGeometry: ao,
        TorusKnotGeometry: oo,
        TorusKnotBufferGeometry: so,
        TorusGeometry: co,
        TorusBufferGeometry: uo,
        TextGeometry: zo,
        TextBufferGeometry: Ho,
        SphereGeometry: ko,
        SphereBufferGeometry: Vo,
        RingGeometry: jo,
        RingBufferGeometry: Wo,
        PlaneGeometry: ln,
        PlaneBufferGeometry: hn,
        LatheGeometry: qo,
        LatheBufferGeometry: Xo,
        ShapeGeometry: Yo,
        ShapeBufferGeometry: Jo,
        ExtrudeGeometry: No,
        ExtrudeBufferGeometry: Uo,
        EdgesGeometry: Ko,
        ConeGeometry: es,
        ConeBufferGeometry: ts,
        CylinderGeometry: Qo,
        CylinderBufferGeometry: $o,
        CircleGeometry: rs,
        CircleBufferGeometry: ns,
        BoxGeometry: cn,
        BoxBufferGeometry: un,
      });
      function as(e) {
        En.call(this),
          (this.type = 'ShadowMaterial'),
          (this.color = new Lr(0)),
          (this.transparent = !0),
          this.setValues(e);
      }
      function os(e) {
        Tn.call(this, e), (this.type = 'RawShaderMaterial');
      }
      function ss(e) {
        En.call(this),
          (this.defines = { STANDARD: '' }),
          (this.type = 'MeshStandardMaterial'),
          (this.color = new Lr(16777215)),
          (this.roughness = 0.5),
          (this.metalness = 0.5),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new Lr(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = Jt),
          (this.normalScale = new Qt(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.roughnessMap = null),
          (this.metalnessMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.envMapIntensity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = 'round'),
          (this.wireframeLinejoin = 'round'),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function cs(e) {
        ss.call(this),
          (this.defines = { PHYSICAL: '' }),
          (this.type = 'MeshPhysicalMaterial'),
          (this.reflectivity = 0.5),
          (this.clearCoat = 0),
          (this.clearCoatRoughness = 0),
          this.setValues(e);
      }
      function us(e) {
        En.call(this),
          (this.type = 'MeshPhongMaterial'),
          (this.color = new Lr(16777215)),
          (this.specular = new Lr(1118481)),
          (this.shininess = 30),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new Lr(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = Jt),
          (this.normalScale = new Qt(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = he),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = 'round'),
          (this.wireframeLinejoin = 'round'),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function ls(e) {
        us.call(this),
          (this.defines = { TOON: '' }),
          (this.type = 'MeshToonMaterial'),
          (this.gradientMap = null),
          this.setValues(e);
      }
      function hs(e) {
        En.call(this),
          (this.type = 'MeshNormalMaterial'),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = Jt),
          (this.normalScale = new Qt(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function ds(e) {
        En.call(this),
          (this.type = 'MeshLambertMaterial'),
          (this.color = new Lr(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new Lr(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = he),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = 'round'),
          (this.wireframeLinejoin = 'round'),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function ps(e) {
        En.call(this),
          (this.defines = { MATCAP: '' }),
          (this.type = 'MeshMatcapMaterial'),
          (this.color = new Lr(16777215)),
          (this.matcap = null),
          (this.map = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = Jt),
          (this.normalScale = new Qt(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.lights = !1),
          this.setValues(e);
      }
      function fs(e) {
        Ba.call(this),
          (this.type = 'LineDashedMaterial'),
          (this.scale = 1),
          (this.dashSize = 3),
          (this.gapSize = 1),
          this.setValues(e);
      }
      (as.prototype = Object.create(En.prototype)),
        (as.prototype.constructor = as),
        (as.prototype.isShadowMaterial = !0),
        (as.prototype.copy = function (e) {
          return En.prototype.copy.call(this, e), this.color.copy(e.color), this;
        }),
        (os.prototype = Object.create(Tn.prototype)),
        (os.prototype.constructor = os),
        (os.prototype.isRawShaderMaterial = !0),
        (ss.prototype = Object.create(En.prototype)),
        (ss.prototype.constructor = ss),
        (ss.prototype.isMeshStandardMaterial = !0),
        (ss.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            (this.defines = { STANDARD: '' }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.envMapIntensity = e.envMapIntensity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        (cs.prototype = Object.create(ss.prototype)),
        (cs.prototype.constructor = cs),
        (cs.prototype.isMeshPhysicalMaterial = !0),
        (cs.prototype.copy = function (e) {
          return (
            ss.prototype.copy.call(this, e),
            (this.defines = { PHYSICAL: '' }),
            (this.reflectivity = e.reflectivity),
            (this.clearCoat = e.clearCoat),
            (this.clearCoatRoughness = e.clearCoatRoughness),
            this
          );
        }),
        (us.prototype = Object.create(En.prototype)),
        (us.prototype.constructor = us),
        (us.prototype.isMeshPhongMaterial = !0),
        (us.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        (ls.prototype = Object.create(us.prototype)),
        (ls.prototype.constructor = ls),
        (ls.prototype.isMeshToonMaterial = !0),
        (ls.prototype.copy = function (e) {
          return us.prototype.copy.call(this, e), (this.gradientMap = e.gradientMap), this;
        }),
        (hs.prototype = Object.create(En.prototype)),
        (hs.prototype.constructor = hs),
        (hs.prototype.isMeshNormalMaterial = !0),
        (hs.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        (ds.prototype = Object.create(En.prototype)),
        (ds.prototype.constructor = ds),
        (ds.prototype.isMeshLambertMaterial = !0),
        (ds.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        (ps.prototype = Object.create(En.prototype)),
        (ps.prototype.constructor = ps),
        (ps.prototype.isMeshMatcapMaterial = !0),
        (ps.prototype.copy = function (e) {
          return (
            En.prototype.copy.call(this, e),
            (this.defines = { MATCAP: '' }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        (fs.prototype = Object.create(Ba.prototype)),
        (fs.prototype.constructor = fs),
        (fs.prototype.isLineDashedMaterial = !0),
        (fs.prototype.copy = function (e) {
          return (
            Ba.prototype.copy.call(this, e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
          );
        });
      var ms = Object.freeze({
          ShadowMaterial: as,
          SpriteMaterial: Ra,
          RawShaderMaterial: os,
          ShaderMaterial: Tn,
          PointsMaterial: Fa,
          MeshPhysicalMaterial: cs,
          MeshStandardMaterial: ss,
          MeshPhongMaterial: us,
          MeshToonMaterial: ls,
          MeshNormalMaterial: hs,
          MeshLambertMaterial: ds,
          MeshDepthMaterial: ra,
          MeshDistanceMaterial: na,
          MeshBasicMaterial: Rn,
          MeshMatcapMaterial: ps,
          LineDashedMaterial: fs,
          LineBasicMaterial: Ba,
          Material: En,
        }),
        vs = {
          arraySlice: function (e, t, r) {
            return vs.isTypedArray(e)
              ? new e.constructor(e.subarray(t, void 0 !== r ? r : e.length))
              : e.slice(t, r);
          },
          convertArray: function (e, t, r) {
            return !e || (!r && e.constructor === t)
              ? e
              : 'number' == typeof t.BYTES_PER_ELEMENT
              ? new t(e)
              : Array.prototype.slice.call(e);
          },
          isTypedArray: function (e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView);
          },
          getKeyframeOrder: function (e) {
            for (var t = e.length, r = new Array(t), n = 0; n !== t; ++n) r[n] = n;
            return (
              r.sort(function (t, r) {
                return e[t] - e[r];
              }),
              r
            );
          },
          sortedArray: function (e, t, r) {
            for (var n = e.length, i = new e.constructor(n), a = 0, o = 0; o !== n; ++a)
              for (var s = r[a] * t, c = 0; c !== t; ++c) i[o++] = e[s + c];
            return i;
          },
          flattenJSON: function (e, t, r, n) {
            for (var i = 1, a = e[0]; void 0 !== a && void 0 === a[n]; ) a = e[i++];
            if (void 0 !== a) {
              var o = a[n];
              if (void 0 !== o)
                if (Array.isArray(o))
                  do {
                    void 0 !== (o = a[n]) && (t.push(a.time), r.push.apply(r, o)), (a = e[i++]);
                  } while (void 0 !== a);
                else if (void 0 !== o.toArray)
                  do {
                    void 0 !== (o = a[n]) && (t.push(a.time), o.toArray(r, r.length)), (a = e[i++]);
                  } while (void 0 !== a);
                else
                  do {
                    void 0 !== (o = a[n]) && (t.push(a.time), r.push(o)), (a = e[i++]);
                  } while (void 0 !== a);
            }
          },
        };
      function gs(e, t, r, n) {
        (this.parameterPositions = e),
          (this._cachedIndex = 0),
          (this.resultBuffer = void 0 !== n ? n : new t.constructor(r)),
          (this.sampleValues = t),
          (this.valueSize = r);
      }
      function ys(e, t, r, n) {
        gs.call(this, e, t, r, n),
          (this._weightPrev = -0),
          (this._offsetPrev = -0),
          (this._weightNext = -0),
          (this._offsetNext = -0);
      }
      function xs(e, t, r, n) {
        gs.call(this, e, t, r, n);
      }
      function bs(e, t, r, n) {
        gs.call(this, e, t, r, n);
      }
      function ws(e, t, r, n) {
        if (void 0 === e) throw new Error('THREE.KeyframeTrack: track name is undefined');
        if (void 0 === t || 0 === t.length)
          throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + e);
        (this.name = e),
          (this.times = vs.convertArray(t, this.TimeBufferType)),
          (this.values = vs.convertArray(r, this.ValueBufferType)),
          this.setInterpolation(n || this.DefaultInterpolation);
      }
      function _s(e, t, r) {
        ws.call(this, e, t, r);
      }
      function Ms(e, t, r, n) {
        ws.call(this, e, t, r, n);
      }
      function Ss(e, t, r, n) {
        ws.call(this, e, t, r, n);
      }
      function Es(e, t, r, n) {
        gs.call(this, e, t, r, n);
      }
      function Ts(e, t, r, n) {
        ws.call(this, e, t, r, n);
      }
      function As(e, t, r, n) {
        ws.call(this, e, t, r, n);
      }
      function Ls(e, t, r, n) {
        ws.call(this, e, t, r, n);
      }
      function Rs(e, t, r) {
        (this.name = e),
          (this.tracks = r),
          (this.duration = void 0 !== t ? t : -1),
          (this.uuid = Kt.generateUUID()),
          this.duration < 0 && this.resetDuration();
      }
      function Cs(e) {
        if (void 0 === e.type)
          throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
        var t = (function (e) {
          switch (e.toLowerCase()) {
            case 'scalar':
            case 'double':
            case 'float':
            case 'number':
            case 'integer':
              return Ss;
            case 'vector':
            case 'vector2':
            case 'vector3':
            case 'vector4':
              return Ls;
            case 'color':
              return Ms;
            case 'quaternion':
              return Ts;
            case 'bool':
            case 'boolean':
              return _s;
            case 'string':
              return As;
          }
          throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + e);
        })(e.type);
        if (void 0 === e.times) {
          var r = [],
            n = [];
          vs.flattenJSON(e.keys, r, n, 'value'), (e.times = r), (e.values = n);
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation);
      }
      Object.assign(gs.prototype, {
        evaluate: function (e) {
          var t = this.parameterPositions,
            r = this._cachedIndex,
            n = t[r],
            i = t[r - 1];
          e: {
            t: {
              var a;
              r: {
                n: if (!(e < n)) {
                  for (var o = r + 2; ; ) {
                    if (void 0 === n) {
                      if (e < i) break n;
                      return (r = t.length), (this._cachedIndex = r), this.afterEnd_(r - 1, e, i);
                    }
                    if (r === o) break;
                    if (((i = n), e < (n = t[++r]))) break t;
                  }
                  a = t.length;
                  break r;
                }
                if (e >= i) break e;
                var s = t[1];
                e < s && ((r = 2), (i = s));
                for (o = r - 2; ; ) {
                  if (void 0 === i) return (this._cachedIndex = 0), this.beforeStart_(0, e, n);
                  if (r === o) break;
                  if (((n = i), e >= (i = t[--r - 1]))) break t;
                }
                (a = r), (r = 0);
              }
              for (; r < a; ) {
                var c = (r + a) >>> 1;
                e < t[c] ? (a = c) : (r = c + 1);
              }
              if (((n = t[r]), void 0 === (i = t[r - 1])))
                return (this._cachedIndex = 0), this.beforeStart_(0, e, n);
              if (void 0 === n)
                return (r = t.length), (this._cachedIndex = r), this.afterEnd_(r - 1, i, e);
            }
            (this._cachedIndex = r), this.intervalChanged_(r, i, n);
          }
          return this.interpolate_(r, i, e, n);
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function () {
          return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function (e) {
          for (
            var t = this.resultBuffer, r = this.sampleValues, n = this.valueSize, i = e * n, a = 0;
            a !== n;
            ++a
          )
            t[a] = r[i + a];
          return t;
        },
        interpolate_: function () {
          throw new Error('call to abstract method');
        },
        intervalChanged_: function () {},
      }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(gs.prototype, {
          beforeStart_: gs.prototype.copySampleValue_,
          afterEnd_: gs.prototype.copySampleValue_,
        }),
        (ys.prototype = Object.assign(Object.create(gs.prototype), {
          constructor: ys,
          DefaultSettings_: { endingStart: It, endingEnd: It },
          intervalChanged_: function (e, t, r) {
            var n = this.parameterPositions,
              i = e - 2,
              a = e + 1,
              o = n[i],
              s = n[a];
            if (void 0 === o)
              switch (this.getSettings_().endingStart) {
                case Dt:
                  (i = e), (o = 2 * t - r);
                  break;
                case Bt:
                  o = t + n[(i = n.length - 2)] - n[i + 1];
                  break;
                default:
                  (i = e), (o = r);
              }
            if (void 0 === s)
              switch (this.getSettings_().endingEnd) {
                case Dt:
                  (a = e), (s = 2 * r - t);
                  break;
                case Bt:
                  (a = 1), (s = r + n[1] - n[0]);
                  break;
                default:
                  (a = e - 1), (s = t);
              }
            var c = 0.5 * (r - t),
              u = this.valueSize;
            (this._weightPrev = c / (t - o)),
              (this._weightNext = c / (s - r)),
              (this._offsetPrev = i * u),
              (this._offsetNext = a * u);
          },
          interpolate_: function (e, t, r, n) {
            for (
              var i = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = e * o,
                c = s - o,
                u = this._offsetPrev,
                l = this._offsetNext,
                h = this._weightPrev,
                d = this._weightNext,
                p = (r - t) / (n - t),
                f = p * p,
                m = f * p,
                v = -h * m + 2 * h * f - h * p,
                g = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
                y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
                x = d * m - d * f,
                b = 0;
              b !== o;
              ++b
            )
              i[b] = v * a[u + b] + g * a[c + b] + y * a[s + b] + x * a[l + b];
            return i;
          },
        })),
        (xs.prototype = Object.assign(Object.create(gs.prototype), {
          constructor: xs,
          interpolate_: function (e, t, r, n) {
            for (
              var i = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = e * o,
                c = s - o,
                u = (r - t) / (n - t),
                l = 1 - u,
                h = 0;
              h !== o;
              ++h
            )
              i[h] = a[c + h] * l + a[s + h] * u;
            return i;
          },
        })),
        (bs.prototype = Object.assign(Object.create(gs.prototype), {
          constructor: bs,
          interpolate_: function (e) {
            return this.copySampleValue_(e - 1);
          },
        })),
        Object.assign(ws, {
          toJSON: function (e) {
            var t,
              r = e.constructor;
            if (void 0 !== r.toJSON) t = r.toJSON(e);
            else {
              t = {
                name: e.name,
                times: vs.convertArray(e.times, Array),
                values: vs.convertArray(e.values, Array),
              };
              var n = e.getInterpolation();
              n !== e.DefaultInterpolation && (t.interpolation = n);
            }
            return (t.type = e.ValueTypeName), t;
          },
        }),
        Object.assign(ws.prototype, {
          constructor: ws,
          TimeBufferType: Float32Array,
          ValueBufferType: Float32Array,
          DefaultInterpolation: Pt,
          InterpolantFactoryMethodDiscrete: function (e) {
            return new bs(this.times, this.values, this.getValueSize(), e);
          },
          InterpolantFactoryMethodLinear: function (e) {
            return new xs(this.times, this.values, this.getValueSize(), e);
          },
          InterpolantFactoryMethodSmooth: function (e) {
            return new ys(this.times, this.values, this.getValueSize(), e);
          },
          setInterpolation: function (e) {
            var t;
            switch (e) {
              case Ct:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
              case Pt:
                t = this.InterpolantFactoryMethodLinear;
                break;
              case Ot:
                t = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === t) {
              var r =
                'unsupported interpolation for ' +
                this.ValueTypeName +
                ' keyframe track named ' +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (e === this.DefaultInterpolation) throw new Error(r);
                this.setInterpolation(this.DefaultInterpolation);
              }
              return console.warn('THREE.KeyframeTrack:', r), this;
            }
            return (this.createInterpolant = t), this;
          },
          getInterpolation: function () {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return Ct;
              case this.InterpolantFactoryMethodLinear:
                return Pt;
              case this.InterpolantFactoryMethodSmooth:
                return Ot;
            }
          },
          getValueSize: function () {
            return this.values.length / this.times.length;
          },
          shift: function (e) {
            if (0 !== e) for (var t = this.times, r = 0, n = t.length; r !== n; ++r) t[r] += e;
            return this;
          },
          scale: function (e) {
            if (1 !== e) for (var t = this.times, r = 0, n = t.length; r !== n; ++r) t[r] *= e;
            return this;
          },
          trim: function (e, t) {
            for (var r = this.times, n = r.length, i = 0, a = n - 1; i !== n && r[i] < e; ) ++i;
            for (; -1 !== a && r[a] > t; ) --a;
            if ((++a, 0 !== i || a !== n)) {
              i >= a && (i = (a = Math.max(a, 1)) - 1);
              var o = this.getValueSize();
              (this.times = vs.arraySlice(r, i, a)),
                (this.values = vs.arraySlice(this.values, i * o, a * o));
            }
            return this;
          },
          validate: function () {
            var e = !0,
              t = this.getValueSize();
            t - Math.floor(t) != 0 &&
              (console.error('THREE.KeyframeTrack: Invalid value size in track.', this), (e = !1));
            var r = this.times,
              n = this.values,
              i = r.length;
            0 === i && (console.error('THREE.KeyframeTrack: Track is empty.', this), (e = !1));
            for (var a = null, o = 0; o !== i; o++) {
              var s = r[o];
              if ('number' == typeof s && isNaN(s)) {
                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, o, s),
                  (e = !1);
                break;
              }
              if (null !== a && a > s) {
                console.error('THREE.KeyframeTrack: Out of order keys.', this, o, s, a), (e = !1);
                break;
              }
              a = s;
            }
            if (void 0 !== n && vs.isTypedArray(n)) {
              o = 0;
              for (var c = n.length; o !== c; ++o) {
                var u = n[o];
                if (isNaN(u)) {
                  console.error('THREE.KeyframeTrack: Value is not a valid number.', this, o, u),
                    (e = !1);
                  break;
                }
              }
            }
            return e;
          },
          optimize: function () {
            for (
              var e = this.times,
                t = this.values,
                r = this.getValueSize(),
                n = this.getInterpolation() === Ot,
                i = 1,
                a = e.length - 1,
                o = 1;
              o < a;
              ++o
            ) {
              var s = !1,
                c = e[o];
              if (c !== e[o + 1] && (1 !== o || c !== c[0]))
                if (n) s = !0;
                else
                  for (var u = o * r, l = u - r, h = u + r, d = 0; d !== r; ++d) {
                    var p = t[u + d];
                    if (p !== t[l + d] || p !== t[h + d]) {
                      s = !0;
                      break;
                    }
                  }
              if (s) {
                if (o !== i) {
                  e[i] = e[o];
                  var f = o * r,
                    m = i * r;
                  for (d = 0; d !== r; ++d) t[m + d] = t[f + d];
                }
                ++i;
              }
            }
            if (a > 0) {
              e[i] = e[a];
              for (f = a * r, m = i * r, d = 0; d !== r; ++d) t[m + d] = t[f + d];
              ++i;
            }
            return (
              i !== e.length &&
                ((this.times = vs.arraySlice(e, 0, i)), (this.values = vs.arraySlice(t, 0, i * r))),
              this
            );
          },
          clone: function () {
            var e = vs.arraySlice(this.times, 0),
              t = vs.arraySlice(this.values, 0),
              r = new (0, this.constructor)(this.name, e, t);
            return (r.createInterpolant = this.createInterpolant), r;
          },
        }),
        (_s.prototype = Object.assign(Object.create(ws.prototype), {
          constructor: _s,
          ValueTypeName: 'bool',
          ValueBufferType: Array,
          DefaultInterpolation: Ct,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0,
        })),
        (Ms.prototype = Object.assign(Object.create(ws.prototype), {
          constructor: Ms,
          ValueTypeName: 'color',
        })),
        (Ss.prototype = Object.assign(Object.create(ws.prototype), {
          constructor: Ss,
          ValueTypeName: 'number',
        })),
        (Es.prototype = Object.assign(Object.create(gs.prototype), {
          constructor: Es,
          interpolate_: function (e, t, r, n) {
            for (
              var i = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = e * o,
                c = (r - t) / (n - t),
                u = s + o;
              s !== u;
              s += 4
            )
              er.slerpFlat(i, 0, a, s - o, a, s, c);
            return i;
          },
        })),
        (Ts.prototype = Object.assign(Object.create(ws.prototype), {
          constructor: Ts,
          ValueTypeName: 'quaternion',
          DefaultInterpolation: Pt,
          InterpolantFactoryMethodLinear: function (e) {
            return new Es(this.times, this.values, this.getValueSize(), e);
          },
          InterpolantFactoryMethodSmooth: void 0,
        })),
        (As.prototype = Object.assign(Object.create(ws.prototype), {
          constructor: As,
          ValueTypeName: 'string',
          ValueBufferType: Array,
          DefaultInterpolation: Ct,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0,
        })),
        (Ls.prototype = Object.assign(Object.create(ws.prototype), {
          constructor: Ls,
          ValueTypeName: 'vector',
        })),
        Object.assign(Rs, {
          parse: function (e) {
            for (var t = [], r = e.tracks, n = 1 / (e.fps || 1), i = 0, a = r.length; i !== a; ++i)
              t.push(Cs(r[i]).scale(n));
            return new Rs(e.name, e.duration, t);
          },
          toJSON: function (e) {
            for (
              var t = [],
                r = e.tracks,
                n = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid },
                i = 0,
                a = r.length;
              i !== a;
              ++i
            )
              t.push(ws.toJSON(r[i]));
            return n;
          },
          CreateFromMorphTargetSequence: function (e, t, r, n) {
            for (var i = t.length, a = [], o = 0; o < i; o++) {
              var s = [],
                c = [];
              s.push((o + i - 1) % i, o, (o + 1) % i), c.push(0, 1, 0);
              var u = vs.getKeyframeOrder(s);
              (s = vs.sortedArray(s, 1, u)),
                (c = vs.sortedArray(c, 1, u)),
                n || 0 !== s[0] || (s.push(i), c.push(c[0])),
                a.push(new Ss('.morphTargetInfluences[' + t[o].name + ']', s, c).scale(1 / r));
            }
            return new Rs(e, -1, a);
          },
          findByName: function (e, t) {
            var r = e;
            if (!Array.isArray(e)) {
              var n = e;
              r = (n.geometry && n.geometry.animations) || n.animations;
            }
            for (var i = 0; i < r.length; i++) if (r[i].name === t) return r[i];
            return null;
          },
          CreateClipsFromMorphTargetSequences: function (e, t, r) {
            for (var n = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
              var s = e[a],
                c = s.name.match(i);
              if (c && c.length > 1) {
                var u = n[(h = c[1])];
                u || (n[h] = u = []), u.push(s);
              }
            }
            var l = [];
            for (var h in n) l.push(Rs.CreateFromMorphTargetSequence(h, n[h], t, r));
            return l;
          },
          parseAnimation: function (e, t) {
            if (!e)
              return console.error('THREE.AnimationClip: No animation in JSONLoader data.'), null;
            for (
              var r = function (e, t, r, n, i) {
                  if (0 !== r.length) {
                    var a = [],
                      o = [];
                    vs.flattenJSON(r, a, o, n), 0 !== a.length && i.push(new e(t, a, o));
                  }
                },
                n = [],
                i = e.name || 'default',
                a = e.length || -1,
                o = e.fps || 30,
                s = e.hierarchy || [],
                c = 0;
              c < s.length;
              c++
            ) {
              var u = s[c].keys;
              if (u && 0 !== u.length)
                if (u[0].morphTargets) {
                  for (var l = {}, h = 0; h < u.length; h++)
                    if (u[h].morphTargets)
                      for (var d = 0; d < u[h].morphTargets.length; d++)
                        l[u[h].morphTargets[d]] = -1;
                  for (var p in l) {
                    var f = [],
                      m = [];
                    for (d = 0; d !== u[h].morphTargets.length; ++d) {
                      var v = u[h];
                      f.push(v.time), m.push(v.morphTarget === p ? 1 : 0);
                    }
                    n.push(new Ss('.morphTargetInfluence[' + p + ']', f, m));
                  }
                  a = l.length * (o || 1);
                } else {
                  var g = '.bones[' + t[c].name + ']';
                  r(Ls, g + '.position', u, 'pos', n),
                    r(Ts, g + '.quaternion', u, 'rot', n),
                    r(Ls, g + '.scale', u, 'scl', n);
                }
            }
            return 0 === n.length ? null : new Rs(i, a, n);
          },
        }),
        Object.assign(Rs.prototype, {
          resetDuration: function () {
            for (var e = 0, t = 0, r = this.tracks.length; t !== r; ++t) {
              var n = this.tracks[t];
              e = Math.max(e, n.times[n.times.length - 1]);
            }
            return (this.duration = e), this;
          },
          trim: function () {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this;
          },
          validate: function () {
            for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
            return e;
          },
          optimize: function () {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this;
          },
          clone: function () {
            for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
            return new Rs(this.name, this.duration, e);
          },
        });
      var Ps = {
        enabled: !1,
        files: {},
        add: function (e, t) {
          !1 !== this.enabled && (this.files[e] = t);
        },
        get: function (e) {
          if (!1 !== this.enabled) return this.files[e];
        },
        remove: function (e) {
          delete this.files[e];
        },
        clear: function () {
          this.files = {};
        },
      };
      function Os(e, t, r) {
        var n = this,
          i = !1,
          a = 0,
          o = 0,
          s = void 0;
        (this.onStart = void 0),
          (this.onLoad = e),
          (this.onProgress = t),
          (this.onError = r),
          (this.itemStart = function (e) {
            o++, !1 === i && void 0 !== n.onStart && n.onStart(e, a, o), (i = !0);
          }),
          (this.itemEnd = function (e) {
            a++,
              void 0 !== n.onProgress && n.onProgress(e, a, o),
              a === o && ((i = !1), void 0 !== n.onLoad && n.onLoad());
          }),
          (this.itemError = function (e) {
            void 0 !== n.onError && n.onError(e);
          }),
          (this.resolveURL = function (e) {
            return s ? s(e) : e;
          }),
          (this.setURLModifier = function (e) {
            return (s = e), this;
          });
      }
      var Is = new Os(),
        Ds = {};
      function Bs(e) {
        this.manager = void 0 !== e ? e : Is;
      }
      function Ns(e) {
        this.manager = void 0 !== e ? e : Is;
      }
      function Us(e) {
        (this.manager = void 0 !== e ? e : Is), (this._parser = null);
      }
      function Gs(e) {
        (this.manager = void 0 !== e ? e : Is), (this._parser = null);
      }
      function Fs(e) {
        this.manager = void 0 !== e ? e : Is;
      }
      function zs(e) {
        this.manager = void 0 !== e ? e : Is;
      }
      function Hs(e) {
        this.manager = void 0 !== e ? e : Is;
      }
      function ks() {
        (this.type = 'Curve'), (this.arcLengthDivisions = 200);
      }
      function Vs(e, t, r, n, i, a, o, s) {
        ks.call(this),
          (this.type = 'EllipseCurve'),
          (this.aX = e || 0),
          (this.aY = t || 0),
          (this.xRadius = r || 1),
          (this.yRadius = n || 1),
          (this.aStartAngle = i || 0),
          (this.aEndAngle = a || 2 * Math.PI),
          (this.aClockwise = o || !1),
          (this.aRotation = s || 0);
      }
      function js(e, t, r, n, i, a) {
        Vs.call(this, e, t, r, r, n, i, a), (this.type = 'ArcCurve');
      }
      function Ws() {
        var e = 0,
          t = 0,
          r = 0,
          n = 0;
        function i(i, a, o, s) {
          (e = i), (t = o), (r = -3 * i + 3 * a - 2 * o - s), (n = 2 * i - 2 * a + o + s);
        }
        return {
          initCatmullRom: function (e, t, r, n, a) {
            i(t, r, a * (r - e), a * (n - t));
          },
          initNonuniformCatmullRom: function (e, t, r, n, a, o, s) {
            var c = (t - e) / a - (r - e) / (a + o) + (r - t) / o,
              u = (r - t) / o - (n - t) / (o + s) + (n - r) / s;
            i(t, r, (c *= o), (u *= o));
          },
          calc: function (i) {
            var a = i * i;
            return e + t * i + r * a + n * (a * i);
          },
        };
      }
      Object.assign(Bs.prototype, {
        load: function (e, t, r, n) {
          void 0 === e && (e = ''),
            void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          var i = this,
            a = Ps.get(e);
          if (void 0 !== a)
            return (
              i.manager.itemStart(e),
              setTimeout(function () {
                t && t(a), i.manager.itemEnd(e);
              }, 0),
              a
            );
          if (void 0 === Ds[e]) {
            var o = e.match(/^data:(.*?)(;base64)?,(.*)$/);
            if (o) {
              var s = o[1],
                c = !!o[2],
                u = o[3];
              (u = decodeURIComponent(u)), c && (u = atob(u));
              try {
                var l,
                  h = (this.responseType || '').toLowerCase();
                switch (h) {
                  case 'arraybuffer':
                  case 'blob':
                    for (var d = new Uint8Array(u.length), p = 0; p < u.length; p++)
                      d[p] = u.charCodeAt(p);
                    l = 'blob' === h ? new Blob([d.buffer], { type: s }) : d.buffer;
                    break;
                  case 'document':
                    var f = new DOMParser();
                    l = f.parseFromString(u, s);
                    break;
                  case 'json':
                    l = JSON.parse(u);
                    break;
                  default:
                    l = u;
                }
                setTimeout(function () {
                  t && t(l), i.manager.itemEnd(e);
                }, 0);
              } catch (t) {
                setTimeout(function () {
                  n && n(t), i.manager.itemError(e), i.manager.itemEnd(e);
                }, 0);
              }
            } else {
              (Ds[e] = []), Ds[e].push({ onLoad: t, onProgress: r, onError: n });
              var m = new XMLHttpRequest();
              for (var v in (m.open('GET', e, !0),
              m.addEventListener(
                'load',
                function (t) {
                  var r = this.response;
                  Ps.add(e, r);
                  var n = Ds[e];
                  if ((delete Ds[e], 200 === this.status || 0 === this.status)) {
                    0 === this.status && console.warn('THREE.FileLoader: HTTP Status 0 received.');
                    for (var a = 0, o = n.length; a < o; a++) {
                      (s = n[a]).onLoad && s.onLoad(r);
                    }
                    i.manager.itemEnd(e);
                  } else {
                    for (a = 0, o = n.length; a < o; a++) {
                      var s;
                      (s = n[a]).onError && s.onError(t);
                    }
                    i.manager.itemError(e), i.manager.itemEnd(e);
                  }
                },
                !1,
              ),
              m.addEventListener(
                'progress',
                function (t) {
                  for (var r = Ds[e], n = 0, i = r.length; n < i; n++) {
                    var a = r[n];
                    a.onProgress && a.onProgress(t);
                  }
                },
                !1,
              ),
              m.addEventListener(
                'error',
                function (t) {
                  var r = Ds[e];
                  delete Ds[e];
                  for (var n = 0, a = r.length; n < a; n++) {
                    var o = r[n];
                    o.onError && o.onError(t);
                  }
                  i.manager.itemError(e), i.manager.itemEnd(e);
                },
                !1,
              ),
              m.addEventListener(
                'abort',
                function (t) {
                  var r = Ds[e];
                  delete Ds[e];
                  for (var n = 0, a = r.length; n < a; n++) {
                    var o = r[n];
                    o.onError && o.onError(t);
                  }
                  i.manager.itemError(e), i.manager.itemEnd(e);
                },
                !1,
              ),
              void 0 !== this.responseType && (m.responseType = this.responseType),
              void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials),
              m.overrideMimeType &&
                m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : 'text/plain'),
              this.requestHeader))
                m.setRequestHeader(v, this.requestHeader[v]);
              m.send(null);
            }
            return i.manager.itemStart(e), m;
          }
          Ds[e].push({ onLoad: t, onProgress: r, onError: n });
        },
        setPath: function (e) {
          return (this.path = e), this;
        },
        setResponseType: function (e) {
          return (this.responseType = e), this;
        },
        setWithCredentials: function (e) {
          return (this.withCredentials = e), this;
        },
        setMimeType: function (e) {
          return (this.mimeType = e), this;
        },
        setRequestHeader: function (e) {
          return (this.requestHeader = e), this;
        },
      }),
        Object.assign(Ns.prototype, {
          load: function (e, t, r, n) {
            var i = this,
              a = new Bs(i.manager);
            a.setPath(i.path),
              a.load(
                e,
                function (e) {
                  t(i.parse(JSON.parse(e)));
                },
                r,
                n,
              );
          },
          parse: function (e, t) {
            for (var r = [], n = 0; n < e.length; n++) {
              var i = Rs.parse(e[n]);
              r.push(i);
            }
            t(r);
          },
          setPath: function (e) {
            return (this.path = e), this;
          },
        }),
        Object.assign(Us.prototype, {
          load: function (e, t, r, n) {
            var i = this,
              a = [],
              o = new ka();
            o.image = a;
            var s = new Bs(this.manager);
            function c(c) {
              s.load(
                e[c],
                function (e) {
                  var r = i._parser(e, !0);
                  (a[c] = {
                    width: r.width,
                    height: r.height,
                    format: r.format,
                    mipmaps: r.mipmaps,
                  }),
                    6 === (u += 1) &&
                      (1 === r.mipmapCount && (o.minFilter = De),
                      (o.format = r.format),
                      (o.needsUpdate = !0),
                      t && t(o));
                },
                r,
                n,
              );
            }
            if ((s.setPath(this.path), s.setResponseType('arraybuffer'), Array.isArray(e)))
              for (var u = 0, l = 0, h = e.length; l < h; ++l) c(l);
            else
              s.load(
                e,
                function (e) {
                  var r = i._parser(e, !0);
                  if (r.isCubemap)
                    for (var n = r.mipmaps.length / r.mipmapCount, s = 0; s < n; s++) {
                      a[s] = { mipmaps: [] };
                      for (var c = 0; c < r.mipmapCount; c++)
                        a[s].mipmaps.push(r.mipmaps[s * r.mipmapCount + c]),
                          (a[s].format = r.format),
                          (a[s].width = r.width),
                          (a[s].height = r.height);
                    }
                  else
                    (o.image.width = r.width), (o.image.height = r.height), (o.mipmaps = r.mipmaps);
                  1 === r.mipmapCount && (o.minFilter = De),
                    (o.format = r.format),
                    (o.needsUpdate = !0),
                    t && t(o);
                },
                r,
                n,
              );
            return o;
          },
          setPath: function (e) {
            return (this.path = e), this;
          },
        }),
        Object.assign(Gs.prototype, {
          load: function (e, t, r, n) {
            var i = this,
              a = new mr(),
              o = new Bs(this.manager);
            return (
              o.setResponseType('arraybuffer'),
              o.setPath(this.path),
              o.load(
                e,
                function (e) {
                  var r = i._parser(e);
                  r &&
                    (void 0 !== r.image
                      ? (a.image = r.image)
                      : void 0 !== r.data &&
                        ((a.image.width = r.width),
                        (a.image.height = r.height),
                        (a.image.data = r.data)),
                    (a.wrapS = void 0 !== r.wrapS ? r.wrapS : Re),
                    (a.wrapT = void 0 !== r.wrapT ? r.wrapT : Re),
                    (a.magFilter = void 0 !== r.magFilter ? r.magFilter : De),
                    (a.minFilter = void 0 !== r.minFilter ? r.minFilter : Ne),
                    (a.anisotropy = void 0 !== r.anisotropy ? r.anisotropy : 1),
                    void 0 !== r.format && (a.format = r.format),
                    void 0 !== r.type && (a.type = r.type),
                    void 0 !== r.mipmaps && (a.mipmaps = r.mipmaps),
                    1 === r.mipmapCount && (a.minFilter = De),
                    (a.needsUpdate = !0),
                    t && t(a, r));
                },
                r,
                n,
              ),
              a
            );
          },
          setPath: function (e) {
            return (this.path = e), this;
          },
        }),
        Object.assign(Fs.prototype, {
          crossOrigin: 'anonymous',
          load: function (e, t, r, n) {
            void 0 === e && (e = ''),
              void 0 !== this.path && (e = this.path + e),
              (e = this.manager.resolveURL(e));
            var i = this,
              a = Ps.get(e);
            if (void 0 !== a)
              return (
                i.manager.itemStart(e),
                setTimeout(function () {
                  t && t(a), i.manager.itemEnd(e);
                }, 0),
                a
              );
            var o = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
            function s() {
              o.removeEventListener('load', s, !1),
                o.removeEventListener('error', c, !1),
                Ps.add(e, this),
                t && t(this),
                i.manager.itemEnd(e);
            }
            function c(t) {
              o.removeEventListener('load', s, !1),
                o.removeEventListener('error', c, !1),
                n && n(t),
                i.manager.itemError(e),
                i.manager.itemEnd(e);
            }
            return (
              o.addEventListener('load', s, !1),
              o.addEventListener('error', c, !1),
              'data:' !== e.substr(0, 5) &&
                void 0 !== this.crossOrigin &&
                (o.crossOrigin = this.crossOrigin),
              i.manager.itemStart(e),
              (o.src = e),
              o
            );
          },
          setCrossOrigin: function (e) {
            return (this.crossOrigin = e), this;
          },
          setPath: function (e) {
            return (this.path = e), this;
          },
        }),
        Object.assign(zs.prototype, {
          crossOrigin: 'anonymous',
          load: function (e, t, r, n) {
            var i = new kn(),
              a = new Fs(this.manager);
            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
            var o = 0;
            function s(r) {
              a.load(
                e[r],
                function (e) {
                  (i.images[r] = e), 6 === ++o && ((i.needsUpdate = !0), t && t(i));
                },
                void 0,
                n,
              );
            }
            for (var c = 0; c < e.length; ++c) s(c);
            return i;
          },
          setCrossOrigin: function (e) {
            return (this.crossOrigin = e), this;
          },
          setPath: function (e) {
            return (this.path = e), this;
          },
        }),
        Object.assign(Hs.prototype, {
          crossOrigin: 'anonymous',
          load: function (e, t, r, n) {
            var i = new lr(),
              a = new Fs(this.manager);
            return (
              a.setCrossOrigin(this.crossOrigin),
              a.setPath(this.path),
              a.load(
                e,
                function (r) {
                  i.image = r;
                  var n = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                  (i.format = n ? Ze : Ke), (i.needsUpdate = !0), void 0 !== t && t(i);
                },
                r,
                n,
              ),
              i
            );
          },
          setCrossOrigin: function (e) {
            return (this.crossOrigin = e), this;
          },
          setPath: function (e) {
            return (this.path = e), this;
          },
        }),
        Object.assign(ks.prototype, {
          getPoint: function () {
            return console.warn('THREE.Curve: .getPoint() not implemented.'), null;
          },
          getPointAt: function (e, t) {
            var r = this.getUtoTmapping(e);
            return this.getPoint(r, t);
          },
          getPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], r = 0; r <= e; r++) t.push(this.getPoint(r / e));
            return t;
          },
          getSpacedPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], r = 0; r <= e; r++) t.push(this.getPointAt(r / e));
            return t;
          },
          getLength: function () {
            var e = this.getLengths();
            return e[e.length - 1];
          },
          getLengths: function (e) {
            if (
              (void 0 === e && (e = this.arcLengthDivisions),
              this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            )
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t,
              r,
              n = [],
              i = this.getPoint(0),
              a = 0;
            for (n.push(0), r = 1; r <= e; r++)
              (a += (t = this.getPoint(r / e)).distanceTo(i)), n.push(a), (i = t);
            return (this.cacheArcLengths = n), n;
          },
          updateArcLengths: function () {
            (this.needsUpdate = !0), this.getLengths();
          },
          getUtoTmapping: function (e, t) {
            var r,
              n = this.getLengths(),
              i = 0,
              a = n.length;
            r = t || e * n[a - 1];
            for (var o, s = 0, c = a - 1; s <= c; )
              if ((o = n[(i = Math.floor(s + (c - s) / 2))] - r) < 0) s = i + 1;
              else {
                if (!(o > 0)) {
                  c = i;
                  break;
                }
                c = i - 1;
              }
            if (n[(i = c)] === r) return i / (a - 1);
            var u = n[i];
            return (i + (r - u) / (n[i + 1] - u)) / (a - 1);
          },
          getTangent: function (e) {
            var t = e - 1e-4,
              r = e + 1e-4;
            t < 0 && (t = 0), r > 1 && (r = 1);
            var n = this.getPoint(t);
            return this.getPoint(r).clone().sub(n).normalize();
          },
          getTangentAt: function (e) {
            var t = this.getUtoTmapping(e);
            return this.getTangent(t);
          },
          computeFrenetFrames: function (e, t) {
            var r,
              n,
              i,
              a = new tr(),
              o = [],
              s = [],
              c = [],
              u = new tr(),
              l = new $t();
            for (r = 0; r <= e; r++) (n = r / e), (o[r] = this.getTangentAt(n)), o[r].normalize();
            (s[0] = new tr()), (c[0] = new tr());
            var h = Number.MAX_VALUE,
              d = Math.abs(o[0].x),
              p = Math.abs(o[0].y),
              f = Math.abs(o[0].z);
            for (
              d <= h && ((h = d), a.set(1, 0, 0)),
                p <= h && ((h = p), a.set(0, 1, 0)),
                f <= h && a.set(0, 0, 1),
                u.crossVectors(o[0], a).normalize(),
                s[0].crossVectors(o[0], u),
                c[0].crossVectors(o[0], s[0]),
                r = 1;
              r <= e;
              r++
            )
              (s[r] = s[r - 1].clone()),
                (c[r] = c[r - 1].clone()),
                u.crossVectors(o[r - 1], o[r]),
                u.length() > Number.EPSILON &&
                  (u.normalize(),
                  (i = Math.acos(Kt.clamp(o[r - 1].dot(o[r]), -1, 1))),
                  s[r].applyMatrix4(l.makeRotationAxis(u, i))),
                c[r].crossVectors(o[r], s[r]);
            if (!0 === t)
              for (
                i = Math.acos(Kt.clamp(s[0].dot(s[e]), -1, 1)),
                  i /= e,
                  o[0].dot(u.crossVectors(s[0], s[e])) > 0 && (i = -i),
                  r = 1;
                r <= e;
                r++
              )
                s[r].applyMatrix4(l.makeRotationAxis(o[r], i * r)), c[r].crossVectors(o[r], s[r]);
            return { tangents: o, normals: s, binormals: c };
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (this.arcLengthDivisions = e.arcLengthDivisions), this;
          },
          toJSON: function () {
            var e = { metadata: { version: 4.5, type: 'Curve', generator: 'Curve.toJSON' } };
            return (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e;
          },
          fromJSON: function (e) {
            return (this.arcLengthDivisions = e.arcLengthDivisions), this;
          },
        }),
        (Vs.prototype = Object.create(ks.prototype)),
        (Vs.prototype.constructor = Vs),
        (Vs.prototype.isEllipseCurve = !0),
        (Vs.prototype.getPoint = function (e, t) {
          for (
            var r = t || new Qt(),
              n = 2 * Math.PI,
              i = this.aEndAngle - this.aStartAngle,
              a = Math.abs(i) < Number.EPSILON;
            i < 0;

          )
            i += n;
          for (; i > n; ) i -= n;
          i < Number.EPSILON && (i = a ? 0 : n),
            !0 !== this.aClockwise || a || (i === n ? (i = -n) : (i -= n));
          var o = this.aStartAngle + e * i,
            s = this.aX + this.xRadius * Math.cos(o),
            c = this.aY + this.yRadius * Math.sin(o);
          if (0 !== this.aRotation) {
            var u = Math.cos(this.aRotation),
              l = Math.sin(this.aRotation),
              h = s - this.aX,
              d = c - this.aY;
            (s = h * u - d * l + this.aX), (c = h * l + d * u + this.aY);
          }
          return r.set(s, c);
        }),
        (Vs.prototype.copy = function (e) {
          return (
            ks.prototype.copy.call(this, e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }),
        (Vs.prototype.toJSON = function () {
          var e = ks.prototype.toJSON.call(this);
          return (
            (e.aX = this.aX),
            (e.aY = this.aY),
            (e.xRadius = this.xRadius),
            (e.yRadius = this.yRadius),
            (e.aStartAngle = this.aStartAngle),
            (e.aEndAngle = this.aEndAngle),
            (e.aClockwise = this.aClockwise),
            (e.aRotation = this.aRotation),
            e
          );
        }),
        (Vs.prototype.fromJSON = function (e) {
          return (
            ks.prototype.fromJSON.call(this, e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }),
        (js.prototype = Object.create(Vs.prototype)),
        (js.prototype.constructor = js),
        (js.prototype.isArcCurve = !0);
      var qs = new tr(),
        Xs = new Ws(),
        Ys = new Ws(),
        Js = new Ws();
      function Zs(e, t, r, n) {
        ks.call(this),
          (this.type = 'CatmullRomCurve3'),
          (this.points = e || []),
          (this.closed = t || !1),
          (this.curveType = r || 'centripetal'),
          (this.tension = n || 0.5);
      }
      function Ks(e, t, r, n, i) {
        var a = 0.5 * (n - t),
          o = 0.5 * (i - r),
          s = e * e;
        return (2 * r - 2 * n + a + o) * (e * s) + (-3 * r + 3 * n - 2 * a - o) * s + a * e + r;
      }
      function Qs(e, t, r, n) {
        return (
          (function (e, t) {
            var r = 1 - e;
            return r * r * t;
          })(e, t) +
          (function (e, t) {
            return 2 * (1 - e) * e * t;
          })(e, r) +
          (function (e, t) {
            return e * e * t;
          })(e, n)
        );
      }
      function $s(e, t, r, n, i) {
        return (
          (function (e, t) {
            var r = 1 - e;
            return r * r * r * t;
          })(e, t) +
          (function (e, t) {
            var r = 1 - e;
            return 3 * r * r * e * t;
          })(e, r) +
          (function (e, t) {
            return 3 * (1 - e) * e * e * t;
          })(e, n) +
          (function (e, t) {
            return e * e * e * t;
          })(e, i)
        );
      }
      function ec(e, t, r, n) {
        ks.call(this),
          (this.type = 'CubicBezierCurve'),
          (this.v0 = e || new Qt()),
          (this.v1 = t || new Qt()),
          (this.v2 = r || new Qt()),
          (this.v3 = n || new Qt());
      }
      function tc(e, t, r, n) {
        ks.call(this),
          (this.type = 'CubicBezierCurve3'),
          (this.v0 = e || new tr()),
          (this.v1 = t || new tr()),
          (this.v2 = r || new tr()),
          (this.v3 = n || new tr());
      }
      function rc(e, t) {
        ks.call(this),
          (this.type = 'LineCurve'),
          (this.v1 = e || new Qt()),
          (this.v2 = t || new Qt());
      }
      function nc(e, t) {
        ks.call(this),
          (this.type = 'LineCurve3'),
          (this.v1 = e || new tr()),
          (this.v2 = t || new tr());
      }
      function ic(e, t, r) {
        ks.call(this),
          (this.type = 'QuadraticBezierCurve'),
          (this.v0 = e || new Qt()),
          (this.v1 = t || new Qt()),
          (this.v2 = r || new Qt());
      }
      function ac(e, t, r) {
        ks.call(this),
          (this.type = 'QuadraticBezierCurve3'),
          (this.v0 = e || new tr()),
          (this.v1 = t || new tr()),
          (this.v2 = r || new tr());
      }
      function oc(e) {
        ks.call(this), (this.type = 'SplineCurve'), (this.points = e || []);
      }
      (Zs.prototype = Object.create(ks.prototype)),
        (Zs.prototype.constructor = Zs),
        (Zs.prototype.isCatmullRomCurve3 = !0),
        (Zs.prototype.getPoint = function (e, t) {
          var r,
            n,
            i,
            a,
            o = t || new tr(),
            s = this.points,
            c = s.length,
            u = (c - (this.closed ? 0 : 1)) * e,
            l = Math.floor(u),
            h = u - l;
          if (
            (this.closed
              ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c)
              : 0 === h && l === c - 1 && ((l = c - 2), (h = 1)),
            this.closed || l > 0
              ? (r = s[(l - 1) % c])
              : (qs.subVectors(s[0], s[1]).add(s[0]), (r = qs)),
            (n = s[l % c]),
            (i = s[(l + 1) % c]),
            this.closed || l + 2 < c
              ? (a = s[(l + 2) % c])
              : (qs.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), (a = qs)),
            'centripetal' === this.curveType || 'chordal' === this.curveType)
          ) {
            var d = 'chordal' === this.curveType ? 0.5 : 0.25,
              p = Math.pow(r.distanceToSquared(n), d),
              f = Math.pow(n.distanceToSquared(i), d),
              m = Math.pow(i.distanceToSquared(a), d);
            f < 1e-4 && (f = 1),
              p < 1e-4 && (p = f),
              m < 1e-4 && (m = f),
              Xs.initNonuniformCatmullRom(r.x, n.x, i.x, a.x, p, f, m),
              Ys.initNonuniformCatmullRom(r.y, n.y, i.y, a.y, p, f, m),
              Js.initNonuniformCatmullRom(r.z, n.z, i.z, a.z, p, f, m);
          } else
            'catmullrom' === this.curveType &&
              (Xs.initCatmullRom(r.x, n.x, i.x, a.x, this.tension),
              Ys.initCatmullRom(r.y, n.y, i.y, a.y, this.tension),
              Js.initCatmullRom(r.z, n.z, i.z, a.z, this.tension));
          return o.set(Xs.calc(h), Ys.calc(h), Js.calc(h)), o;
        }),
        (Zs.prototype.copy = function (e) {
          ks.prototype.copy.call(this, e), (this.points = []);
          for (var t = 0, r = e.points.length; t < r; t++) {
            var n = e.points[t];
            this.points.push(n.clone());
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }),
        (Zs.prototype.toJSON = function () {
          var e = ks.prototype.toJSON.call(this);
          e.points = [];
          for (var t = 0, r = this.points.length; t < r; t++) {
            var n = this.points[t];
            e.points.push(n.toArray());
          }
          return (
            (e.closed = this.closed), (e.curveType = this.curveType), (e.tension = this.tension), e
          );
        }),
        (Zs.prototype.fromJSON = function (e) {
          ks.prototype.fromJSON.call(this, e), (this.points = []);
          for (var t = 0, r = e.points.length; t < r; t++) {
            var n = e.points[t];
            this.points.push(new tr().fromArray(n));
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }),
        (ec.prototype = Object.create(ks.prototype)),
        (ec.prototype.constructor = ec),
        (ec.prototype.isCubicBezierCurve = !0),
        (ec.prototype.getPoint = function (e, t) {
          var r = t || new Qt(),
            n = this.v0,
            i = this.v1,
            a = this.v2,
            o = this.v3;
          return r.set($s(e, n.x, i.x, a.x, o.x), $s(e, n.y, i.y, a.y, o.y)), r;
        }),
        (ec.prototype.copy = function (e) {
          return (
            ks.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }),
        (ec.prototype.toJSON = function () {
          var e = ks.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }),
        (ec.prototype.fromJSON = function (e) {
          return (
            ks.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }),
        (tc.prototype = Object.create(ks.prototype)),
        (tc.prototype.constructor = tc),
        (tc.prototype.isCubicBezierCurve3 = !0),
        (tc.prototype.getPoint = function (e, t) {
          var r = t || new tr(),
            n = this.v0,
            i = this.v1,
            a = this.v2,
            o = this.v3;
          return (
            r.set($s(e, n.x, i.x, a.x, o.x), $s(e, n.y, i.y, a.y, o.y), $s(e, n.z, i.z, a.z, o.z)),
            r
          );
        }),
        (tc.prototype.copy = function (e) {
          return (
            ks.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }),
        (tc.prototype.toJSON = function () {
          var e = ks.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }),
        (tc.prototype.fromJSON = function (e) {
          return (
            ks.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }),
        (rc.prototype = Object.create(ks.prototype)),
        (rc.prototype.constructor = rc),
        (rc.prototype.isLineCurve = !0),
        (rc.prototype.getPoint = function (e, t) {
          var r = t || new Qt();
          return (
            1 === e
              ? r.copy(this.v2)
              : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
            r
          );
        }),
        (rc.prototype.getPointAt = function (e, t) {
          return this.getPoint(e, t);
        }),
        (rc.prototype.getTangent = function () {
          return this.v2.clone().sub(this.v1).normalize();
        }),
        (rc.prototype.copy = function (e) {
          return ks.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }),
        (rc.prototype.toJSON = function () {
          var e = ks.prototype.toJSON.call(this);
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }),
        (rc.prototype.fromJSON = function (e) {
          return (
            ks.prototype.fromJSON.call(this, e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        (nc.prototype = Object.create(ks.prototype)),
        (nc.prototype.constructor = nc),
        (nc.prototype.isLineCurve3 = !0),
        (nc.prototype.getPoint = function (e, t) {
          var r = t || new tr();
          return (
            1 === e
              ? r.copy(this.v2)
              : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
            r
          );
        }),
        (nc.prototype.getPointAt = function (e, t) {
          return this.getPoint(e, t);
        }),
        (nc.prototype.copy = function (e) {
          return ks.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }),
        (nc.prototype.toJSON = function () {
          var e = ks.prototype.toJSON.call(this);
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }),
        (nc.prototype.fromJSON = function (e) {
          return (
            ks.prototype.fromJSON.call(this, e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        (ic.prototype = Object.create(ks.prototype)),
        (ic.prototype.constructor = ic),
        (ic.prototype.isQuadraticBezierCurve = !0),
        (ic.prototype.getPoint = function (e, t) {
          var r = t || new Qt(),
            n = this.v0,
            i = this.v1,
            a = this.v2;
          return r.set(Qs(e, n.x, i.x, a.x), Qs(e, n.y, i.y, a.y)), r;
        }),
        (ic.prototype.copy = function (e) {
          return (
            ks.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }),
        (ic.prototype.toJSON = function () {
          var e = ks.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
          );
        }),
        (ic.prototype.fromJSON = function (e) {
          return (
            ks.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        (ac.prototype = Object.create(ks.prototype)),
        (ac.prototype.constructor = ac),
        (ac.prototype.isQuadraticBezierCurve3 = !0),
        (ac.prototype.getPoint = function (e, t) {
          var r = t || new tr(),
            n = this.v0,
            i = this.v1,
            a = this.v2;
          return r.set(Qs(e, n.x, i.x, a.x), Qs(e, n.y, i.y, a.y), Qs(e, n.z, i.z, a.z)), r;
        }),
        (ac.prototype.copy = function (e) {
          return (
            ks.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }),
        (ac.prototype.toJSON = function () {
          var e = ks.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
          );
        }),
        (ac.prototype.fromJSON = function (e) {
          return (
            ks.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        (oc.prototype = Object.create(ks.prototype)),
        (oc.prototype.constructor = oc),
        (oc.prototype.isSplineCurve = !0),
        (oc.prototype.getPoint = function (e, t) {
          var r = t || new Qt(),
            n = this.points,
            i = (n.length - 1) * e,
            a = Math.floor(i),
            o = i - a,
            s = n[0 === a ? a : a - 1],
            c = n[a],
            u = n[a > n.length - 2 ? n.length - 1 : a + 1],
            l = n[a > n.length - 3 ? n.length - 1 : a + 2];
          return r.set(Ks(o, s.x, c.x, u.x, l.x), Ks(o, s.y, c.y, u.y, l.y)), r;
        }),
        (oc.prototype.copy = function (e) {
          ks.prototype.copy.call(this, e), (this.points = []);
          for (var t = 0, r = e.points.length; t < r; t++) {
            var n = e.points[t];
            this.points.push(n.clone());
          }
          return this;
        }),
        (oc.prototype.toJSON = function () {
          var e = ks.prototype.toJSON.call(this);
          e.points = [];
          for (var t = 0, r = this.points.length; t < r; t++) {
            var n = this.points[t];
            e.points.push(n.toArray());
          }
          return e;
        }),
        (oc.prototype.fromJSON = function (e) {
          ks.prototype.fromJSON.call(this, e), (this.points = []);
          for (var t = 0, r = e.points.length; t < r; t++) {
            var n = e.points[t];
            this.points.push(new Qt().fromArray(n));
          }
          return this;
        });
      var sc = Object.freeze({
        ArcCurve: js,
        CatmullRomCurve3: Zs,
        CubicBezierCurve: ec,
        CubicBezierCurve3: tc,
        EllipseCurve: Vs,
        LineCurve: rc,
        LineCurve3: nc,
        QuadraticBezierCurve: ic,
        QuadraticBezierCurve3: ac,
        SplineCurve: oc,
      });
      function cc() {
        ks.call(this), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1);
      }
      function uc(e) {
        cc.call(this),
          (this.type = 'Path'),
          (this.currentPoint = new Qt()),
          e && this.setFromPoints(e);
      }
      function lc(e) {
        uc.call(this, e), (this.uuid = Kt.generateUUID()), (this.type = 'Shape'), (this.holes = []);
      }
      function hc(e, t) {
        kr.call(this),
          (this.type = 'Light'),
          (this.color = new Lr(e)),
          (this.intensity = void 0 !== t ? t : 1),
          (this.receiveShadow = void 0);
      }
      function dc(e, t, r) {
        hc.call(this, e, r),
          (this.type = 'HemisphereLight'),
          (this.castShadow = void 0),
          this.position.copy(kr.DefaultUp),
          this.updateMatrix(),
          (this.groundColor = new Lr(t));
      }
      function pc(e) {
        (this.camera = e),
          (this.bias = 0),
          (this.radius = 1),
          (this.mapSize = new Qt(512, 512)),
          (this.map = null),
          (this.matrix = new $t());
      }
      function fc() {
        pc.call(this, new la(50, 1, 0.5, 500));
      }
      function mc(e, t, r, n, i, a) {
        hc.call(this, e, t),
          (this.type = 'SpotLight'),
          this.position.copy(kr.DefaultUp),
          this.updateMatrix(),
          (this.target = new kr()),
          Object.defineProperty(this, 'power', {
            get: function () {
              return this.intensity * Math.PI;
            },
            set: function (e) {
              this.intensity = e / Math.PI;
            },
          }),
          (this.distance = void 0 !== r ? r : 0),
          (this.angle = void 0 !== n ? n : Math.PI / 3),
          (this.penumbra = void 0 !== i ? i : 0),
          (this.decay = void 0 !== a ? a : 1),
          (this.shadow = new fc());
      }
      function vc(e, t, r, n) {
        hc.call(this, e, t),
          (this.type = 'PointLight'),
          Object.defineProperty(this, 'power', {
            get: function () {
              return 4 * this.intensity * Math.PI;
            },
            set: function (e) {
              this.intensity = e / (4 * Math.PI);
            },
          }),
          (this.distance = void 0 !== r ? r : 0),
          (this.decay = void 0 !== n ? n : 1),
          (this.shadow = new pc(new la(90, 1, 0.5, 500)));
      }
      function gc(e, t, r, n, i, a) {
        ua.call(this),
          (this.type = 'OrthographicCamera'),
          (this.zoom = 1),
          (this.view = null),
          (this.left = void 0 !== e ? e : -1),
          (this.right = void 0 !== t ? t : 1),
          (this.top = void 0 !== r ? r : 1),
          (this.bottom = void 0 !== n ? n : -1),
          (this.near = void 0 !== i ? i : 0.1),
          (this.far = void 0 !== a ? a : 2e3),
          this.updateProjectionMatrix();
      }
      function yc() {
        pc.call(this, new gc(-5, 5, 5, -5, 0.5, 500));
      }
      function xc(e, t) {
        hc.call(this, e, t),
          (this.type = 'DirectionalLight'),
          this.position.copy(kr.DefaultUp),
          this.updateMatrix(),
          (this.target = new kr()),
          (this.shadow = new yc());
      }
      function bc(e, t) {
        hc.call(this, e, t), (this.type = 'AmbientLight'), (this.castShadow = void 0);
      }
      function wc(e, t, r, n) {
        hc.call(this, e, t),
          (this.type = 'RectAreaLight'),
          (this.width = void 0 !== r ? r : 10),
          (this.height = void 0 !== n ? n : 10);
      }
      function _c(e) {
        (this.manager = void 0 !== e ? e : Is), (this.textures = {});
      }
      (cc.prototype = Object.assign(Object.create(ks.prototype), {
        constructor: cc,
        add: function (e) {
          this.curves.push(e);
        },
        closePath: function () {
          var e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
          e.equals(t) || this.curves.push(new rc(t, e));
        },
        getPoint: function (e) {
          for (var t = e * this.getLength(), r = this.getCurveLengths(), n = 0; n < r.length; ) {
            if (r[n] >= t) {
              var i = r[n] - t,
                a = this.curves[n],
                o = a.getLength(),
                s = 0 === o ? 0 : 1 - i / o;
              return a.getPointAt(s);
            }
            n++;
          }
          return null;
        },
        getLength: function () {
          var e = this.getCurveLengths();
          return e[e.length - 1];
        },
        updateArcLengths: function () {
          (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
        },
        getCurveLengths: function () {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
          for (var e = [], t = 0, r = 0, n = this.curves.length; r < n; r++)
            (t += this.curves[r].getLength()), e.push(t);
          return (this.cacheLengths = e), e;
        },
        getSpacedPoints: function (e) {
          void 0 === e && (e = 40);
          for (var t = [], r = 0; r <= e; r++) t.push(this.getPoint(r / e));
          return this.autoClose && t.push(t[0]), t;
        },
        getPoints: function (e) {
          e = e || 12;
          for (var t, r = [], n = 0, i = this.curves; n < i.length; n++)
            for (
              var a = i[n],
                o =
                  a && a.isEllipseCurve
                    ? 2 * e
                    : a && (a.isLineCurve || a.isLineCurve3)
                    ? 1
                    : a && a.isSplineCurve
                    ? e * a.points.length
                    : e,
                s = a.getPoints(o),
                c = 0;
              c < s.length;
              c++
            ) {
              var u = s[c];
              (t && t.equals(u)) || (r.push(u), (t = u));
            }
          return this.autoClose && r.length > 1 && !r[r.length - 1].equals(r[0]) && r.push(r[0]), r;
        },
        copy: function (e) {
          ks.prototype.copy.call(this, e), (this.curves = []);
          for (var t = 0, r = e.curves.length; t < r; t++) {
            var n = e.curves[t];
            this.curves.push(n.clone());
          }
          return (this.autoClose = e.autoClose), this;
        },
        toJSON: function () {
          var e = ks.prototype.toJSON.call(this);
          (e.autoClose = this.autoClose), (e.curves = []);
          for (var t = 0, r = this.curves.length; t < r; t++) {
            var n = this.curves[t];
            e.curves.push(n.toJSON());
          }
          return e;
        },
        fromJSON: function (e) {
          ks.prototype.fromJSON.call(this, e), (this.autoClose = e.autoClose), (this.curves = []);
          for (var t = 0, r = e.curves.length; t < r; t++) {
            var n = e.curves[t];
            this.curves.push(new sc[n.type]().fromJSON(n));
          }
          return this;
        },
      })),
        (uc.prototype = Object.assign(Object.create(cc.prototype), {
          constructor: uc,
          setFromPoints: function (e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, r = e.length; t < r; t++) this.lineTo(e[t].x, e[t].y);
          },
          moveTo: function (e, t) {
            this.currentPoint.set(e, t);
          },
          lineTo: function (e, t) {
            var r = new rc(this.currentPoint.clone(), new Qt(e, t));
            this.curves.push(r), this.currentPoint.set(e, t);
          },
          quadraticCurveTo: function (e, t, r, n) {
            var i = new ic(this.currentPoint.clone(), new Qt(e, t), new Qt(r, n));
            this.curves.push(i), this.currentPoint.set(r, n);
          },
          bezierCurveTo: function (e, t, r, n, i, a) {
            var o = new ec(this.currentPoint.clone(), new Qt(e, t), new Qt(r, n), new Qt(i, a));
            this.curves.push(o), this.currentPoint.set(i, a);
          },
          splineThru: function (e) {
            var t = new oc([this.currentPoint.clone()].concat(e));
            this.curves.push(t), this.currentPoint.copy(e[e.length - 1]);
          },
          arc: function (e, t, r, n, i, a) {
            var o = this.currentPoint.x,
              s = this.currentPoint.y;
            this.absarc(e + o, t + s, r, n, i, a);
          },
          absarc: function (e, t, r, n, i, a) {
            this.absellipse(e, t, r, r, n, i, a);
          },
          ellipse: function (e, t, r, n, i, a, o, s) {
            var c = this.currentPoint.x,
              u = this.currentPoint.y;
            this.absellipse(e + c, t + u, r, n, i, a, o, s);
          },
          absellipse: function (e, t, r, n, i, a, o, s) {
            var c = new Vs(e, t, r, n, i, a, o, s);
            if (this.curves.length > 0) {
              var u = c.getPoint(0);
              u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
            }
            this.curves.push(c);
            var l = c.getPoint(1);
            this.currentPoint.copy(l);
          },
          copy: function (e) {
            return cc.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this;
          },
          toJSON: function () {
            var e = cc.prototype.toJSON.call(this);
            return (e.currentPoint = this.currentPoint.toArray()), e;
          },
          fromJSON: function (e) {
            return (
              cc.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
            );
          },
        })),
        (lc.prototype = Object.assign(Object.create(uc.prototype), {
          constructor: lc,
          getPointsHoles: function (e) {
            for (var t = [], r = 0, n = this.holes.length; r < n; r++)
              t[r] = this.holes[r].getPoints(e);
            return t;
          },
          extractPoints: function (e) {
            return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
          },
          copy: function (e) {
            uc.prototype.copy.call(this, e), (this.holes = []);
            for (var t = 0, r = e.holes.length; t < r; t++) {
              var n = e.holes[t];
              this.holes.push(n.clone());
            }
            return this;
          },
          toJSON: function () {
            var e = uc.prototype.toJSON.call(this);
            (e.uuid = this.uuid), (e.holes = []);
            for (var t = 0, r = this.holes.length; t < r; t++) {
              var n = this.holes[t];
              e.holes.push(n.toJSON());
            }
            return e;
          },
          fromJSON: function (e) {
            uc.prototype.fromJSON.call(this, e), (this.uuid = e.uuid), (this.holes = []);
            for (var t = 0, r = e.holes.length; t < r; t++) {
              var n = e.holes[t];
              this.holes.push(new uc().fromJSON(n));
            }
            return this;
          },
        })),
        (hc.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: hc,
          isLight: !0,
          copy: function (e) {
            return (
              kr.prototype.copy.call(this, e),
              this.color.copy(e.color),
              (this.intensity = e.intensity),
              this
            );
          },
          toJSON: function (e) {
            var t = kr.prototype.toJSON.call(this, e);
            return (
              (t.object.color = this.color.getHex()),
              (t.object.intensity = this.intensity),
              void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (t.object.distance = this.distance),
              void 0 !== this.angle && (t.object.angle = this.angle),
              void 0 !== this.decay && (t.object.decay = this.decay),
              void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
              void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
              t
            );
          },
        })),
        (dc.prototype = Object.assign(Object.create(hc.prototype), {
          constructor: dc,
          isHemisphereLight: !0,
          copy: function (e) {
            return hc.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this;
          },
        })),
        Object.assign(pc.prototype, {
          copy: function (e) {
            return (
              (this.camera = e.camera.clone()),
              (this.bias = e.bias),
              (this.radius = e.radius),
              this.mapSize.copy(e.mapSize),
              this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          toJSON: function () {
            var e = {};
            return (
              0 !== this.bias && (e.bias = this.bias),
              1 !== this.radius && (e.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                (e.mapSize = this.mapSize.toArray()),
              (e.camera = this.camera.toJSON(!1).object),
              delete e.camera.matrix,
              e
            );
          },
        }),
        (fc.prototype = Object.assign(Object.create(pc.prototype), {
          constructor: fc,
          isSpotLightShadow: !0,
          update: function (e) {
            var t = this.camera,
              r = 2 * Kt.RAD2DEG * e.angle,
              n = this.mapSize.width / this.mapSize.height,
              i = e.distance || t.far;
            (r === t.fov && n === t.aspect && i === t.far) ||
              ((t.fov = r), (t.aspect = n), (t.far = i), t.updateProjectionMatrix());
          },
        })),
        (mc.prototype = Object.assign(Object.create(hc.prototype), {
          constructor: mc,
          isSpotLight: !0,
          copy: function (e) {
            return (
              hc.prototype.copy.call(this, e),
              (this.distance = e.distance),
              (this.angle = e.angle),
              (this.penumbra = e.penumbra),
              (this.decay = e.decay),
              (this.target = e.target.clone()),
              (this.shadow = e.shadow.clone()),
              this
            );
          },
        })),
        (vc.prototype = Object.assign(Object.create(hc.prototype), {
          constructor: vc,
          isPointLight: !0,
          copy: function (e) {
            return (
              hc.prototype.copy.call(this, e),
              (this.distance = e.distance),
              (this.decay = e.decay),
              (this.shadow = e.shadow.clone()),
              this
            );
          },
        })),
        (gc.prototype = Object.assign(Object.create(ua.prototype), {
          constructor: gc,
          isOrthographicCamera: !0,
          copy: function (e, t) {
            return (
              ua.prototype.copy.call(this, e, t),
              (this.left = e.left),
              (this.right = e.right),
              (this.top = e.top),
              (this.bottom = e.bottom),
              (this.near = e.near),
              (this.far = e.far),
              (this.zoom = e.zoom),
              (this.view = null === e.view ? null : Object.assign({}, e.view)),
              this
            );
          },
          setViewOffset: function (e, t, r, n, i, a) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = e),
              (this.view.fullHeight = t),
              (this.view.offsetX = r),
              (this.view.offsetY = n),
              (this.view.width = i),
              (this.view.height = a),
              this.updateProjectionMatrix();
          },
          clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
          },
          updateProjectionMatrix: function () {
            var e = (this.right - this.left) / (2 * this.zoom),
              t = (this.top - this.bottom) / (2 * this.zoom),
              r = (this.right + this.left) / 2,
              n = (this.top + this.bottom) / 2,
              i = r - e,
              a = r + e,
              o = n + t,
              s = n - t;
            if (null !== this.view && this.view.enabled) {
              var c = this.zoom / (this.view.width / this.view.fullWidth),
                u = this.zoom / (this.view.height / this.view.fullHeight),
                l = (this.right - this.left) / this.view.width,
                h = (this.top - this.bottom) / this.view.height;
              (a = (i += l * (this.view.offsetX / c)) + l * (this.view.width / c)),
                (s = (o -= h * (this.view.offsetY / u)) - h * (this.view.height / u));
            }
            this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far),
              this.projectionMatrixInverse.getInverse(this.projectionMatrix);
          },
          toJSON: function (e) {
            var t = kr.prototype.toJSON.call(this, e);
            return (
              (t.object.zoom = this.zoom),
              (t.object.left = this.left),
              (t.object.right = this.right),
              (t.object.top = this.top),
              (t.object.bottom = this.bottom),
              (t.object.near = this.near),
              (t.object.far = this.far),
              null !== this.view && (t.object.view = Object.assign({}, this.view)),
              t
            );
          },
        })),
        (yc.prototype = Object.assign(Object.create(pc.prototype), { constructor: yc })),
        (xc.prototype = Object.assign(Object.create(hc.prototype), {
          constructor: xc,
          isDirectionalLight: !0,
          copy: function (e) {
            return (
              hc.prototype.copy.call(this, e),
              (this.target = e.target.clone()),
              (this.shadow = e.shadow.clone()),
              this
            );
          },
        })),
        (bc.prototype = Object.assign(Object.create(hc.prototype), {
          constructor: bc,
          isAmbientLight: !0,
        })),
        (wc.prototype = Object.assign(Object.create(hc.prototype), {
          constructor: wc,
          isRectAreaLight: !0,
          copy: function (e) {
            return (
              hc.prototype.copy.call(this, e),
              (this.width = e.width),
              (this.height = e.height),
              this
            );
          },
          toJSON: function (e) {
            var t = hc.prototype.toJSON.call(this, e);
            return (t.object.width = this.width), (t.object.height = this.height), t;
          },
        })),
        Object.assign(_c.prototype, {
          load: function (e, t, r, n) {
            var i = this,
              a = new Bs(i.manager);
            a.setPath(i.path),
              a.load(
                e,
                function (e) {
                  t(i.parse(JSON.parse(e)));
                },
                r,
                n,
              );
          },
          parse: function (e) {
            var t = this.textures;
            function r(e) {
              return (
                void 0 === t[e] && console.warn('THREE.MaterialLoader: Undefined texture', e), t[e]
              );
            }
            var n = new ms[e.type]();
            if (
              (void 0 !== e.uuid && (n.uuid = e.uuid),
              void 0 !== e.name && (n.name = e.name),
              void 0 !== e.color && n.color.setHex(e.color),
              void 0 !== e.roughness && (n.roughness = e.roughness),
              void 0 !== e.metalness && (n.metalness = e.metalness),
              void 0 !== e.emissive && n.emissive.setHex(e.emissive),
              void 0 !== e.specular && n.specular.setHex(e.specular),
              void 0 !== e.shininess && (n.shininess = e.shininess),
              void 0 !== e.clearCoat && (n.clearCoat = e.clearCoat),
              void 0 !== e.clearCoatRoughness && (n.clearCoatRoughness = e.clearCoatRoughness),
              void 0 !== e.vertexColors && (n.vertexColors = e.vertexColors),
              void 0 !== e.fog && (n.fog = e.fog),
              void 0 !== e.flatShading && (n.flatShading = e.flatShading),
              void 0 !== e.blending && (n.blending = e.blending),
              void 0 !== e.combine && (n.combine = e.combine),
              void 0 !== e.side && (n.side = e.side),
              void 0 !== e.opacity && (n.opacity = e.opacity),
              void 0 !== e.transparent && (n.transparent = e.transparent),
              void 0 !== e.alphaTest && (n.alphaTest = e.alphaTest),
              void 0 !== e.depthTest && (n.depthTest = e.depthTest),
              void 0 !== e.depthWrite && (n.depthWrite = e.depthWrite),
              void 0 !== e.colorWrite && (n.colorWrite = e.colorWrite),
              void 0 !== e.wireframe && (n.wireframe = e.wireframe),
              void 0 !== e.wireframeLinewidth && (n.wireframeLinewidth = e.wireframeLinewidth),
              void 0 !== e.wireframeLinecap && (n.wireframeLinecap = e.wireframeLinecap),
              void 0 !== e.wireframeLinejoin && (n.wireframeLinejoin = e.wireframeLinejoin),
              void 0 !== e.rotation && (n.rotation = e.rotation),
              1 !== e.linewidth && (n.linewidth = e.linewidth),
              void 0 !== e.dashSize && (n.dashSize = e.dashSize),
              void 0 !== e.gapSize && (n.gapSize = e.gapSize),
              void 0 !== e.scale && (n.scale = e.scale),
              void 0 !== e.polygonOffset && (n.polygonOffset = e.polygonOffset),
              void 0 !== e.polygonOffsetFactor && (n.polygonOffsetFactor = e.polygonOffsetFactor),
              void 0 !== e.polygonOffsetUnits && (n.polygonOffsetUnits = e.polygonOffsetUnits),
              void 0 !== e.skinning && (n.skinning = e.skinning),
              void 0 !== e.morphTargets && (n.morphTargets = e.morphTargets),
              void 0 !== e.dithering && (n.dithering = e.dithering),
              void 0 !== e.visible && (n.visible = e.visible),
              void 0 !== e.userData && (n.userData = e.userData),
              void 0 !== e.uniforms)
            )
              for (var i in e.uniforms) {
                var a = e.uniforms[i];
                switch (((n.uniforms[i] = {}), a.type)) {
                  case 't':
                    n.uniforms[i].value = r(a.value);
                    break;
                  case 'c':
                    n.uniforms[i].value = new Lr().setHex(a.value);
                    break;
                  case 'v2':
                    n.uniforms[i].value = new Qt().fromArray(a.value);
                    break;
                  case 'v3':
                    n.uniforms[i].value = new tr().fromArray(a.value);
                    break;
                  case 'v4':
                    n.uniforms[i].value = new hr().fromArray(a.value);
                    break;
                  case 'm3':
                    n.uniforms[i].value = new rr().fromArray(a.value);
                  case 'm4':
                    n.uniforms[i].value = new $t().fromArray(a.value);
                    break;
                  default:
                    n.uniforms[i].value = a.value;
                }
              }
            if (
              (void 0 !== e.defines && (n.defines = e.defines),
              void 0 !== e.vertexShader && (n.vertexShader = e.vertexShader),
              void 0 !== e.fragmentShader && (n.fragmentShader = e.fragmentShader),
              void 0 !== e.extensions)
            )
              for (var o in e.extensions) n.extensions[o] = e.extensions[o];
            if (
              (void 0 !== e.shading && (n.flatShading = 1 === e.shading),
              void 0 !== e.size && (n.size = e.size),
              void 0 !== e.sizeAttenuation && (n.sizeAttenuation = e.sizeAttenuation),
              void 0 !== e.map && (n.map = r(e.map)),
              void 0 !== e.alphaMap && ((n.alphaMap = r(e.alphaMap)), (n.transparent = !0)),
              void 0 !== e.bumpMap && (n.bumpMap = r(e.bumpMap)),
              void 0 !== e.bumpScale && (n.bumpScale = e.bumpScale),
              void 0 !== e.normalMap && (n.normalMap = r(e.normalMap)),
              void 0 !== e.normalMapType && (n.normalMapType = e.normalMapType),
              void 0 !== e.normalScale)
            ) {
              var s = e.normalScale;
              !1 === Array.isArray(s) && (s = [s, s]), (n.normalScale = new Qt().fromArray(s));
            }
            return (
              void 0 !== e.displacementMap && (n.displacementMap = r(e.displacementMap)),
              void 0 !== e.displacementScale && (n.displacementScale = e.displacementScale),
              void 0 !== e.displacementBias && (n.displacementBias = e.displacementBias),
              void 0 !== e.roughnessMap && (n.roughnessMap = r(e.roughnessMap)),
              void 0 !== e.metalnessMap && (n.metalnessMap = r(e.metalnessMap)),
              void 0 !== e.emissiveMap && (n.emissiveMap = r(e.emissiveMap)),
              void 0 !== e.emissiveIntensity && (n.emissiveIntensity = e.emissiveIntensity),
              void 0 !== e.specularMap && (n.specularMap = r(e.specularMap)),
              void 0 !== e.envMap && (n.envMap = r(e.envMap)),
              void 0 !== e.envMapIntensity && (n.envMapIntensity = e.envMapIntensity),
              void 0 !== e.reflectivity && (n.reflectivity = e.reflectivity),
              void 0 !== e.lightMap && (n.lightMap = r(e.lightMap)),
              void 0 !== e.lightMapIntensity && (n.lightMapIntensity = e.lightMapIntensity),
              void 0 !== e.aoMap && (n.aoMap = r(e.aoMap)),
              void 0 !== e.aoMapIntensity && (n.aoMapIntensity = e.aoMapIntensity),
              void 0 !== e.gradientMap && (n.gradientMap = r(e.gradientMap)),
              n
            );
          },
          setPath: function (e) {
            return (this.path = e), this;
          },
          setTextures: function (e) {
            return (this.textures = e), this;
          },
        });
      var Mc = {
        decodeText: function (e) {
          if ('undefined' != typeof TextDecoder) return new TextDecoder().decode(e);
          for (var t = '', r = 0, n = e.length; r < n; r++) t += String.fromCharCode(e[r]);
          return decodeURIComponent(escape(t));
        },
        extractUrlBase: function (e) {
          var t = e.lastIndexOf('/');
          return -1 === t ? './' : e.substr(0, t + 1);
        },
      };
      function Sc(e) {
        this.manager = void 0 !== e ? e : Is;
      }
      Object.assign(Sc.prototype, {
        load: function (e, t, r, n) {
          var i = this,
            a = new Bs(i.manager);
          a.setPath(i.path),
            a.load(
              e,
              function (e) {
                t(i.parse(JSON.parse(e)));
              },
              r,
              n,
            );
        },
        parse: function (e) {
          var t = new sn(),
            r = e.data.index;
          if (void 0 !== r) {
            var n = new Ec[r.type](r.array);
            t.setIndex(new Xr(n, 1));
          }
          var i = e.data.attributes;
          for (var a in i) {
            var o = i[a];
            n = new Ec[o.type](o.array);
            t.addAttribute(a, new Xr(n, o.itemSize, o.normalized));
          }
          var s = e.data.groups || e.data.drawcalls || e.data.offsets;
          if (void 0 !== s)
            for (var c = 0, u = s.length; c !== u; ++c) {
              var l = s[c];
              t.addGroup(l.start, l.count, l.materialIndex);
            }
          var h = e.data.boundingSphere;
          if (void 0 !== h) {
            var d = new tr();
            void 0 !== h.center && d.fromArray(h.center), (t.boundingSphere = new gr(d, h.radius));
          }
          return e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t;
        },
        setPath: function (e) {
          return (this.path = e), this;
        },
      });
      var Ec = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: 'undefined' != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array,
      };
      function Tc(e) {
        (this.manager = void 0 !== e ? e : Is), (this.resourcePath = '');
      }
      Object.assign(Tc.prototype, {
        crossOrigin: 'anonymous',
        load: function (e, t, r, n) {
          var i = this,
            a = void 0 === this.path ? Mc.extractUrlBase(e) : this.path;
          this.resourcePath = this.resourcePath || a;
          var o = new Bs(i.manager);
          o.setPath(this.path),
            o.load(
              e,
              function (r) {
                var a = null;
                try {
                  a = JSON.parse(r);
                } catch (t) {
                  return (
                    void 0 !== n && n(t),
                    void console.error("THREE:ObjectLoader: Can't parse " + e + '.', t.message)
                  );
                }
                var o = a.metadata;
                void 0 !== o && void 0 !== o.type && 'geometry' !== o.type.toLowerCase()
                  ? i.parse(a, t)
                  : console.error("THREE.ObjectLoader: Can't load " + e);
              },
              r,
              n,
            );
        },
        setPath: function (e) {
          return (this.path = e), this;
        },
        setResourcePath: function (e) {
          return (this.resourcePath = e), this;
        },
        setCrossOrigin: function (e) {
          return (this.crossOrigin = e), this;
        },
        parse: function (e, t) {
          var r = this.parseShape(e.shapes),
            n = this.parseGeometries(e.geometries, r),
            i = this.parseImages(e.images, function () {
              void 0 !== t && t(s);
            }),
            a = this.parseTextures(e.textures, i),
            o = this.parseMaterials(e.materials, a),
            s = this.parseObject(e.object, n, o);
          return (
            e.animations && (s.animations = this.parseAnimations(e.animations)),
            (void 0 !== e.images && 0 !== e.images.length) || (void 0 !== t && t(s)),
            s
          );
        },
        parseShape: function (e) {
          var t = {};
          if (void 0 !== e)
            for (var r = 0, n = e.length; r < n; r++) {
              var i = new lc().fromJSON(e[r]);
              t[i.uuid] = i;
            }
          return t;
        },
        parseGeometries: function (e, t) {
          var r = {};
          if (void 0 !== e)
            for (var n = new Sc(), i = 0, a = e.length; i < a; i++) {
              var o,
                s = e[i];
              switch (s.type) {
                case 'PlaneGeometry':
                case 'PlaneBufferGeometry':
                  o = new is[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                  break;
                case 'BoxGeometry':
                case 'BoxBufferGeometry':
                case 'CubeGeometry':
                  o = new is[s.type](
                    s.width,
                    s.height,
                    s.depth,
                    s.widthSegments,
                    s.heightSegments,
                    s.depthSegments,
                  );
                  break;
                case 'CircleGeometry':
                case 'CircleBufferGeometry':
                  o = new is[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                  break;
                case 'CylinderGeometry':
                case 'CylinderBufferGeometry':
                  o = new is[s.type](
                    s.radiusTop,
                    s.radiusBottom,
                    s.height,
                    s.radialSegments,
                    s.heightSegments,
                    s.openEnded,
                    s.thetaStart,
                    s.thetaLength,
                  );
                  break;
                case 'ConeGeometry':
                case 'ConeBufferGeometry':
                  o = new is[s.type](
                    s.radius,
                    s.height,
                    s.radialSegments,
                    s.heightSegments,
                    s.openEnded,
                    s.thetaStart,
                    s.thetaLength,
                  );
                  break;
                case 'SphereGeometry':
                case 'SphereBufferGeometry':
                  o = new is[s.type](
                    s.radius,
                    s.widthSegments,
                    s.heightSegments,
                    s.phiStart,
                    s.phiLength,
                    s.thetaStart,
                    s.thetaLength,
                  );
                  break;
                case 'DodecahedronGeometry':
                case 'DodecahedronBufferGeometry':
                case 'IcosahedronGeometry':
                case 'IcosahedronBufferGeometry':
                case 'OctahedronGeometry':
                case 'OctahedronBufferGeometry':
                case 'TetrahedronGeometry':
                case 'TetrahedronBufferGeometry':
                  o = new is[s.type](s.radius, s.detail);
                  break;
                case 'RingGeometry':
                case 'RingBufferGeometry':
                  o = new is[s.type](
                    s.innerRadius,
                    s.outerRadius,
                    s.thetaSegments,
                    s.phiSegments,
                    s.thetaStart,
                    s.thetaLength,
                  );
                  break;
                case 'TorusGeometry':
                case 'TorusBufferGeometry':
                  o = new is[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                  break;
                case 'TorusKnotGeometry':
                case 'TorusKnotBufferGeometry':
                  o = new is[s.type](
                    s.radius,
                    s.tube,
                    s.tubularSegments,
                    s.radialSegments,
                    s.p,
                    s.q,
                  );
                  break;
                case 'LatheGeometry':
                case 'LatheBufferGeometry':
                  o = new is[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                  break;
                case 'PolyhedronGeometry':
                case 'PolyhedronBufferGeometry':
                  o = new is[s.type](s.vertices, s.indices, s.radius, s.details);
                  break;
                case 'ShapeGeometry':
                case 'ShapeBufferGeometry':
                  for (var c = [], u = 0, l = s.shapes.length; u < l; u++) {
                    var h = t[s.shapes[u]];
                    c.push(h);
                  }
                  o = new is[s.type](c, s.curveSegments);
                  break;
                case 'ExtrudeGeometry':
                case 'ExtrudeBufferGeometry':
                  for (c = [], u = 0, l = s.shapes.length; u < l; u++) {
                    h = t[s.shapes[u]];
                    c.push(h);
                  }
                  var d = s.options.extrudePath;
                  void 0 !== d && (s.options.extrudePath = new sc[d.type]().fromJSON(d)),
                    (o = new is[s.type](c, s.options));
                  break;
                case 'BufferGeometry':
                  o = n.parse(s);
                  break;
                case 'Geometry':
                  if ('THREE' in window && 'LegacyJSONLoader' in THREE)
                    o = new THREE.LegacyJSONLoader().parse(s, this.resourcePath).geometry;
                  else
                    console.error(
                      'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".',
                    );
                  break;
                default:
                  console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                  continue;
              }
              (o.uuid = s.uuid),
                void 0 !== s.name && (o.name = s.name),
                !0 === o.isBufferGeometry && void 0 !== s.userData && (o.userData = s.userData),
                (r[s.uuid] = o);
            }
          return r;
        },
        parseMaterials: function (e, t) {
          var r = {},
            n = {};
          if (void 0 !== e) {
            var i = new _c();
            i.setTextures(t);
            for (var a = 0, o = e.length; a < o; a++) {
              var s = e[a];
              if ('MultiMaterial' === s.type) {
                for (var c = [], u = 0; u < s.materials.length; u++) {
                  var l = s.materials[u];
                  void 0 === r[l.uuid] && (r[l.uuid] = i.parse(l)), c.push(r[l.uuid]);
                }
                n[s.uuid] = c;
              } else void 0 === r[s.uuid] && (r[s.uuid] = i.parse(s)), (n[s.uuid] = r[s.uuid]);
            }
          }
          return n;
        },
        parseAnimations: function (e) {
          for (var t = [], r = 0; r < e.length; r++) {
            var n = e[r],
              i = Rs.parse(n);
            void 0 !== n.uuid && (i.uuid = n.uuid), t.push(i);
          }
          return t;
        },
        parseImages: function (e, t) {
          var r = this,
            n = {};
          function i(e) {
            return (
              r.manager.itemStart(e),
              a.load(
                e,
                function () {
                  r.manager.itemEnd(e);
                },
                void 0,
                function () {
                  r.manager.itemError(e), r.manager.itemEnd(e);
                },
              )
            );
          }
          if (void 0 !== e && e.length > 0) {
            var a = new Fs(new Os(t));
            a.setCrossOrigin(this.crossOrigin);
            for (var o = 0, s = e.length; o < s; o++) {
              var c = e[o],
                u = c.url;
              if (Array.isArray(u)) {
                n[c.uuid] = [];
                for (var l = 0, h = u.length; l < h; l++) {
                  var d = u[l],
                    p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : r.resourcePath + d;
                  n[c.uuid].push(i(p));
                }
              } else {
                p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : r.resourcePath + c.url;
                n[c.uuid] = i(p);
              }
            }
          }
          return n;
        },
        parseTextures: function (e, t) {
          function r(e, t) {
            return 'number' == typeof e
              ? e
              : (console.warn(
                  'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',
                  e,
                ),
                t[e]);
          }
          var n = {};
          if (void 0 !== e)
            for (var i = 0, a = e.length; i < a; i++) {
              var o,
                s = e[i];
              void 0 === s.image &&
                console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
                void 0 === t[s.image] &&
                  console.warn('THREE.ObjectLoader: Undefined image', s.image),
                ((o = Array.isArray(t[s.image])
                  ? new kn(t[s.image])
                  : new lr(t[s.image])).needsUpdate = !0),
                (o.uuid = s.uuid),
                void 0 !== s.name && (o.name = s.name),
                void 0 !== s.mapping && (o.mapping = r(s.mapping, Oc)),
                void 0 !== s.offset && o.offset.fromArray(s.offset),
                void 0 !== s.repeat && o.repeat.fromArray(s.repeat),
                void 0 !== s.center && o.center.fromArray(s.center),
                void 0 !== s.rotation && (o.rotation = s.rotation),
                void 0 !== s.wrap && ((o.wrapS = r(s.wrap[0], Ic)), (o.wrapT = r(s.wrap[1], Ic))),
                void 0 !== s.format && (o.format = s.format),
                void 0 !== s.type && (o.type = s.type),
                void 0 !== s.encoding && (o.encoding = s.encoding),
                void 0 !== s.minFilter && (o.minFilter = r(s.minFilter, Dc)),
                void 0 !== s.magFilter && (o.magFilter = r(s.magFilter, Dc)),
                void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy),
                void 0 !== s.flipY && (o.flipY = s.flipY),
                void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha),
                void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment),
                (n[s.uuid] = o);
            }
          return n;
        },
        parseObject: function (e, t, r) {
          var n;
          function i(e) {
            return (
              void 0 === t[e] && console.warn('THREE.ObjectLoader: Undefined geometry', e), t[e]
            );
          }
          function a(e) {
            if (void 0 !== e) {
              if (Array.isArray(e)) {
                for (var t = [], n = 0, i = e.length; n < i; n++) {
                  var a = e[n];
                  void 0 === r[a] && console.warn('THREE.ObjectLoader: Undefined material', a),
                    t.push(r[a]);
                }
                return t;
              }
              return (
                void 0 === r[e] && console.warn('THREE.ObjectLoader: Undefined material', e), r[e]
              );
            }
          }
          switch (e.type) {
            case 'Scene':
              (n = new Ta()),
                void 0 !== e.background &&
                  Number.isInteger(e.background) &&
                  (n.background = new Lr(e.background)),
                void 0 !== e.fog &&
                  ('Fog' === e.fog.type
                    ? (n.fog = new Ea(e.fog.color, e.fog.near, e.fog.far))
                    : 'FogExp2' === e.fog.type && (n.fog = new Sa(e.fog.color, e.fog.density)));
              break;
            case 'PerspectiveCamera':
              (n = new la(e.fov, e.aspect, e.near, e.far)),
                void 0 !== e.focus && (n.focus = e.focus),
                void 0 !== e.zoom && (n.zoom = e.zoom),
                void 0 !== e.filmGauge && (n.filmGauge = e.filmGauge),
                void 0 !== e.filmOffset && (n.filmOffset = e.filmOffset),
                void 0 !== e.view && (n.view = Object.assign({}, e.view));
              break;
            case 'OrthographicCamera':
              (n = new gc(e.left, e.right, e.top, e.bottom, e.near, e.far)),
                void 0 !== e.zoom && (n.zoom = e.zoom),
                void 0 !== e.view && (n.view = Object.assign({}, e.view));
              break;
            case 'AmbientLight':
              n = new bc(e.color, e.intensity);
              break;
            case 'DirectionalLight':
              n = new xc(e.color, e.intensity);
              break;
            case 'PointLight':
              n = new vc(e.color, e.intensity, e.distance, e.decay);
              break;
            case 'RectAreaLight':
              n = new wc(e.color, e.intensity, e.width, e.height);
              break;
            case 'SpotLight':
              n = new mc(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
              break;
            case 'HemisphereLight':
              n = new dc(e.color, e.groundColor, e.intensity);
              break;
            case 'SkinnedMesh':
              console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');
            case 'Mesh':
              var o = i(e.geometry),
                s = a(e.material);
              (n = o.bones && o.bones.length > 0 ? new Oa(o, s) : new Cn(o, s)),
                void 0 !== e.drawMode && n.setDrawMode(e.drawMode);
              break;
            case 'LOD':
              n = new Pa();
              break;
            case 'Line':
              n = new Na(i(e.geometry), a(e.material), e.mode);
              break;
            case 'LineLoop':
              n = new Ga(i(e.geometry), a(e.material));
              break;
            case 'LineSegments':
              n = new Ua(i(e.geometry), a(e.material));
              break;
            case 'PointCloud':
            case 'Points':
              n = new za(i(e.geometry), a(e.material));
              break;
            case 'Sprite':
              n = new Ca(a(e.material));
              break;
            case 'Group':
              n = new ca();
              break;
            default:
              n = new kr();
          }
          if (
            ((n.uuid = e.uuid),
            void 0 !== e.name && (n.name = e.name),
            void 0 !== e.matrix
              ? (n.matrix.fromArray(e.matrix),
                void 0 !== e.matrixAutoUpdate && (n.matrixAutoUpdate = e.matrixAutoUpdate),
                n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale))
              : (void 0 !== e.position && n.position.fromArray(e.position),
                void 0 !== e.rotation && n.rotation.fromArray(e.rotation),
                void 0 !== e.quaternion && n.quaternion.fromArray(e.quaternion),
                void 0 !== e.scale && n.scale.fromArray(e.scale)),
            void 0 !== e.castShadow && (n.castShadow = e.castShadow),
            void 0 !== e.receiveShadow && (n.receiveShadow = e.receiveShadow),
            e.shadow &&
              (void 0 !== e.shadow.bias && (n.shadow.bias = e.shadow.bias),
              void 0 !== e.shadow.radius && (n.shadow.radius = e.shadow.radius),
              void 0 !== e.shadow.mapSize && n.shadow.mapSize.fromArray(e.shadow.mapSize),
              void 0 !== e.shadow.camera && (n.shadow.camera = this.parseObject(e.shadow.camera))),
            void 0 !== e.visible && (n.visible = e.visible),
            void 0 !== e.frustumCulled && (n.frustumCulled = e.frustumCulled),
            void 0 !== e.renderOrder && (n.renderOrder = e.renderOrder),
            void 0 !== e.userData && (n.userData = e.userData),
            void 0 !== e.layers && (n.layers.mask = e.layers),
            void 0 !== e.children)
          )
            for (var c = e.children, u = 0; u < c.length; u++) n.add(this.parseObject(c[u], t, r));
          if ('LOD' === e.type)
            for (var l = e.levels, h = 0; h < l.length; h++) {
              var d = l[h],
                p = n.getObjectByProperty('uuid', d.object);
              void 0 !== p && n.addLevel(p, d.distance);
            }
          return n;
        },
      });
      var Ac,
        Lc,
        Rc,
        Cc,
        Pc,
        Oc = {
          UVMapping: be,
          CubeReflectionMapping: we,
          CubeRefractionMapping: _e,
          EquirectangularReflectionMapping: Me,
          EquirectangularRefractionMapping: Se,
          SphericalReflectionMapping: Ee,
          CubeUVReflectionMapping: Te,
          CubeUVRefractionMapping: Ae,
        },
        Ic = { RepeatWrapping: Le, ClampToEdgeWrapping: Re, MirroredRepeatWrapping: Ce },
        Dc = {
          NearestFilter: Pe,
          NearestMipMapNearestFilter: Oe,
          NearestMipMapLinearFilter: Ie,
          LinearFilter: De,
          LinearMipMapNearestFilter: Be,
          LinearMipMapLinearFilter: Ne,
        };
      function Bc(e) {
        'undefined' == typeof createImageBitmap &&
          console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.'),
          'undefined' == typeof fetch &&
            console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
          (this.manager = void 0 !== e ? e : Is),
          (this.options = void 0);
      }
      function Nc() {
        (this.type = 'ShapePath'),
          (this.color = new Lr()),
          (this.subPaths = []),
          (this.currentPath = null);
      }
      function Uc(e) {
        (this.type = 'Font'), (this.data = e);
      }
      function Gc(e, t, r, n, i) {
        var a = i.glyphs[e] || i.glyphs['?'];
        if (a) {
          var o,
            s,
            c,
            u,
            l,
            h,
            d,
            p,
            f = new Nc();
          if (a.o)
            for (
              var m = a._cachedOutline || (a._cachedOutline = a.o.split(' ')), v = 0, g = m.length;
              v < g;

            ) {
              switch (m[v++]) {
                case 'm':
                  (o = m[v++] * t + r), (s = m[v++] * t + n), f.moveTo(o, s);
                  break;
                case 'l':
                  (o = m[v++] * t + r), (s = m[v++] * t + n), f.lineTo(o, s);
                  break;
                case 'q':
                  (c = m[v++] * t + r),
                    (u = m[v++] * t + n),
                    (l = m[v++] * t + r),
                    (h = m[v++] * t + n),
                    f.quadraticCurveTo(l, h, c, u);
                  break;
                case 'b':
                  (c = m[v++] * t + r),
                    (u = m[v++] * t + n),
                    (l = m[v++] * t + r),
                    (h = m[v++] * t + n),
                    (d = m[v++] * t + r),
                    (p = m[v++] * t + n),
                    f.bezierCurveTo(l, h, d, p, c, u);
              }
            }
          return { offsetX: a.ha * t, path: f };
        }
      }
      function Fc(e) {
        this.manager = void 0 !== e ? e : Is;
      }
      function zc() {}
      (Bc.prototype = {
        constructor: Bc,
        setOptions: function (e) {
          return (this.options = e), this;
        },
        load: function (e, t, r, n) {
          void 0 === e && (e = ''),
            void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          var i = this,
            a = Ps.get(e);
          if (void 0 !== a)
            return (
              i.manager.itemStart(e),
              setTimeout(function () {
                t && t(a), i.manager.itemEnd(e);
              }, 0),
              a
            );
          fetch(e)
            .then(function (e) {
              return e.blob();
            })
            .then(function (e) {
              return createImageBitmap(e, i.options);
            })
            .then(function (r) {
              Ps.add(e, r), t && t(r), i.manager.itemEnd(e);
            })
            .catch(function (t) {
              n && n(t), i.manager.itemError(e), i.manager.itemEnd(e);
            });
        },
        setCrossOrigin: function () {
          return this;
        },
        setPath: function (e) {
          return (this.path = e), this;
        },
      }),
        Object.assign(Nc.prototype, {
          moveTo: function (e, t) {
            (this.currentPath = new uc()),
              this.subPaths.push(this.currentPath),
              this.currentPath.moveTo(e, t);
          },
          lineTo: function (e, t) {
            this.currentPath.lineTo(e, t);
          },
          quadraticCurveTo: function (e, t, r, n) {
            this.currentPath.quadraticCurveTo(e, t, r, n);
          },
          bezierCurveTo: function (e, t, r, n, i, a) {
            this.currentPath.bezierCurveTo(e, t, r, n, i, a);
          },
          splineThru: function (e) {
            this.currentPath.splineThru(e);
          },
          toShapes: function (e, t) {
            function r(e) {
              for (var t = [], r = 0, n = e.length; r < n; r++) {
                var i = e[r],
                  a = new lc();
                (a.curves = i.curves), t.push(a);
              }
              return t;
            }
            function n(e, t) {
              for (var r = t.length, n = !1, i = r - 1, a = 0; a < r; i = a++) {
                var o = t[i],
                  s = t[a],
                  c = s.x - o.x,
                  u = s.y - o.y;
                if (Math.abs(u) > Number.EPSILON) {
                  if (
                    (u < 0 && ((o = t[a]), (c = -c), (s = t[i]), (u = -u)), e.y < o.y || e.y > s.y)
                  )
                    continue;
                  if (e.y === o.y) {
                    if (e.x === o.x) return !0;
                  } else {
                    var l = u * (e.x - o.x) - c * (e.y - o.y);
                    if (0 === l) return !0;
                    if (l < 0) continue;
                    n = !n;
                  }
                } else {
                  if (e.y !== o.y) continue;
                  if ((s.x <= e.x && e.x <= o.x) || (o.x <= e.x && e.x <= s.x)) return !0;
                }
              }
              return n;
            }
            var i = Io.isClockWise,
              a = this.subPaths;
            if (0 === a.length) return [];
            if (!0 === t) return r(a);
            var o,
              s,
              c,
              u = [];
            if (1 === a.length) return (s = a[0]), ((c = new lc()).curves = s.curves), u.push(c), u;
            var l = !i(a[0].getPoints());
            l = e ? !l : l;
            var h,
              d,
              p = [],
              f = [],
              m = [],
              v = 0;
            (f[v] = void 0), (m[v] = []);
            for (var g = 0, y = a.length; g < y; g++)
              (o = i((h = (s = a[g]).getPoints()))),
                (o = e ? !o : o)
                  ? (!l && f[v] && v++,
                    (f[v] = { s: new lc(), p: h }),
                    (f[v].s.curves = s.curves),
                    l && v++,
                    (m[v] = []))
                  : m[v].push({ h: s, p: h[0] });
            if (!f[0]) return r(a);
            if (f.length > 1) {
              for (var x = !1, b = [], w = 0, _ = f.length; w < _; w++) p[w] = [];
              for (w = 0, _ = f.length; w < _; w++)
                for (var M = m[w], S = 0; S < M.length; S++) {
                  for (var E = M[S], T = !0, A = 0; A < f.length; A++)
                    n(E.p, f[A].p) &&
                      (w !== A && b.push({ froms: w, tos: A, hole: S }),
                      T ? ((T = !1), p[A].push(E)) : (x = !0));
                  T && p[w].push(E);
                }
              b.length > 0 && (x || (m = p));
            }
            g = 0;
            for (var L = f.length; g < L; g++) {
              (c = f[g].s), u.push(c);
              for (var R = 0, C = (d = m[g]).length; R < C; R++) c.holes.push(d[R].h);
            }
            return u;
          },
        }),
        Object.assign(Uc.prototype, {
          isFont: !0,
          generateShapes: function (e, t) {
            void 0 === t && (t = 100);
            for (
              var r = [],
                n = (function (e, t, r) {
                  for (
                    var n = Array.from ? Array.from(e) : String(e).split(''),
                      i = t / r.resolution,
                      a = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * i,
                      o = [],
                      s = 0,
                      c = 0,
                      u = 0;
                    u < n.length;
                    u++
                  ) {
                    var l = n[u];
                    if ('\n' === l) (s = 0), (c -= a);
                    else {
                      var h = Gc(l, i, s, c, r);
                      (s += h.offsetX), o.push(h.path);
                    }
                  }
                  return o;
                })(e, t, this.data),
                i = 0,
                a = n.length;
              i < a;
              i++
            )
              Array.prototype.push.apply(r, n[i].toShapes());
            return r;
          },
        }),
        Object.assign(Fc.prototype, {
          load: function (e, t, r, n) {
            var i = this,
              a = new Bs(this.manager);
            a.setPath(this.path),
              a.load(
                e,
                function (e) {
                  var r;
                  try {
                    r = JSON.parse(e);
                  } catch (t) {
                    console.warn(
                      'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.',
                    ),
                      (r = JSON.parse(e.substring(65, e.length - 2)));
                  }
                  var n = i.parse(r);
                  t && t(n);
                },
                r,
                n,
              );
          },
          parse: function (e) {
            return new Uc(e);
          },
          setPath: function (e) {
            return (this.path = e), this;
          },
        }),
        (zc.Handlers = {
          handlers: [],
          add: function (e, t) {
            this.handlers.push(e, t);
          },
          get: function (e) {
            for (var t = this.handlers, r = 0, n = t.length; r < n; r += 2) {
              var i = t[r],
                a = t[r + 1];
              if (i.test(e)) return a;
            }
            return null;
          },
        }),
        Object.assign(zc.prototype, {
          crossOrigin: 'anonymous',
          onLoadStart: function () {},
          onLoadProgress: function () {},
          onLoadComplete: function () {},
          initMaterials: function (e, t, r) {
            for (var n = [], i = 0; i < e.length; ++i) n[i] = this.createMaterial(e[i], t, r);
            return n;
          },
          createMaterial:
            ((Ac = {
              NoBlending: B,
              NormalBlending: N,
              AdditiveBlending: U,
              SubtractiveBlending: G,
              MultiplyBlending: F,
              CustomBlending: z,
            }),
            (Lc = new Lr()),
            (Rc = new Hs()),
            (Cc = new _c()),
            function (e, t, r) {
              var n = {};
              function i(e, i, a, o, s) {
                var c,
                  u = t + e,
                  l = zc.Handlers.get(u);
                null !== l ? (c = l.load(u)) : (Rc.setCrossOrigin(r), (c = Rc.load(u))),
                  void 0 !== i &&
                    (c.repeat.fromArray(i),
                    1 !== i[0] && (c.wrapS = Le),
                    1 !== i[1] && (c.wrapT = Le)),
                  void 0 !== a && c.offset.fromArray(a),
                  void 0 !== o &&
                    ('repeat' === o[0] && (c.wrapS = Le),
                    'mirror' === o[0] && (c.wrapS = Ce),
                    'repeat' === o[1] && (c.wrapT = Le),
                    'mirror' === o[1] && (c.wrapT = Ce)),
                  void 0 !== s && (c.anisotropy = s);
                var h = Kt.generateUUID();
                return (n[h] = c), h;
              }
              var a = { uuid: Kt.generateUUID(), type: 'MeshLambertMaterial' };
              for (var o in e) {
                var s = e[o];
                switch (o) {
                  case 'DbgColor':
                  case 'DbgIndex':
                  case 'opticalDensity':
                  case 'illumination':
                    break;
                  case 'DbgName':
                    a.name = s;
                    break;
                  case 'blending':
                    a.blending = Ac[s];
                    break;
                  case 'colorAmbient':
                  case 'mapAmbient':
                    console.warn('THREE.Loader.createMaterial:', o, 'is no longer supported.');
                    break;
                  case 'colorDiffuse':
                    a.color = Lc.fromArray(s).getHex();
                    break;
                  case 'colorSpecular':
                    a.specular = Lc.fromArray(s).getHex();
                    break;
                  case 'colorEmissive':
                    a.emissive = Lc.fromArray(s).getHex();
                    break;
                  case 'specularCoef':
                    a.shininess = s;
                    break;
                  case 'shading':
                    'basic' === s.toLowerCase() && (a.type = 'MeshBasicMaterial'),
                      'phong' === s.toLowerCase() && (a.type = 'MeshPhongMaterial'),
                      'standard' === s.toLowerCase() && (a.type = 'MeshStandardMaterial');
                    break;
                  case 'mapDiffuse':
                    a.map = i(
                      s,
                      e.mapDiffuseRepeat,
                      e.mapDiffuseOffset,
                      e.mapDiffuseWrap,
                      e.mapDiffuseAnisotropy,
                    );
                    break;
                  case 'mapDiffuseRepeat':
                  case 'mapDiffuseOffset':
                  case 'mapDiffuseWrap':
                  case 'mapDiffuseAnisotropy':
                    break;
                  case 'mapEmissive':
                    a.emissiveMap = i(
                      s,
                      e.mapEmissiveRepeat,
                      e.mapEmissiveOffset,
                      e.mapEmissiveWrap,
                      e.mapEmissiveAnisotropy,
                    );
                    break;
                  case 'mapEmissiveRepeat':
                  case 'mapEmissiveOffset':
                  case 'mapEmissiveWrap':
                  case 'mapEmissiveAnisotropy':
                    break;
                  case 'mapLight':
                    a.lightMap = i(
                      s,
                      e.mapLightRepeat,
                      e.mapLightOffset,
                      e.mapLightWrap,
                      e.mapLightAnisotropy,
                    );
                    break;
                  case 'mapLightRepeat':
                  case 'mapLightOffset':
                  case 'mapLightWrap':
                  case 'mapLightAnisotropy':
                    break;
                  case 'mapAO':
                    a.aoMap = i(s, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                    break;
                  case 'mapAORepeat':
                  case 'mapAOOffset':
                  case 'mapAOWrap':
                  case 'mapAOAnisotropy':
                    break;
                  case 'mapBump':
                    a.bumpMap = i(
                      s,
                      e.mapBumpRepeat,
                      e.mapBumpOffset,
                      e.mapBumpWrap,
                      e.mapBumpAnisotropy,
                    );
                    break;
                  case 'mapBumpScale':
                    a.bumpScale = s;
                    break;
                  case 'mapBumpRepeat':
                  case 'mapBumpOffset':
                  case 'mapBumpWrap':
                  case 'mapBumpAnisotropy':
                    break;
                  case 'mapNormal':
                    a.normalMap = i(
                      s,
                      e.mapNormalRepeat,
                      e.mapNormalOffset,
                      e.mapNormalWrap,
                      e.mapNormalAnisotropy,
                    );
                    break;
                  case 'mapNormalFactor':
                    a.normalScale = s;
                    break;
                  case 'mapNormalRepeat':
                  case 'mapNormalOffset':
                  case 'mapNormalWrap':
                  case 'mapNormalAnisotropy':
                    break;
                  case 'mapSpecular':
                    a.specularMap = i(
                      s,
                      e.mapSpecularRepeat,
                      e.mapSpecularOffset,
                      e.mapSpecularWrap,
                      e.mapSpecularAnisotropy,
                    );
                    break;
                  case 'mapSpecularRepeat':
                  case 'mapSpecularOffset':
                  case 'mapSpecularWrap':
                  case 'mapSpecularAnisotropy':
                    break;
                  case 'mapMetalness':
                    a.metalnessMap = i(
                      s,
                      e.mapMetalnessRepeat,
                      e.mapMetalnessOffset,
                      e.mapMetalnessWrap,
                      e.mapMetalnessAnisotropy,
                    );
                    break;
                  case 'mapMetalnessRepeat':
                  case 'mapMetalnessOffset':
                  case 'mapMetalnessWrap':
                  case 'mapMetalnessAnisotropy':
                    break;
                  case 'mapRoughness':
                    a.roughnessMap = i(
                      s,
                      e.mapRoughnessRepeat,
                      e.mapRoughnessOffset,
                      e.mapRoughnessWrap,
                      e.mapRoughnessAnisotropy,
                    );
                    break;
                  case 'mapRoughnessRepeat':
                  case 'mapRoughnessOffset':
                  case 'mapRoughnessWrap':
                  case 'mapRoughnessAnisotropy':
                    break;
                  case 'mapAlpha':
                    a.alphaMap = i(
                      s,
                      e.mapAlphaRepeat,
                      e.mapAlphaOffset,
                      e.mapAlphaWrap,
                      e.mapAlphaAnisotropy,
                    );
                    break;
                  case 'mapAlphaRepeat':
                  case 'mapAlphaOffset':
                  case 'mapAlphaWrap':
                  case 'mapAlphaAnisotropy':
                    break;
                  case 'flipSided':
                    a.side = L;
                    break;
                  case 'doubleSided':
                    a.side = R;
                    break;
                  case 'transparency':
                    console.warn(
                      'THREE.Loader.createMaterial: transparency has been renamed to opacity',
                    ),
                      (a.opacity = s);
                    break;
                  case 'depthTest':
                  case 'depthWrite':
                  case 'colorWrite':
                  case 'opacity':
                  case 'reflectivity':
                  case 'transparent':
                  case 'visible':
                  case 'wireframe':
                    a[o] = s;
                    break;
                  case 'vertexColors':
                    !0 === s && (a.vertexColors = D), 'face' === s && (a.vertexColors = I);
                    break;
                  default:
                    console.error('THREE.Loader.createMaterial: Unsupported', o, s);
                }
              }
              return (
                'MeshBasicMaterial' === a.type && delete a.emissive,
                'MeshPhongMaterial' !== a.type && delete a.specular,
                a.opacity < 1 && (a.transparent = !0),
                Cc.setTextures(n),
                Cc.parse(a)
              );
            }),
        });
      var Hc,
        kc,
        Vc,
        jc,
        Wc,
        qc,
        Xc,
        Yc,
        Jc,
        Zc,
        Kc = {
          getContext: function () {
            return (
              void 0 === Pc && (Pc = new (window.AudioContext || window.webkitAudioContext)()), Pc
            );
          },
          setContext: function (e) {
            Pc = e;
          },
        };
      function Qc(e) {
        this.manager = void 0 !== e ? e : Is;
      }
      function $c() {
        (this.type = 'StereoCamera'),
          (this.aspect = 1),
          (this.eyeSep = 0.064),
          (this.cameraL = new la()),
          this.cameraL.layers.enable(1),
          (this.cameraL.matrixAutoUpdate = !1),
          (this.cameraR = new la()),
          this.cameraR.layers.enable(2),
          (this.cameraR.matrixAutoUpdate = !1);
      }
      function eu(e, t, r, n) {
        kr.call(this), (this.type = 'CubeCamera');
        var i = new la(90, 1, e, t);
        i.up.set(0, -1, 0), i.lookAt(new tr(1, 0, 0)), this.add(i);
        var a = new la(90, 1, e, t);
        a.up.set(0, -1, 0), a.lookAt(new tr(-1, 0, 0)), this.add(a);
        var o = new la(90, 1, e, t);
        o.up.set(0, 0, 1), o.lookAt(new tr(0, 1, 0)), this.add(o);
        var s = new la(90, 1, e, t);
        s.up.set(0, 0, -1), s.lookAt(new tr(0, -1, 0)), this.add(s);
        var c = new la(90, 1, e, t);
        c.up.set(0, -1, 0), c.lookAt(new tr(0, 0, 1)), this.add(c);
        var u = new la(90, 1, e, t);
        u.up.set(0, -1, 0),
          u.lookAt(new tr(0, 0, -1)),
          this.add(u),
          (n = n || { format: Ze, magFilter: De, minFilter: De }),
          (this.renderTarget = new fr(r, r, n)),
          (this.renderTarget.texture.name = 'CubeCamera'),
          (this.update = function (e, t) {
            null === this.parent && this.updateMatrixWorld();
            var r = e.getRenderTarget(),
              n = this.renderTarget,
              l = n.texture.generateMipmaps;
            (n.texture.generateMipmaps = !1),
              (n.activeCubeFace = 0),
              e.render(t, i, n),
              (n.activeCubeFace = 1),
              e.render(t, a, n),
              (n.activeCubeFace = 2),
              e.render(t, o, n),
              (n.activeCubeFace = 3),
              e.render(t, s, n),
              (n.activeCubeFace = 4),
              e.render(t, c, n),
              (n.texture.generateMipmaps = l),
              (n.activeCubeFace = 5),
              e.render(t, u, n),
              e.setRenderTarget(r);
          }),
          (this.clear = function (e, t, r, n) {
            for (var i = e.getRenderTarget(), a = this.renderTarget, o = 0; o < 6; o++)
              (a.activeCubeFace = o), e.setRenderTarget(a), e.clear(t, r, n);
            e.setRenderTarget(i);
          });
      }
      function tu(e) {
        (this.autoStart = void 0 === e || e),
          (this.startTime = 0),
          (this.oldTime = 0),
          (this.elapsedTime = 0),
          (this.running = !1);
      }
      function ru() {
        kr.call(this),
          (this.type = 'AudioListener'),
          (this.context = Kc.getContext()),
          (this.gain = this.context.createGain()),
          this.gain.connect(this.context.destination),
          (this.filter = null),
          (this.timeDelta = 0);
      }
      function nu(e) {
        kr.call(this),
          (this.type = 'Audio'),
          (this.listener = e),
          (this.context = e.context),
          (this.gain = this.context.createGain()),
          this.gain.connect(e.getInput()),
          (this.autoplay = !1),
          (this.buffer = null),
          (this.detune = 0),
          (this.loop = !1),
          (this.startTime = 0),
          (this.offset = 0),
          (this.playbackRate = 1),
          (this.isPlaying = !1),
          (this.hasPlaybackControl = !0),
          (this.sourceType = 'empty'),
          (this.filters = []);
      }
      function iu(e) {
        nu.call(this, e),
          (this.panner = this.context.createPanner()),
          this.panner.connect(this.gain);
      }
      function au(e, t) {
        (this.analyser = e.context.createAnalyser()),
          (this.analyser.fftSize = void 0 !== t ? t : 2048),
          (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
          e.getOutput().connect(this.analyser);
      }
      function ou(e, t, r) {
        (this.binding = e), (this.valueSize = r);
        var n,
          i = Float64Array;
        switch (t) {
          case 'quaternion':
            n = this._slerp;
            break;
          case 'string':
          case 'bool':
            (i = Array), (n = this._select);
            break;
          default:
            n = this._lerp;
        }
        (this.buffer = new i(4 * r)),
          (this._mixBufferRegion = n),
          (this.cumulativeWeight = 0),
          (this.useCount = 0),
          (this.referenceCount = 0);
      }
      Object.assign(Qc.prototype, {
        load: function (e, t, r, n) {
          var i = new Bs(this.manager);
          i.setResponseType('arraybuffer'),
            i.setPath(this.path),
            i.load(
              e,
              function (e) {
                var r = e.slice(0);
                Kc.getContext().decodeAudioData(r, function (e) {
                  t(e);
                });
              },
              r,
              n,
            );
        },
        setPath: function (e) {
          return (this.path = e), this;
        },
      }),
        Object.assign($c.prototype, {
          update:
            ((Jc = new $t()),
            (Zc = new $t()),
            function (e) {
              if (
                Hc !== this ||
                kc !== e.focus ||
                Vc !== e.fov ||
                jc !== e.aspect * this.aspect ||
                Wc !== e.near ||
                qc !== e.far ||
                Xc !== e.zoom ||
                Yc !== this.eyeSep
              ) {
                (Hc = this),
                  (kc = e.focus),
                  (Vc = e.fov),
                  (jc = e.aspect * this.aspect),
                  (Wc = e.near),
                  (qc = e.far),
                  (Xc = e.zoom);
                var t,
                  r,
                  n = e.projectionMatrix.clone(),
                  i = ((Yc = this.eyeSep / 2) * Wc) / kc,
                  a = (Wc * Math.tan(Kt.DEG2RAD * Vc * 0.5)) / Xc;
                (Zc.elements[12] = -Yc),
                  (Jc.elements[12] = Yc),
                  (t = -a * jc + i),
                  (r = a * jc + i),
                  (n.elements[0] = (2 * Wc) / (r - t)),
                  (n.elements[8] = (r + t) / (r - t)),
                  this.cameraL.projectionMatrix.copy(n),
                  (t = -a * jc - i),
                  (r = a * jc - i),
                  (n.elements[0] = (2 * Wc) / (r - t)),
                  (n.elements[8] = (r + t) / (r - t)),
                  this.cameraR.projectionMatrix.copy(n);
              }
              this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Zc),
                this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Jc);
            }),
        }),
        (eu.prototype = Object.create(kr.prototype)),
        (eu.prototype.constructor = eu),
        Object.assign(tu.prototype, {
          start: function () {
            (this.startTime = ('undefined' == typeof performance ? Date : performance).now()),
              (this.oldTime = this.startTime),
              (this.elapsedTime = 0),
              (this.running = !0);
          },
          stop: function () {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
          },
          getElapsedTime: function () {
            return this.getDelta(), this.elapsedTime;
          },
          getDelta: function () {
            var e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
              var t = ('undefined' == typeof performance ? Date : performance).now();
              (e = (t - this.oldTime) / 1e3), (this.oldTime = t), (this.elapsedTime += e);
            }
            return e;
          },
        }),
        (ru.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: ru,
          getInput: function () {
            return this.gain;
          },
          removeFilter: function () {
            return (
              null !== this.filter &&
                (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                (this.filter = null)),
              this
            );
          },
          getFilter: function () {
            return this.filter;
          },
          setFilter: function (e) {
            return (
              null !== this.filter
                ? (this.gain.disconnect(this.filter),
                  this.filter.disconnect(this.context.destination))
                : this.gain.disconnect(this.context.destination),
              (this.filter = e),
              this.gain.connect(this.filter),
              this.filter.connect(this.context.destination),
              this
            );
          },
          getMasterVolume: function () {
            return this.gain.gain.value;
          },
          setMasterVolume: function (e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
          },
          updateMatrixWorld: (function () {
            var e = new tr(),
              t = new er(),
              r = new tr(),
              n = new tr(),
              i = new tu();
            return function (a) {
              kr.prototype.updateMatrixWorld.call(this, a);
              var o = this.context.listener,
                s = this.up;
              if (
                ((this.timeDelta = i.getDelta()),
                this.matrixWorld.decompose(e, t, r),
                n.set(0, 0, -1).applyQuaternion(t),
                o.positionX)
              ) {
                var c = this.context.currentTime + this.timeDelta;
                o.positionX.linearRampToValueAtTime(e.x, c),
                  o.positionY.linearRampToValueAtTime(e.y, c),
                  o.positionZ.linearRampToValueAtTime(e.z, c),
                  o.forwardX.linearRampToValueAtTime(n.x, c),
                  o.forwardY.linearRampToValueAtTime(n.y, c),
                  o.forwardZ.linearRampToValueAtTime(n.z, c),
                  o.upX.linearRampToValueAtTime(s.x, c),
                  o.upY.linearRampToValueAtTime(s.y, c),
                  o.upZ.linearRampToValueAtTime(s.z, c);
              } else o.setPosition(e.x, e.y, e.z), o.setOrientation(n.x, n.y, n.z, s.x, s.y, s.z);
            };
          })(),
        })),
        (nu.prototype = Object.assign(Object.create(kr.prototype), {
          constructor: nu,
          getOutput: function () {
            return this.gain;
          },
          setNodeSource: function (e) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'audioNode'),
              (this.source = e),
              this.connect(),
              this
            );
          },
          setMediaElementSource: function (e) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'mediaNode'),
              (this.source = this.context.createMediaElementSource(e)),
              this.connect(),
              this
            );
          },
          setBuffer: function (e) {
            return (
              (this.buffer = e), (this.sourceType = 'buffer'), this.autoplay && this.play(), this
            );
          },
          play: function () {
            if (!0 !== this.isPlaying) {
              if (!1 !== this.hasPlaybackControl) {
                var e = this.context.createBufferSource();
                return (
                  (e.buffer = this.buffer),
                  (e.loop = this.loop),
                  (e.onended = this.onEnded.bind(this)),
                  (this.startTime = this.context.currentTime),
                  e.start(this.startTime, this.offset),
                  (this.isPlaying = !0),
                  (this.source = e),
                  this.setDetune(this.detune),
                  this.setPlaybackRate(this.playbackRate),
                  this.connect()
                );
              }
              console.warn('THREE.Audio: this Audio has no playback control.');
            } else console.warn('THREE.Audio: Audio is already playing.');
          },
          pause: function () {
            if (!1 !== this.hasPlaybackControl)
              return (
                !0 === this.isPlaying &&
                  (this.source.stop(),
                  (this.source.onended = null),
                  (this.offset += (this.context.currentTime - this.startTime) * this.playbackRate),
                  (this.isPlaying = !1)),
                this
              );
            console.warn('THREE.Audio: this Audio has no playback control.');
          },
          stop: function () {
            if (!1 !== this.hasPlaybackControl)
              return (
                this.source.stop(),
                (this.source.onended = null),
                (this.offset = 0),
                (this.isPlaying = !1),
                this
              );
            console.warn('THREE.Audio: this Audio has no playback control.');
          },
          connect: function () {
            if (this.filters.length > 0) {
              this.source.connect(this.filters[0]);
              for (var e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
              this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return this;
          },
          disconnect: function () {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0]);
              for (var e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].disconnect(this.filters[e]);
              this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else this.source.disconnect(this.getOutput());
            return this;
          },
          getFilters: function () {
            return this.filters;
          },
          setFilters: function (e) {
            return (
              e || (e = []),
              !0 === this.isPlaying
                ? (this.disconnect(), (this.filters = e), this.connect())
                : (this.filters = e),
              this
            );
          },
          setDetune: function (e) {
            if (((this.detune = e), void 0 !== this.source.detune))
              return (
                !0 === this.isPlaying &&
                  this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01),
                this
              );
          },
          getDetune: function () {
            return this.detune;
          },
          getFilter: function () {
            return this.getFilters()[0];
          },
          setFilter: function (e) {
            return this.setFilters(e ? [e] : []);
          },
          setPlaybackRate: function (e) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.playbackRate = e),
                !0 === this.isPlaying &&
                  this.source.playbackRate.setTargetAtTime(
                    this.playbackRate,
                    this.context.currentTime,
                    0.01,
                  ),
                this
              );
            console.warn('THREE.Audio: this Audio has no playback control.');
          },
          getPlaybackRate: function () {
            return this.playbackRate;
          },
          onEnded: function () {
            this.isPlaying = !1;
          },
          getLoop: function () {
            return !1 === this.hasPlaybackControl
              ? (console.warn('THREE.Audio: this Audio has no playback control.'), !1)
              : this.loop;
          },
          setLoop: function (e) {
            if (!1 !== this.hasPlaybackControl)
              return (this.loop = e), !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn('THREE.Audio: this Audio has no playback control.');
          },
          getVolume: function () {
            return this.gain.gain.value;
          },
          setVolume: function (e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
          },
        })),
        (iu.prototype = Object.assign(Object.create(nu.prototype), {
          constructor: iu,
          getOutput: function () {
            return this.panner;
          },
          getRefDistance: function () {
            return this.panner.refDistance;
          },
          setRefDistance: function (e) {
            return (this.panner.refDistance = e), this;
          },
          getRolloffFactor: function () {
            return this.panner.rolloffFactor;
          },
          setRolloffFactor: function (e) {
            return (this.panner.rolloffFactor = e), this;
          },
          getDistanceModel: function () {
            return this.panner.distanceModel;
          },
          setDistanceModel: function (e) {
            return (this.panner.distanceModel = e), this;
          },
          getMaxDistance: function () {
            return this.panner.maxDistance;
          },
          setMaxDistance: function (e) {
            return (this.panner.maxDistance = e), this;
          },
          setDirectionalCone: function (e, t, r) {
            return (
              (this.panner.coneInnerAngle = e),
              (this.panner.coneOuterAngle = t),
              (this.panner.coneOuterGain = r),
              this
            );
          },
          updateMatrixWorld: (function () {
            var e = new tr(),
              t = new er(),
              r = new tr(),
              n = new tr();
            return function (i) {
              if ((kr.prototype.updateMatrixWorld.call(this, i), !1 !== this.isPlaying)) {
                this.matrixWorld.decompose(e, t, r), n.set(0, 0, 1).applyQuaternion(t);
                var a = this.panner;
                if (a.positionX) {
                  var o = this.context.currentTime + this.listener.timeDelta;
                  a.positionX.linearRampToValueAtTime(e.x, o),
                    a.positionY.linearRampToValueAtTime(e.y, o),
                    a.positionZ.linearRampToValueAtTime(e.z, o),
                    a.orientationX.linearRampToValueAtTime(n.x, o),
                    a.orientationY.linearRampToValueAtTime(n.y, o),
                    a.orientationZ.linearRampToValueAtTime(n.z, o);
                } else a.setPosition(e.x, e.y, e.z), a.setOrientation(n.x, n.y, n.z);
              }
            };
          })(),
        })),
        Object.assign(au.prototype, {
          getFrequencyData: function () {
            return this.analyser.getByteFrequencyData(this.data), this.data;
          },
          getAverageFrequency: function () {
            for (var e = 0, t = this.getFrequencyData(), r = 0; r < t.length; r++) e += t[r];
            return e / t.length;
          },
        }),
        Object.assign(ou.prototype, {
          accumulate: function (e, t) {
            var r = this.buffer,
              n = this.valueSize,
              i = e * n + n,
              a = this.cumulativeWeight;
            if (0 === a) {
              for (var o = 0; o !== n; ++o) r[i + o] = r[o];
              a = t;
            } else {
              var s = t / (a += t);
              this._mixBufferRegion(r, i, 0, s, n);
            }
            this.cumulativeWeight = a;
          },
          apply: function (e) {
            var t = this.valueSize,
              r = this.buffer,
              n = e * t + t,
              i = this.cumulativeWeight,
              a = this.binding;
            if (((this.cumulativeWeight = 0), i < 1)) {
              var o = 3 * t;
              this._mixBufferRegion(r, n, o, 1 - i, t);
            }
            for (var s = t, c = t + t; s !== c; ++s)
              if (r[s] !== r[s + t]) {
                a.setValue(r, n);
                break;
              }
          },
          saveOriginalState: function () {
            var e = this.binding,
              t = this.buffer,
              r = this.valueSize,
              n = 3 * r;
            e.getValue(t, n);
            for (var i = r, a = n; i !== a; ++i) t[i] = t[n + (i % r)];
            this.cumulativeWeight = 0;
          },
          restoreOriginalState: function () {
            var e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e);
          },
          _select: function (e, t, r, n, i) {
            if (n >= 0.5) for (var a = 0; a !== i; ++a) e[t + a] = e[r + a];
          },
          _slerp: function (e, t, r, n) {
            er.slerpFlat(e, t, e, t, e, r, n);
          },
          _lerp: function (e, t, r, n, i) {
            for (var a = 1 - n, o = 0; o !== i; ++o) {
              var s = t + o;
              e[s] = e[s] * a + e[r + o] * n;
            }
          },
        });
      var su, cu, uu, lu, hu, du, pu, fu, mu, vu, gu, yu, xu, bu, wu;
      function _u(e, t, r) {
        var n = r || Mu.parseTrackName(t);
        (this._targetGroup = e), (this._bindings = e.subscribe_(t, n));
      }
      function Mu(e, t, r) {
        (this.path = t),
          (this.parsedPath = r || Mu.parseTrackName(t)),
          (this.node = Mu.findNode(e, this.parsedPath.nodeName) || e),
          (this.rootNode = e);
      }
      function Su() {
        (this.uuid = Kt.generateUUID()),
          (this._objects = Array.prototype.slice.call(arguments)),
          (this.nCachedObjects_ = 0);
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, r = arguments.length; t !== r; ++t) e[arguments[t].uuid] = t;
        (this._paths = []),
          (this._parsedPaths = []),
          (this._bindings = []),
          (this._bindingsIndicesByPath = {});
        var n = this;
        this.stats = {
          objects: {
            get total() {
              return n._objects.length;
            },
            get inUse() {
              return this.total - n.nCachedObjects_;
            },
          },
          get bindingsPerObject() {
            return n._bindings.length;
          },
        };
      }
      function Eu(e, t, r) {
        (this._mixer = e), (this._clip = t), (this._localRoot = r || null);
        for (
          var n = t.tracks,
            i = n.length,
            a = new Array(i),
            o = { endingStart: It, endingEnd: It },
            s = 0;
          s !== i;
          ++s
        ) {
          var c = n[s].createInterpolant(null);
          (a[s] = c), (c.settings = o);
        }
        (this._interpolantSettings = o),
          (this._interpolants = a),
          (this._propertyBindings = new Array(i)),
          (this._cacheIndex = null),
          (this._byClipCacheIndex = null),
          (this._timeScaleInterpolant = null),
          (this._weightInterpolant = null),
          (this.loop = Lt),
          (this._loopCount = -1),
          (this._startTime = null),
          (this.time = 0),
          (this.timeScale = 1),
          (this._effectiveTimeScale = 1),
          (this.weight = 1),
          (this._effectiveWeight = 1),
          (this.repetitions = 1 / 0),
          (this.paused = !1),
          (this.enabled = !0),
          (this.clampWhenFinished = !1),
          (this.zeroSlopeAtStart = !0),
          (this.zeroSlopeAtEnd = !0);
      }
      function Tu(e) {
        (this._root = e),
          this._initMemoryManager(),
          (this._accuIndex = 0),
          (this.time = 0),
          (this.timeScale = 1);
      }
      function Au(e) {
        'string' == typeof e &&
          (console.warn('THREE.Uniform: Type parameter is no longer needed.'), (e = arguments[1])),
          (this.value = e);
      }
      function Lu() {
        sn.call(this), (this.type = 'InstancedBufferGeometry'), (this.maxInstancedCount = void 0);
      }
      function Ru(e, t, r) {
        Aa.call(this, e, t), (this.meshPerAttribute = r || 1);
      }
      function Cu(e, t, r, n) {
        'number' == typeof r &&
          ((n = r),
          (r = !1),
          console.error(
            'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.',
          )),
          Xr.call(this, e, t, r),
          (this.meshPerAttribute = n || 1);
      }
      function Pu(e, t, r, n) {
        (this.ray = new An(e, t)),
          (this.near = r || 0),
          (this.far = n || 1 / 0),
          (this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }),
          Object.defineProperties(this.params, {
            PointCloud: {
              get: function () {
                return (
                  console.warn(
                    'THREE.Raycaster: params.PointCloud has been renamed to params.Points.',
                  ),
                  this.Points
                );
              },
            },
          });
      }
      function Ou(e, t) {
        return e.distance - t.distance;
      }
      function Iu(e, t, r, n) {
        if (!1 !== e.visible && (e.raycast(t, r), !0 === n))
          for (var i = e.children, a = 0, o = i.length; a < o; a++) Iu(i[a], t, r, !0);
      }
      function Du(e, t, r) {
        return (
          (this.radius = void 0 !== e ? e : 1),
          (this.phi = void 0 !== t ? t : 0),
          (this.theta = void 0 !== r ? r : 0),
          this
        );
      }
      function Bu(e, t, r) {
        return (
          (this.radius = void 0 !== e ? e : 1),
          (this.theta = void 0 !== t ? t : 0),
          (this.y = void 0 !== r ? r : 0),
          this
        );
      }
      function Nu(e, t) {
        (this.min = void 0 !== e ? e : new Qt(1 / 0, 1 / 0)),
          (this.max = void 0 !== t ? t : new Qt(-1 / 0, -1 / 0));
      }
      function Uu(e, t) {
        (this.start = void 0 !== e ? e : new tr()), (this.end = void 0 !== t ? t : new tr());
      }
      function Gu(e) {
        kr.call(this), (this.material = e), (this.render = function () {});
      }
      function Fu(e, t, r, n) {
        (this.object = e), (this.size = void 0 !== t ? t : 1);
        var i = void 0 !== r ? r : 16711680,
          a = void 0 !== n ? n : 1,
          o = 0,
          s = this.object.geometry;
        s && s.isGeometry
          ? (o = 3 * s.faces.length)
          : s && s.isBufferGeometry && (o = s.attributes.normal.count);
        var c = new sn(),
          u = new tn(2 * o * 3, 3);
        c.addAttribute('position', u),
          Ua.call(this, c, new Ba({ color: i, linewidth: a })),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      function zu(e, t) {
        kr.call(this),
          (this.light = e),
          this.light.updateMatrixWorld(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = t);
        for (
          var r = new sn(),
            n = [
              0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
              -1, 1,
            ],
            i = 0,
            a = 1;
          i < 32;
          i++, a++
        ) {
          var o = (i / 32) * Math.PI * 2,
            s = (a / 32) * Math.PI * 2;
          n.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1);
        }
        r.addAttribute('position', new tn(n, 3));
        var c = new Ba({ fog: !1 });
        (this.cone = new Ua(r, c)), this.add(this.cone), this.update();
      }
      function Hu(e) {
        for (
          var t = (function e(t) {
              var r = [];
              t && t.isBone && r.push(t);
              for (var n = 0; n < t.children.length; n++) r.push.apply(r, e(t.children[n]));
              return r;
            })(e),
            r = new sn(),
            n = [],
            i = [],
            a = new Lr(0, 0, 1),
            o = new Lr(0, 1, 0),
            s = 0;
          s < t.length;
          s++
        ) {
          var c = t[s];
          c.parent &&
            c.parent.isBone &&
            (n.push(0, 0, 0), n.push(0, 0, 0), i.push(a.r, a.g, a.b), i.push(o.r, o.g, o.b));
        }
        r.addAttribute('position', new tn(n, 3)), r.addAttribute('color', new tn(i, 3));
        var u = new Ba({ vertexColors: D, depthTest: !1, depthWrite: !1, transparent: !0 });
        Ua.call(this, r, u),
          (this.root = e),
          (this.bones = t),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1);
      }
      function ku(e, t, r) {
        (this.light = e), this.light.updateMatrixWorld(), (this.color = r);
        var n = new Vo(t, 4, 2),
          i = new Rn({ wireframe: !0, fog: !1 });
        Cn.call(this, n, i),
          (this.matrix = this.light.matrixWorld),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      function Vu(e, t) {
        (this.type = 'RectAreaLightHelper'), (this.light = e), (this.color = t);
        var r = new sn();
        r.addAttribute('position', new tn([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)),
          r.computeBoundingSphere();
        var n = new Ba({ fog: !1 });
        Na.call(this, r, n);
        var i = new sn();
        i.addAttribute(
          'position',
          new tn([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3),
        ),
          i.computeBoundingSphere(),
          this.add(new Cn(i, new Rn({ side: L, fog: !1 }))),
          this.update();
      }
      function ju(e, t, r) {
        kr.call(this),
          (this.light = e),
          this.light.updateMatrixWorld(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = r);
        var n = new $a(t);
        n.rotateY(0.5 * Math.PI),
          (this.material = new Rn({ wireframe: !0, fog: !1 })),
          void 0 === this.color && (this.material.vertexColors = D);
        var i = n.getAttribute('position'),
          a = new Float32Array(3 * i.count);
        n.addAttribute('color', new Xr(a, 3)), this.add(new Cn(n, this.material)), this.update();
      }
      function Wu(e, t, r, n) {
        (e = e || 10),
          (t = t || 10),
          (r = new Lr(void 0 !== r ? r : 4473924)),
          (n = new Lr(void 0 !== n ? n : 8947848));
        for (
          var i = t / 2, a = e / t, o = e / 2, s = [], c = [], u = 0, l = 0, h = -o;
          u <= t;
          u++, h += a
        ) {
          s.push(-o, 0, h, o, 0, h), s.push(h, 0, -o, h, 0, o);
          var d = u === i ? r : n;
          d.toArray(c, l),
            (l += 3),
            d.toArray(c, l),
            (l += 3),
            d.toArray(c, l),
            (l += 3),
            d.toArray(c, l),
            (l += 3);
        }
        var p = new sn();
        p.addAttribute('position', new tn(s, 3)), p.addAttribute('color', new tn(c, 3));
        var f = new Ba({ vertexColors: D });
        Ua.call(this, p, f);
      }
      function qu(e, t, r, n, i, a) {
        (e = e || 10),
          (t = t || 16),
          (r = r || 8),
          (n = n || 64),
          (i = new Lr(void 0 !== i ? i : 4473924)),
          (a = new Lr(void 0 !== a ? a : 8947848));
        var o,
          s,
          c,
          u,
          l,
          h,
          d,
          p = [],
          f = [];
        for (u = 0; u <= t; u++)
          (c = (u / t) * (2 * Math.PI)),
            (o = Math.sin(c) * e),
            (s = Math.cos(c) * e),
            p.push(0, 0, 0),
            p.push(o, 0, s),
            (d = 1 & u ? i : a),
            f.push(d.r, d.g, d.b),
            f.push(d.r, d.g, d.b);
        for (u = 0; u <= r; u++)
          for (d = 1 & u ? i : a, h = e - (e / r) * u, l = 0; l < n; l++)
            (c = (l / n) * (2 * Math.PI)),
              (o = Math.sin(c) * h),
              (s = Math.cos(c) * h),
              p.push(o, 0, s),
              f.push(d.r, d.g, d.b),
              (c = ((l + 1) / n) * (2 * Math.PI)),
              (o = Math.sin(c) * h),
              (s = Math.cos(c) * h),
              p.push(o, 0, s),
              f.push(d.r, d.g, d.b);
        var m = new sn();
        m.addAttribute('position', new tn(p, 3)), m.addAttribute('color', new tn(f, 3));
        var v = new Ba({ vertexColors: D });
        Ua.call(this, m, v);
      }
      function Xu(e, t, r, n) {
        (this.object = e), (this.size = void 0 !== t ? t : 1);
        var i = void 0 !== r ? r : 16776960,
          a = void 0 !== n ? n : 1,
          o = 0,
          s = this.object.geometry;
        s && s.isGeometry
          ? (o = s.faces.length)
          : console.warn(
              'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.',
            );
        var c = new sn(),
          u = new tn(2 * o * 3, 3);
        c.addAttribute('position', u),
          Ua.call(this, c, new Ba({ color: i, linewidth: a })),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      function Yu(e, t, r) {
        kr.call(this),
          (this.light = e),
          this.light.updateMatrixWorld(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = r),
          void 0 === t && (t = 1);
        var n = new sn();
        n.addAttribute('position', new tn([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
        var i = new Ba({ fog: !1 });
        (this.lightPlane = new Na(n, i)),
          this.add(this.lightPlane),
          (n = new sn()).addAttribute('position', new tn([0, 0, 0, 0, 0, 1], 3)),
          (this.targetLine = new Na(n, i)),
          this.add(this.targetLine),
          this.update();
      }
      function Ju(e) {
        var t = new sn(),
          r = new Ba({ color: 16777215, vertexColors: I }),
          n = [],
          i = [],
          a = {},
          o = new Lr(16755200),
          s = new Lr(16711680),
          c = new Lr(43775),
          u = new Lr(16777215),
          l = new Lr(3355443);
        function h(e, t, r) {
          d(e, r), d(t, r);
        }
        function d(e, t) {
          n.push(0, 0, 0),
            i.push(t.r, t.g, t.b),
            void 0 === a[e] && (a[e] = []),
            a[e].push(n.length / 3 - 1);
        }
        h('n1', 'n2', o),
          h('n2', 'n4', o),
          h('n4', 'n3', o),
          h('n3', 'n1', o),
          h('f1', 'f2', o),
          h('f2', 'f4', o),
          h('f4', 'f3', o),
          h('f3', 'f1', o),
          h('n1', 'f1', o),
          h('n2', 'f2', o),
          h('n3', 'f3', o),
          h('n4', 'f4', o),
          h('p', 'n1', s),
          h('p', 'n2', s),
          h('p', 'n3', s),
          h('p', 'n4', s),
          h('u1', 'u2', c),
          h('u2', 'u3', c),
          h('u3', 'u1', c),
          h('c', 't', u),
          h('p', 'c', l),
          h('cn1', 'cn2', l),
          h('cn3', 'cn4', l),
          h('cf1', 'cf2', l),
          h('cf3', 'cf4', l),
          t.addAttribute('position', new tn(n, 3)),
          t.addAttribute('color', new tn(i, 3)),
          Ua.call(this, t, r),
          (this.camera = e),
          this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.pointMap = a),
          this.update();
      }
      function Zu(e, t) {
        (this.object = e), void 0 === t && (t = 16776960);
        var r = new Uint16Array([
            0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
          ]),
          n = new Float32Array(24),
          i = new sn();
        i.setIndex(new Xr(r, 1)),
          i.addAttribute('position', new Xr(n, 3)),
          Ua.call(this, i, new Ba({ color: t })),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      function Ku(e, t) {
        (this.type = 'Box3Helper'), (this.box = e);
        var r = void 0 !== t ? t : 16776960,
          n = new Uint16Array([
            0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
          ]),
          i = new sn();
        i.setIndex(new Xr(n, 1)),
          i.addAttribute(
            'position',
            new tn(
              [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
              3,
            ),
          ),
          Ua.call(this, i, new Ba({ color: r })),
          this.geometry.computeBoundingSphere();
      }
      function Qu(e, t, r) {
        (this.type = 'PlaneHelper'), (this.plane = e), (this.size = void 0 === t ? 1 : t);
        var n = void 0 !== r ? r : 16776960,
          i = new sn();
        i.addAttribute(
          'position',
          new tn(
            [
              1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0,
              1, 0, 0, 0,
            ],
            3,
          ),
        ),
          i.computeBoundingSphere(),
          Na.call(this, i, new Ba({ color: n }));
        var a = new sn();
        a.addAttribute(
          'position',
          new tn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3),
        ),
          a.computeBoundingSphere(),
          this.add(new Cn(a, new Rn({ color: n, opacity: 0.2, transparent: !0, depthWrite: !1 })));
      }
      function $u(e, t, r, n, i, a) {
        kr.call(this),
          void 0 === e && (e = new tr(0, 0, 1)),
          void 0 === t && (t = new tr(0, 0, 0)),
          void 0 === r && (r = 1),
          void 0 === n && (n = 16776960),
          void 0 === i && (i = 0.2 * r),
          void 0 === a && (a = 0.2 * i),
          void 0 === yu &&
            ((yu = new sn()).addAttribute('position', new tn([0, 0, 0, 0, 1, 0], 3)),
            (xu = new $o(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
          this.position.copy(t),
          (this.line = new Na(yu, new Ba({ color: n }))),
          (this.line.matrixAutoUpdate = !1),
          this.add(this.line),
          (this.cone = new Cn(xu, new Rn({ color: n }))),
          (this.cone.matrixAutoUpdate = !1),
          this.add(this.cone),
          this.setDirection(e),
          this.setLength(r, i, a);
      }
      function el(e) {
        var t = [0, 0, 0, (e = e || 1), 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
          r = new sn();
        r.addAttribute('position', new tn(t, 3)),
          r.addAttribute(
            'color',
            new tn([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3),
          );
        var n = new Ba({ vertexColors: D });
        Ua.call(this, r, n);
      }
      function tl(e, t, r, n, i, a, o) {
        return (
          console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.'),
          new Dr(e, t, r, i, a, o)
        );
      }
      Object.assign(_u.prototype, {
        getValue: function (e, t) {
          this.bind();
          var r = this._targetGroup.nCachedObjects_,
            n = this._bindings[r];
          void 0 !== n && n.getValue(e, t);
        },
        setValue: function (e, t) {
          for (
            var r = this._bindings, n = this._targetGroup.nCachedObjects_, i = r.length;
            n !== i;
            ++n
          )
            r[n].setValue(e, t);
        },
        bind: function () {
          for (
            var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length;
            t !== r;
            ++t
          )
            e[t].bind();
        },
        unbind: function () {
          for (
            var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length;
            t !== r;
            ++t
          )
            e[t].unbind();
        },
      }),
        Object.assign(Mu, {
          Composite: _u,
          create: function (e, t, r) {
            return e && e.isAnimationObjectGroup ? new Mu.Composite(e, t, r) : new Mu(e, t, r);
          },
          sanitizeNodeName:
            ((mu = new RegExp('[\\[\\]\\.:\\/]', 'g')),
            function (e) {
              return e.replace(/\s/g, '_').replace(mu, '');
            }),
          parseTrackName:
            ((su = '[^\\[\\]\\.:\\/]'),
            (cu = '[^' + '\\[\\]\\.:\\/'.replace('\\.', '') + ']'),
            (uu = /((?:WC+[\/:])*)/.source.replace('WC', su)),
            (lu = /(WCOD+)?/.source.replace('WCOD', cu)),
            (hu = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', su)),
            (du = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', su)),
            (pu = new RegExp('^' + uu + lu + hu + du + '$')),
            (fu = ['material', 'materials', 'bones']),
            function (e) {
              var t = pu.exec(e);
              if (!t) throw new Error('PropertyBinding: Cannot parse trackName: ' + e);
              var r = {
                  nodeName: t[2],
                  objectName: t[3],
                  objectIndex: t[4],
                  propertyName: t[5],
                  propertyIndex: t[6],
                },
                n = r.nodeName && r.nodeName.lastIndexOf('.');
              if (void 0 !== n && -1 !== n) {
                var i = r.nodeName.substring(n + 1);
                -1 !== fu.indexOf(i) &&
                  ((r.nodeName = r.nodeName.substring(0, n)), (r.objectName = i));
              }
              if (null === r.propertyName || 0 === r.propertyName.length)
                throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + e);
              return r;
            }),
          findNode: function (e, t) {
            if (
              !t ||
              '' === t ||
              'root' === t ||
              '.' === t ||
              -1 === t ||
              t === e.name ||
              t === e.uuid
            )
              return e;
            if (e.skeleton) {
              var r = e.skeleton.getBoneByName(t);
              if (void 0 !== r) return r;
            }
            if (e.children) {
              var n = function (e) {
                  for (var r = 0; r < e.length; r++) {
                    var i = e[r];
                    if (i.name === t || i.uuid === t) return i;
                    var a = n(i.children);
                    if (a) return a;
                  }
                  return null;
                },
                i = n(e.children);
              if (i) return i;
            }
            return null;
          },
        }),
        Object.assign(Mu.prototype, {
          _getValue_unavailable: function () {},
          _setValue_unavailable: function () {},
          BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 },
          Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
          GetterByBindingType: [
            function (e, t) {
              e[t] = this.node[this.propertyName];
            },
            function (e, t) {
              for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n) e[t++] = r[n];
            },
            function (e, t) {
              e[t] = this.resolvedProperty[this.propertyIndex];
            },
            function (e, t) {
              this.resolvedProperty.toArray(e, t);
            },
          ],
          SetterByBindingTypeAndVersioning: [
            [
              function (e, t) {
                this.targetObject[this.propertyName] = e[t];
              },
              function (e, t) {
                (this.targetObject[this.propertyName] = e[t]), (this.targetObject.needsUpdate = !0);
              },
              function (e, t) {
                (this.targetObject[this.propertyName] = e[t]),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
            [
              function (e, t) {
                for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n)
                  r[n] = e[t++];
              },
              function (e, t) {
                for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n)
                  r[n] = e[t++];
                this.targetObject.needsUpdate = !0;
              },
              function (e, t) {
                for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n)
                  r[n] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0;
              },
            ],
            [
              function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t];
              },
              function (e, t) {
                (this.resolvedProperty[this.propertyIndex] = e[t]),
                  (this.targetObject.needsUpdate = !0);
              },
              function (e, t) {
                (this.resolvedProperty[this.propertyIndex] = e[t]),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
            [
              function (e, t) {
                this.resolvedProperty.fromArray(e, t);
              },
              function (e, t) {
                this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
              },
              function (e, t) {
                this.resolvedProperty.fromArray(e, t),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
          ],
          getValue: function (e, t) {
            this.bind(), this.getValue(e, t);
          },
          setValue: function (e, t) {
            this.bind(), this.setValue(e, t);
          },
          bind: function () {
            var e = this.node,
              t = this.parsedPath,
              r = t.objectName,
              n = t.propertyName,
              i = t.propertyIndex;
            if (
              (e ||
                ((e = Mu.findNode(this.rootNode, t.nodeName) || this.rootNode), (this.node = e)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              e)
            ) {
              if (r) {
                var a = t.objectIndex;
                switch (r) {
                  case 'materials':
                    if (!e.material)
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                        this,
                      );
                    if (!e.material.materials)
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                        this,
                      );
                    e = e.material.materials;
                    break;
                  case 'bones':
                    if (!e.skeleton)
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                        this,
                      );
                    e = e.skeleton.bones;
                    for (var o = 0; o < e.length; o++)
                      if (e[o].name === a) {
                        a = o;
                        break;
                      }
                    break;
                  default:
                    if (void 0 === e[r])
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                        this,
                      );
                    e = e[r];
                }
                if (void 0 !== a) {
                  if (void 0 === e[a])
                    return void console.error(
                      'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                      this,
                      e,
                    );
                  e = e[a];
                }
              }
              var s = e[n];
              if (void 0 !== s) {
                var c = this.Versioning.None;
                (this.targetObject = e),
                  void 0 !== e.needsUpdate
                    ? (c = this.Versioning.NeedsUpdate)
                    : void 0 !== e.matrixWorldNeedsUpdate &&
                      (c = this.Versioning.MatrixWorldNeedsUpdate);
                var u = this.BindingType.Direct;
                if (void 0 !== i) {
                  if ('morphTargetInfluences' === n) {
                    if (!e.geometry)
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                        this,
                      );
                    if (e.geometry.isBufferGeometry) {
                      if (!e.geometry.morphAttributes)
                        return void console.error(
                          'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                          this,
                        );
                      for (o = 0; o < this.node.geometry.morphAttributes.position.length; o++)
                        if (e.geometry.morphAttributes.position[o].name === i) {
                          i = o;
                          break;
                        }
                    } else {
                      if (!e.geometry.morphTargets)
                        return void console.error(
                          'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.',
                          this,
                        );
                      for (o = 0; o < this.node.geometry.morphTargets.length; o++)
                        if (e.geometry.morphTargets[o].name === i) {
                          i = o;
                          break;
                        }
                    }
                  }
                  (u = this.BindingType.ArrayElement),
                    (this.resolvedProperty = s),
                    (this.propertyIndex = i);
                } else
                  void 0 !== s.fromArray && void 0 !== s.toArray
                    ? ((u = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
                    : Array.isArray(s)
                    ? ((u = this.BindingType.EntireArray), (this.resolvedProperty = s))
                    : (this.propertyName = n);
                (this.getValue = this.GetterByBindingType[u]),
                  (this.setValue = this.SetterByBindingTypeAndVersioning[u][c]);
              } else {
                var l = t.nodeName;
                console.error(
                  'THREE.PropertyBinding: Trying to update property for track: ' +
                    l +
                    '.' +
                    n +
                    " but it wasn't found.",
                  e,
                );
              }
            } else
              console.error(
                'THREE.PropertyBinding: Trying to update node for track: ' +
                  this.path +
                  " but it wasn't found.",
              );
          },
          unbind: function () {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          },
        }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(Mu.prototype, {
          _getValue_unbound: Mu.prototype.getValue,
          _setValue_unbound: Mu.prototype.setValue,
        }),
        Object.assign(Su.prototype, {
          isAnimationObjectGroup: !0,
          add: function () {
            for (
              var e = this._objects,
                t = e.length,
                r = this.nCachedObjects_,
                n = this._indicesByUUID,
                i = this._paths,
                a = this._parsedPaths,
                o = this._bindings,
                s = o.length,
                c = void 0,
                u = 0,
                l = arguments.length;
              u !== l;
              ++u
            ) {
              var h = arguments[u],
                d = h.uuid,
                p = n[d];
              if (void 0 === p) {
                (p = t++), (n[d] = p), e.push(h);
                for (var f = 0, m = s; f !== m; ++f) o[f].push(new Mu(h, i[f], a[f]));
              } else if (p < r) {
                c = e[p];
                var v = --r,
                  g = e[v];
                (n[g.uuid] = p), (e[p] = g), (n[d] = v), (e[v] = h);
                for (f = 0, m = s; f !== m; ++f) {
                  var y = o[f],
                    x = y[v],
                    b = y[p];
                  (y[p] = x), void 0 === b && (b = new Mu(h, i[f], a[f])), (y[v] = b);
                }
              } else
                e[p] !== c &&
                  console.error(
                    'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.',
                  );
            }
            this.nCachedObjects_ = r;
          },
          remove: function () {
            for (
              var e = this._objects,
                t = this.nCachedObjects_,
                r = this._indicesByUUID,
                n = this._bindings,
                i = n.length,
                a = 0,
                o = arguments.length;
              a !== o;
              ++a
            ) {
              var s = arguments[a],
                c = s.uuid,
                u = r[c];
              if (void 0 !== u && u >= t) {
                var l = t++,
                  h = e[l];
                (r[h.uuid] = u), (e[u] = h), (r[c] = l), (e[l] = s);
                for (var d = 0, p = i; d !== p; ++d) {
                  var f = n[d],
                    m = f[l],
                    v = f[u];
                  (f[u] = m), (f[l] = v);
                }
              }
            }
            this.nCachedObjects_ = t;
          },
          uncache: function () {
            for (
              var e = this._objects,
                t = e.length,
                r = this.nCachedObjects_,
                n = this._indicesByUUID,
                i = this._bindings,
                a = i.length,
                o = 0,
                s = arguments.length;
              o !== s;
              ++o
            ) {
              var c = arguments[o].uuid,
                u = n[c];
              if (void 0 !== u)
                if ((delete n[c], u < r)) {
                  var l = --r,
                    h = e[l],
                    d = e[(g = --t)];
                  (n[h.uuid] = u), (e[u] = h), (n[d.uuid] = l), (e[l] = d), e.pop();
                  for (var p = 0, f = a; p !== f; ++p) {
                    var m = (y = i[p])[l],
                      v = y[g];
                    (y[u] = m), (y[l] = v), y.pop();
                  }
                } else {
                  var g;
                  (n[(d = e[(g = --t)]).uuid] = u), (e[u] = d), e.pop();
                  for (p = 0, f = a; p !== f; ++p) {
                    var y;
                    ((y = i[p])[u] = y[g]), y.pop();
                  }
                }
            }
            this.nCachedObjects_ = r;
          },
          subscribe_: function (e, t) {
            var r = this._bindingsIndicesByPath,
              n = r[e],
              i = this._bindings;
            if (void 0 !== n) return i[n];
            var a = this._paths,
              o = this._parsedPaths,
              s = this._objects,
              c = s.length,
              u = this.nCachedObjects_,
              l = new Array(c);
            (n = i.length), (r[e] = n), a.push(e), o.push(t), i.push(l);
            for (var h = u, d = s.length; h !== d; ++h) {
              var p = s[h];
              l[h] = new Mu(p, e, t);
            }
            return l;
          },
          unsubscribe_: function (e) {
            var t = this._bindingsIndicesByPath,
              r = t[e];
            if (void 0 !== r) {
              var n = this._paths,
                i = this._parsedPaths,
                a = this._bindings,
                o = a.length - 1,
                s = a[o];
              (t[e[o]] = r), (a[r] = s), a.pop(), (i[r] = i[o]), i.pop(), (n[r] = n[o]), n.pop();
            }
          },
        }),
        Object.assign(Eu.prototype, {
          play: function () {
            return this._mixer._activateAction(this), this;
          },
          stop: function () {
            return this._mixer._deactivateAction(this), this.reset();
          },
          reset: function () {
            return (
              (this.paused = !1),
              (this.enabled = !0),
              (this.time = 0),
              (this._loopCount = -1),
              (this._startTime = null),
              this.stopFading().stopWarping()
            );
          },
          isRunning: function () {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            );
          },
          isScheduled: function () {
            return this._mixer._isActiveAction(this);
          },
          startAt: function (e) {
            return (this._startTime = e), this;
          },
          setLoop: function (e, t) {
            return (this.loop = e), (this.repetitions = t), this;
          },
          setEffectiveWeight: function (e) {
            return (
              (this.weight = e), (this._effectiveWeight = this.enabled ? e : 0), this.stopFading()
            );
          },
          getEffectiveWeight: function () {
            return this._effectiveWeight;
          },
          fadeIn: function (e) {
            return this._scheduleFading(e, 0, 1);
          },
          fadeOut: function (e) {
            return this._scheduleFading(e, 1, 0);
          },
          crossFadeFrom: function (e, t, r) {
            if ((e.fadeOut(t), this.fadeIn(t), r)) {
              var n = this._clip.duration,
                i = e._clip.duration,
                a = i / n,
                o = n / i;
              e.warp(1, a, t), this.warp(o, 1, t);
            }
            return this;
          },
          crossFadeTo: function (e, t, r) {
            return e.crossFadeFrom(this, t, r);
          },
          stopFading: function () {
            var e = this._weightInterpolant;
            return (
              null !== e &&
                ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(e)),
              this
            );
          },
          setEffectiveTimeScale: function (e) {
            return (
              (this.timeScale = e),
              (this._effectiveTimeScale = this.paused ? 0 : e),
              this.stopWarping()
            );
          },
          getEffectiveTimeScale: function () {
            return this._effectiveTimeScale;
          },
          setDuration: function (e) {
            return (this.timeScale = this._clip.duration / e), this.stopWarping();
          },
          syncWith: function (e) {
            return (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping();
          },
          halt: function (e) {
            return this.warp(this._effectiveTimeScale, 0, e);
          },
          warp: function (e, t, r) {
            var n = this._mixer,
              i = n.time,
              a = this._timeScaleInterpolant,
              o = this.timeScale;
            null === a && ((a = n._lendControlInterpolant()), (this._timeScaleInterpolant = a));
            var s = a.parameterPositions,
              c = a.sampleValues;
            return (s[0] = i), (s[1] = i + r), (c[0] = e / o), (c[1] = t / o), this;
          },
          stopWarping: function () {
            var e = this._timeScaleInterpolant;
            return (
              null !== e &&
                ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(e)),
              this
            );
          },
          getMixer: function () {
            return this._mixer;
          },
          getClip: function () {
            return this._clip;
          },
          getRoot: function () {
            return this._localRoot || this._mixer._root;
          },
          _update: function (e, t, r, n) {
            if (this.enabled) {
              var i = this._startTime;
              if (null !== i) {
                var a = (e - i) * r;
                if (a < 0 || 0 === r) return;
                (this._startTime = null), (t = r * a);
              }
              t *= this._updateTimeScale(e);
              var o = this._updateTime(t),
                s = this._updateWeight(e);
              if (s > 0)
                for (
                  var c = this._interpolants, u = this._propertyBindings, l = 0, h = c.length;
                  l !== h;
                  ++l
                )
                  c[l].evaluate(o), u[l].accumulate(n, s);
            } else this._updateWeight(e);
          },
          _updateWeight: function (e) {
            var t = 0;
            if (this.enabled) {
              t = this.weight;
              var r = this._weightInterpolant;
              if (null !== r) {
                var n = r.evaluate(e)[0];
                (t *= n),
                  e > r.parameterPositions[1] &&
                    (this.stopFading(), 0 === n && (this.enabled = !1));
              }
            }
            return (this._effectiveWeight = t), t;
          },
          _updateTimeScale: function (e) {
            var t = 0;
            if (!this.paused) {
              t = this.timeScale;
              var r = this._timeScaleInterpolant;
              if (null !== r)
                (t *= r.evaluate(e)[0]),
                  e > r.parameterPositions[1] &&
                    (this.stopWarping(), 0 === t ? (this.paused = !0) : (this.timeScale = t));
            }
            return (this._effectiveTimeScale = t), t;
          },
          _updateTime: function (e) {
            var t = this.time + e,
              r = this._clip.duration,
              n = this.loop,
              i = this._loopCount,
              a = n === Rt;
            if (0 === e) return -1 === i ? t : a && 1 == (1 & i) ? r - t : t;
            if (n === At) {
              -1 === i && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
              e: {
                if (t >= r) t = r;
                else {
                  if (!(t < 0)) break e;
                  t = 0;
                }
                this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                  this._mixer.dispatchEvent({
                    type: 'finished',
                    action: this,
                    direction: e < 0 ? -1 : 1,
                  });
              }
            } else {
              if (
                (-1 === i &&
                  (e >= 0
                    ? ((i = 0), this._setEndings(!0, 0 === this.repetitions, a))
                    : this._setEndings(0 === this.repetitions, !0, a)),
                t >= r || t < 0)
              ) {
                var o = Math.floor(t / r);
                (t -= r * o), (i += Math.abs(o));
                var s = this.repetitions - i;
                if (s <= 0)
                  this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                    (t = e > 0 ? r : 0),
                    this._mixer.dispatchEvent({
                      type: 'finished',
                      action: this,
                      direction: e > 0 ? 1 : -1,
                    });
                else {
                  if (1 === s) {
                    var c = e < 0;
                    this._setEndings(c, !c, a);
                  } else this._setEndings(!1, !1, a);
                  (this._loopCount = i),
                    this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: o });
                }
              }
              if (a && 1 == (1 & i)) return (this.time = t), r - t;
            }
            return (this.time = t), t;
          },
          _setEndings: function (e, t, r) {
            var n = this._interpolantSettings;
            r
              ? ((n.endingStart = Dt), (n.endingEnd = Dt))
              : ((n.endingStart = e ? (this.zeroSlopeAtStart ? Dt : It) : Bt),
                (n.endingEnd = t ? (this.zeroSlopeAtEnd ? Dt : It) : Bt));
          },
          _scheduleFading: function (e, t, r) {
            var n = this._mixer,
              i = n.time,
              a = this._weightInterpolant;
            null === a && ((a = n._lendControlInterpolant()), (this._weightInterpolant = a));
            var o = a.parameterPositions,
              s = a.sampleValues;
            return (o[0] = i), (s[0] = t), (o[1] = i + e), (s[1] = r), this;
          },
        }),
        (Tu.prototype = Object.assign(Object.create(n.prototype), {
          constructor: Tu,
          _bindAction: function (e, t) {
            var r = e._localRoot || this._root,
              n = e._clip.tracks,
              i = n.length,
              a = e._propertyBindings,
              o = e._interpolants,
              s = r.uuid,
              c = this._bindingsByRootAndName,
              u = c[s];
            void 0 === u && ((u = {}), (c[s] = u));
            for (var l = 0; l !== i; ++l) {
              var h = n[l],
                d = h.name,
                p = u[d];
              if (void 0 !== p) a[l] = p;
              else {
                if (void 0 !== (p = a[l])) {
                  null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                  continue;
                }
                var f = t && t._propertyBindings[l].binding.parsedPath;
                ++(p = new ou(Mu.create(r, d, f), h.ValueTypeName, h.getValueSize()))
                  .referenceCount,
                  this._addInactiveBinding(p, s, d),
                  (a[l] = p);
              }
              o[l].resultBuffer = p.buffer;
            }
          },
          _activateAction: function (e) {
            if (!this._isActiveAction(e)) {
              if (null === e._cacheIndex) {
                var t = (e._localRoot || this._root).uuid,
                  r = e._clip.uuid,
                  n = this._actionsByClip[r];
                this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, r, t);
              }
              for (var i = e._propertyBindings, a = 0, o = i.length; a !== o; ++a) {
                var s = i[a];
                0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState());
              }
              this._lendAction(e);
            }
          },
          _deactivateAction: function (e) {
            if (this._isActiveAction(e)) {
              for (var t = e._propertyBindings, r = 0, n = t.length; r !== n; ++r) {
                var i = t[r];
                0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i));
              }
              this._takeBackAction(e);
            }
          },
          _initMemoryManager: function () {
            (this._actions = []),
              (this._nActiveActions = 0),
              (this._actionsByClip = {}),
              (this._bindings = []),
              (this._nActiveBindings = 0),
              (this._bindingsByRootAndName = {}),
              (this._controlInterpolants = []),
              (this._nActiveControlInterpolants = 0);
            var e = this;
            this.stats = {
              actions: {
                get total() {
                  return e._actions.length;
                },
                get inUse() {
                  return e._nActiveActions;
                },
              },
              bindings: {
                get total() {
                  return e._bindings.length;
                },
                get inUse() {
                  return e._nActiveBindings;
                },
              },
              controlInterpolants: {
                get total() {
                  return e._controlInterpolants.length;
                },
                get inUse() {
                  return e._nActiveControlInterpolants;
                },
              },
            };
          },
          _isActiveAction: function (e) {
            var t = e._cacheIndex;
            return null !== t && t < this._nActiveActions;
          },
          _addInactiveAction: function (e, t, r) {
            var n = this._actions,
              i = this._actionsByClip,
              a = i[t];
            if (void 0 === a)
              (a = { knownActions: [e], actionByRoot: {} }), (e._byClipCacheIndex = 0), (i[t] = a);
            else {
              var o = a.knownActions;
              (e._byClipCacheIndex = o.length), o.push(e);
            }
            (e._cacheIndex = n.length), n.push(e), (a.actionByRoot[r] = e);
          },
          _removeInactiveAction: function (e) {
            var t = this._actions,
              r = t[t.length - 1],
              n = e._cacheIndex;
            (r._cacheIndex = n), (t[n] = r), t.pop(), (e._cacheIndex = null);
            var i = e._clip.uuid,
              a = this._actionsByClip,
              o = a[i],
              s = o.knownActions,
              c = s[s.length - 1],
              u = e._byClipCacheIndex;
            (c._byClipCacheIndex = u),
              (s[u] = c),
              s.pop(),
              (e._byClipCacheIndex = null),
              delete o.actionByRoot[(e._localRoot || this._root).uuid],
              0 === s.length && delete a[i],
              this._removeInactiveBindingsForAction(e);
          },
          _removeInactiveBindingsForAction: function (e) {
            for (var t = e._propertyBindings, r = 0, n = t.length; r !== n; ++r) {
              var i = t[r];
              0 == --i.referenceCount && this._removeInactiveBinding(i);
            }
          },
          _lendAction: function (e) {
            var t = this._actions,
              r = e._cacheIndex,
              n = this._nActiveActions++,
              i = t[n];
            (e._cacheIndex = n), (t[n] = e), (i._cacheIndex = r), (t[r] = i);
          },
          _takeBackAction: function (e) {
            var t = this._actions,
              r = e._cacheIndex,
              n = --this._nActiveActions,
              i = t[n];
            (e._cacheIndex = n), (t[n] = e), (i._cacheIndex = r), (t[r] = i);
          },
          _addInactiveBinding: function (e, t, r) {
            var n = this._bindingsByRootAndName,
              i = n[t],
              a = this._bindings;
            void 0 === i && ((i = {}), (n[t] = i)),
              (i[r] = e),
              (e._cacheIndex = a.length),
              a.push(e);
          },
          _removeInactiveBinding: function (e) {
            var t = this._bindings,
              r = e.binding,
              n = r.rootNode.uuid,
              i = r.path,
              a = this._bindingsByRootAndName,
              o = a[n],
              s = t[t.length - 1],
              c = e._cacheIndex;
            (s._cacheIndex = c), (t[c] = s), t.pop(), delete o[i];
            e: {
              for (var u in o) break e;
              delete a[n];
            }
          },
          _lendBinding: function (e) {
            var t = this._bindings,
              r = e._cacheIndex,
              n = this._nActiveBindings++,
              i = t[n];
            (e._cacheIndex = n), (t[n] = e), (i._cacheIndex = r), (t[r] = i);
          },
          _takeBackBinding: function (e) {
            var t = this._bindings,
              r = e._cacheIndex,
              n = --this._nActiveBindings,
              i = t[n];
            (e._cacheIndex = n), (t[n] = e), (i._cacheIndex = r), (t[r] = i);
          },
          _lendControlInterpolant: function () {
            var e = this._controlInterpolants,
              t = this._nActiveControlInterpolants++,
              r = e[t];
            return (
              void 0 === r &&
                (((r = new xs(
                  new Float32Array(2),
                  new Float32Array(2),
                  1,
                  this._controlInterpolantsResultBuffer,
                )).__cacheIndex = t),
                (e[t] = r)),
              r
            );
          },
          _takeBackControlInterpolant: function (e) {
            var t = this._controlInterpolants,
              r = e.__cacheIndex,
              n = --this._nActiveControlInterpolants,
              i = t[n];
            (e.__cacheIndex = n), (t[n] = e), (i.__cacheIndex = r), (t[r] = i);
          },
          _controlInterpolantsResultBuffer: new Float32Array(1),
          clipAction: function (e, t) {
            var r = t || this._root,
              n = r.uuid,
              i = 'string' == typeof e ? Rs.findByName(r, e) : e,
              a = null !== i ? i.uuid : e,
              o = this._actionsByClip[a],
              s = null;
            if (void 0 !== o) {
              var c = o.actionByRoot[n];
              if (void 0 !== c) return c;
              (s = o.knownActions[0]), null === i && (i = s._clip);
            }
            if (null === i) return null;
            var u = new Eu(this, i, t);
            return this._bindAction(u, s), this._addInactiveAction(u, a, n), u;
          },
          existingAction: function (e, t) {
            var r = t || this._root,
              n = r.uuid,
              i = 'string' == typeof e ? Rs.findByName(r, e) : e,
              a = i ? i.uuid : e,
              o = this._actionsByClip[a];
            return (void 0 !== o && o.actionByRoot[n]) || null;
          },
          stopAllAction: function () {
            var e = this._actions,
              t = this._nActiveActions,
              r = this._bindings,
              n = this._nActiveBindings;
            (this._nActiveActions = 0), (this._nActiveBindings = 0);
            for (var i = 0; i !== t; ++i) e[i].reset();
            for (i = 0; i !== n; ++i) r[i].useCount = 0;
            return this;
          },
          update: function (e) {
            e *= this.timeScale;
            for (
              var t = this._actions,
                r = this._nActiveActions,
                n = (this.time += e),
                i = Math.sign(e),
                a = (this._accuIndex ^= 1),
                o = 0;
              o !== r;
              ++o
            ) {
              t[o]._update(n, e, i, a);
            }
            var s = this._bindings,
              c = this._nActiveBindings;
            for (o = 0; o !== c; ++o) s[o].apply(a);
            return this;
          },
          getRoot: function () {
            return this._root;
          },
          uncacheClip: function (e) {
            var t = this._actions,
              r = e.uuid,
              n = this._actionsByClip,
              i = n[r];
            if (void 0 !== i) {
              for (var a = i.knownActions, o = 0, s = a.length; o !== s; ++o) {
                var c = a[o];
                this._deactivateAction(c);
                var u = c._cacheIndex,
                  l = t[t.length - 1];
                (c._cacheIndex = null),
                  (c._byClipCacheIndex = null),
                  (l._cacheIndex = u),
                  (t[u] = l),
                  t.pop(),
                  this._removeInactiveBindingsForAction(c);
              }
              delete n[r];
            }
          },
          uncacheRoot: function (e) {
            var t = e.uuid,
              r = this._actionsByClip;
            for (var n in r) {
              var i = r[n].actionByRoot[t];
              void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
            }
            var a = this._bindingsByRootAndName[t];
            if (void 0 !== a)
              for (var o in a) {
                var s = a[o];
                s.restoreOriginalState(), this._removeInactiveBinding(s);
              }
          },
          uncacheAction: function (e, t) {
            var r = this.existingAction(e, t);
            null !== r && (this._deactivateAction(r), this._removeInactiveAction(r));
          },
        })),
        (Au.prototype.clone = function () {
          return new Au(void 0 === this.value.clone ? this.value : this.value.clone());
        }),
        (Lu.prototype = Object.assign(Object.create(sn.prototype), {
          constructor: Lu,
          isInstancedBufferGeometry: !0,
          copy: function (e) {
            return (
              sn.prototype.copy.call(this, e), (this.maxInstancedCount = e.maxInstancedCount), this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
        })),
        (Ru.prototype = Object.assign(Object.create(Aa.prototype), {
          constructor: Ru,
          isInstancedInterleavedBuffer: !0,
          copy: function (e) {
            return (
              Aa.prototype.copy.call(this, e), (this.meshPerAttribute = e.meshPerAttribute), this
            );
          },
        })),
        (Cu.prototype = Object.assign(Object.create(Xr.prototype), {
          constructor: Cu,
          isInstancedBufferAttribute: !0,
          copy: function (e) {
            return (
              Xr.prototype.copy.call(this, e), (this.meshPerAttribute = e.meshPerAttribute), this
            );
          },
        })),
        Object.assign(Pu.prototype, {
          linePrecision: 1,
          set: function (e, t) {
            this.ray.set(e, t);
          },
          setFromCamera: function (e, t) {
            t && t.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize())
              : t && t.isOrthographicCamera
              ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld))
              : console.error('THREE.Raycaster: Unsupported camera type.');
          },
          intersectObject: function (e, t, r) {
            var n = r || [];
            return Iu(e, this, n, t), n.sort(Ou), n;
          },
          intersectObjects: function (e, t, r) {
            var n = r || [];
            if (!1 === Array.isArray(e))
              return console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.'), n;
            for (var i = 0, a = e.length; i < a; i++) Iu(e[i], this, n, t);
            return n.sort(Ou), n;
          },
        }),
        Object.assign(Du.prototype, {
          set: function (e, t, r) {
            return (this.radius = e), (this.phi = t), (this.theta = r), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this;
          },
          makeSafe: function () {
            return (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this;
          },
          setFromVector3: function (e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z);
          },
          setFromCartesianCoords: function (e, t, r) {
            return (
              (this.radius = Math.sqrt(e * e + t * t + r * r)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(e, r)),
                  (this.phi = Math.acos(Kt.clamp(t / this.radius, -1, 1)))),
              this
            );
          },
        }),
        Object.assign(Bu.prototype, {
          set: function (e, t, r) {
            return (this.radius = e), (this.theta = t), (this.y = r), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this;
          },
          setFromVector3: function (e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z);
          },
          setFromCartesianCoords: function (e, t, r) {
            return (
              (this.radius = Math.sqrt(e * e + r * r)),
              (this.theta = Math.atan2(e, r)),
              (this.y = t),
              this
            );
          },
        }),
        Object.assign(Nu.prototype, {
          set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this;
          },
          setFromPoints: function (e) {
            this.makeEmpty();
            for (var t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
            return this;
          },
          setFromCenterAndSize: (function () {
            var e = new Qt();
            return function (t, r) {
              var n = e.copy(r).multiplyScalar(0.5);
              return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
            };
          })(),
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this;
          },
          makeEmpty: function () {
            return (this.min.x = this.min.y = 1 / 0), (this.max.x = this.max.y = -1 / 0), this;
          },
          isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y;
          },
          getCenter: function (e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Box2: .getCenter() target is now required'), (e = new Qt())),
              this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5)
            );
          },
          getSize: function (e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Box2: .getSize() target is now required'), (e = new Qt())),
              this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
            );
          },
          expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this;
          },
          expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this;
          },
          expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this;
          },
          containsPoint: function (e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
          },
          containsBox: function (e) {
            return (
              this.min.x <= e.min.x &&
              e.max.x <= this.max.x &&
              this.min.y <= e.min.y &&
              e.max.y <= this.max.y
            );
          },
          getParameter: function (e, t) {
            return (
              void 0 === t &&
                (console.warn('THREE.Box2: .getParameter() target is now required'),
                (t = new Qt())),
              t.set(
                (e.x - this.min.x) / (this.max.x - this.min.x),
                (e.y - this.min.y) / (this.max.y - this.min.y),
              )
            );
          },
          intersectsBox: function (e) {
            return !(
              e.max.x < this.min.x ||
              e.min.x > this.max.x ||
              e.max.y < this.min.y ||
              e.min.y > this.max.y
            );
          },
          clampPoint: function (e, t) {
            return (
              void 0 === t &&
                (console.warn('THREE.Box2: .clampPoint() target is now required'), (t = new Qt())),
              t.copy(e).clamp(this.min, this.max)
            );
          },
          distanceToPoint: (function () {
            var e = new Qt();
            return function (t) {
              return e.copy(t).clamp(this.min, this.max).sub(t).length();
            };
          })(),
          intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this;
          },
          union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this;
          },
          translate: function (e) {
            return this.min.add(e), this.max.add(e), this;
          },
          equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max);
          },
        }),
        Object.assign(Uu.prototype, {
          set: function (e, t) {
            return this.start.copy(e), this.end.copy(t), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return this.start.copy(e.start), this.end.copy(e.end), this;
          },
          getCenter: function (e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Line3: .getCenter() target is now required'), (e = new tr())),
              e.addVectors(this.start, this.end).multiplyScalar(0.5)
            );
          },
          delta: function (e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Line3: .delta() target is now required'), (e = new tr())),
              e.subVectors(this.end, this.start)
            );
          },
          distanceSq: function () {
            return this.start.distanceToSquared(this.end);
          },
          distance: function () {
            return this.start.distanceTo(this.end);
          },
          at: function (e, t) {
            return (
              void 0 === t &&
                (console.warn('THREE.Line3: .at() target is now required'), (t = new tr())),
              this.delta(t).multiplyScalar(e).add(this.start)
            );
          },
          closestPointToPointParameter:
            ((vu = new tr()),
            (gu = new tr()),
            function (e, t) {
              vu.subVectors(e, this.start), gu.subVectors(this.end, this.start);
              var r = gu.dot(gu),
                n = gu.dot(vu) / r;
              return t && (n = Kt.clamp(n, 0, 1)), n;
            }),
          closestPointToPoint: function (e, t, r) {
            var n = this.closestPointToPointParameter(e, t);
            return (
              void 0 === r &&
                (console.warn('THREE.Line3: .closestPointToPoint() target is now required'),
                (r = new tr())),
              this.delta(r).multiplyScalar(n).add(this.start)
            );
          },
          applyMatrix4: function (e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
          },
          equals: function (e) {
            return e.start.equals(this.start) && e.end.equals(this.end);
          },
        }),
        (Gu.prototype = Object.create(kr.prototype)),
        (Gu.prototype.constructor = Gu),
        (Gu.prototype.isImmediateRenderObject = !0),
        (Fu.prototype = Object.create(Ua.prototype)),
        (Fu.prototype.constructor = Fu),
        (Fu.prototype.update = (function () {
          var e = new tr(),
            t = new tr(),
            r = new rr();
          return function () {
            var n = ['a', 'b', 'c'];
            this.object.updateMatrixWorld(!0), r.getNormalMatrix(this.object.matrixWorld);
            var i = this.object.matrixWorld,
              a = this.geometry.attributes.position,
              o = this.object.geometry;
            if (o && o.isGeometry)
              for (var s = o.vertices, c = o.faces, u = 0, l = 0, h = c.length; l < h; l++)
                for (var d = c[l], p = 0, f = d.vertexNormals.length; p < f; p++) {
                  var m = s[d[n[p]]],
                    v = d.vertexNormals[p];
                  e.copy(m).applyMatrix4(i),
                    t.copy(v).applyMatrix3(r).normalize().multiplyScalar(this.size).add(e),
                    a.setXYZ(u, e.x, e.y, e.z),
                    (u += 1),
                    a.setXYZ(u, t.x, t.y, t.z),
                    (u += 1);
                }
            else if (o && o.isBufferGeometry) {
              var g = o.attributes.position,
                y = o.attributes.normal;
              for (u = 0, p = 0, f = g.count; p < f; p++)
                e.set(g.getX(p), g.getY(p), g.getZ(p)).applyMatrix4(i),
                  t.set(y.getX(p), y.getY(p), y.getZ(p)),
                  t.applyMatrix3(r).normalize().multiplyScalar(this.size).add(e),
                  a.setXYZ(u, e.x, e.y, e.z),
                  (u += 1),
                  a.setXYZ(u, t.x, t.y, t.z),
                  (u += 1);
            }
            a.needsUpdate = !0;
          };
        })()),
        (zu.prototype = Object.create(kr.prototype)),
        (zu.prototype.constructor = zu),
        (zu.prototype.dispose = function () {
          this.cone.geometry.dispose(), this.cone.material.dispose();
        }),
        (zu.prototype.update = (function () {
          var e = new tr();
          return function () {
            this.light.updateMatrixWorld();
            var t = this.light.distance ? this.light.distance : 1e3,
              r = t * Math.tan(this.light.angle);
            this.cone.scale.set(r, r, t),
              e.setFromMatrixPosition(this.light.target.matrixWorld),
              this.cone.lookAt(e),
              void 0 !== this.color
                ? this.cone.material.color.set(this.color)
                : this.cone.material.color.copy(this.light.color);
          };
        })()),
        (Hu.prototype = Object.create(Ua.prototype)),
        (Hu.prototype.constructor = Hu),
        (Hu.prototype.updateMatrixWorld = (function () {
          var e = new tr(),
            t = new $t(),
            r = new $t();
          return function (n) {
            var i = this.bones,
              a = this.geometry,
              o = a.getAttribute('position');
            r.getInverse(this.root.matrixWorld);
            for (var s = 0, c = 0; s < i.length; s++) {
              var u = i[s];
              u.parent &&
                u.parent.isBone &&
                (t.multiplyMatrices(r, u.matrixWorld),
                e.setFromMatrixPosition(t),
                o.setXYZ(c, e.x, e.y, e.z),
                t.multiplyMatrices(r, u.parent.matrixWorld),
                e.setFromMatrixPosition(t),
                o.setXYZ(c + 1, e.x, e.y, e.z),
                (c += 2));
            }
            (a.getAttribute('position').needsUpdate = !0),
              kr.prototype.updateMatrixWorld.call(this, n);
          };
        })()),
        (ku.prototype = Object.create(Cn.prototype)),
        (ku.prototype.constructor = ku),
        (ku.prototype.dispose = function () {
          this.geometry.dispose(), this.material.dispose();
        }),
        (ku.prototype.update = function () {
          void 0 !== this.color
            ? this.material.color.set(this.color)
            : this.material.color.copy(this.light.color);
        }),
        (Vu.prototype = Object.create(Na.prototype)),
        (Vu.prototype.constructor = Vu),
        (Vu.prototype.update = function () {
          if (
            (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1),
            void 0 !== this.color)
          )
            this.material.color.set(this.color), this.children[0].material.color.set(this.color);
          else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var e = this.material.color,
              t = Math.max(e.r, e.g, e.b);
            t > 1 && e.multiplyScalar(1 / t),
              this.children[0].material.color.copy(this.material.color);
          }
        }),
        (Vu.prototype.dispose = function () {
          this.geometry.dispose(),
            this.material.dispose(),
            this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
        }),
        (ju.prototype = Object.create(kr.prototype)),
        (ju.prototype.constructor = ju),
        (ju.prototype.dispose = function () {
          this.children[0].geometry.dispose(), this.children[0].material.dispose();
        }),
        (ju.prototype.update = (function () {
          var e = new tr(),
            t = new Lr(),
            r = new Lr();
          return function () {
            var n = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
              var i = n.geometry.getAttribute('color');
              t.copy(this.light.color), r.copy(this.light.groundColor);
              for (var a = 0, o = i.count; a < o; a++) {
                var s = a < o / 2 ? t : r;
                i.setXYZ(a, s.r, s.g, s.b);
              }
              i.needsUpdate = !0;
            }
            n.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate());
          };
        })()),
        (Wu.prototype = Object.create(Ua.prototype)),
        (Wu.prototype.constructor = Wu),
        (qu.prototype = Object.create(Ua.prototype)),
        (qu.prototype.constructor = qu),
        (Xu.prototype = Object.create(Ua.prototype)),
        (Xu.prototype.constructor = Xu),
        (Xu.prototype.update = (function () {
          var e = new tr(),
            t = new tr(),
            r = new rr();
          return function () {
            this.object.updateMatrixWorld(!0), r.getNormalMatrix(this.object.matrixWorld);
            for (
              var n = this.object.matrixWorld,
                i = this.geometry.attributes.position,
                a = this.object.geometry,
                o = a.vertices,
                s = a.faces,
                c = 0,
                u = 0,
                l = s.length;
              u < l;
              u++
            ) {
              var h = s[u],
                d = h.normal;
              e.copy(o[h.a]).add(o[h.b]).add(o[h.c]).divideScalar(3).applyMatrix4(n),
                t.copy(d).applyMatrix3(r).normalize().multiplyScalar(this.size).add(e),
                i.setXYZ(c, e.x, e.y, e.z),
                (c += 1),
                i.setXYZ(c, t.x, t.y, t.z),
                (c += 1);
            }
            i.needsUpdate = !0;
          };
        })()),
        (Yu.prototype = Object.create(kr.prototype)),
        (Yu.prototype.constructor = Yu),
        (Yu.prototype.dispose = function () {
          this.lightPlane.geometry.dispose(),
            this.lightPlane.material.dispose(),
            this.targetLine.geometry.dispose(),
            this.targetLine.material.dispose();
        }),
        (Yu.prototype.update = (function () {
          var e = new tr(),
            t = new tr(),
            r = new tr();
          return function () {
            e.setFromMatrixPosition(this.light.matrixWorld),
              t.setFromMatrixPosition(this.light.target.matrixWorld),
              r.subVectors(t, e),
              this.lightPlane.lookAt(t),
              void 0 !== this.color
                ? (this.lightPlane.material.color.set(this.color),
                  this.targetLine.material.color.set(this.color))
                : (this.lightPlane.material.color.copy(this.light.color),
                  this.targetLine.material.color.copy(this.light.color)),
              this.targetLine.lookAt(t),
              (this.targetLine.scale.z = r.length());
          };
        })()),
        (Ju.prototype = Object.create(Ua.prototype)),
        (Ju.prototype.constructor = Ju),
        (Ju.prototype.update = (function () {
          var e,
            t,
            r = new tr(),
            n = new ua();
          function i(i, a, o, s) {
            r.set(a, o, s).unproject(n);
            var c = t[i];
            if (void 0 !== c)
              for (var u = e.getAttribute('position'), l = 0, h = c.length; l < h; l++)
                u.setXYZ(c[l], r.x, r.y, r.z);
          }
          return function () {
            (e = this.geometry), (t = this.pointMap);
            n.projectionMatrix.copy(this.camera.projectionMatrix),
              i('c', 0, 0, -1),
              i('t', 0, 0, 1),
              i('n1', -1, -1, -1),
              i('n2', 1, -1, -1),
              i('n3', -1, 1, -1),
              i('n4', 1, 1, -1),
              i('f1', -1, -1, 1),
              i('f2', 1, -1, 1),
              i('f3', -1, 1, 1),
              i('f4', 1, 1, 1),
              i('u1', 0.7, 1.1, -1),
              i('u2', -0.7, 1.1, -1),
              i('u3', 0, 2, -1),
              i('cf1', -1, 0, 1),
              i('cf2', 1, 0, 1),
              i('cf3', 0, -1, 1),
              i('cf4', 0, 1, 1),
              i('cn1', -1, 0, -1),
              i('cn2', 1, 0, -1),
              i('cn3', 0, -1, -1),
              i('cn4', 0, 1, -1),
              (e.getAttribute('position').needsUpdate = !0);
          };
        })()),
        (Zu.prototype = Object.create(Ua.prototype)),
        (Zu.prototype.constructor = Zu),
        (Zu.prototype.update = (function () {
          var e = new vr();
          return function (t) {
            if (
              (void 0 !== t && console.warn('THREE.BoxHelper: .update() has no longer arguments.'),
              void 0 !== this.object && e.setFromObject(this.object),
              !e.isEmpty())
            ) {
              var r = e.min,
                n = e.max,
                i = this.geometry.attributes.position,
                a = i.array;
              (a[0] = n.x),
                (a[1] = n.y),
                (a[2] = n.z),
                (a[3] = r.x),
                (a[4] = n.y),
                (a[5] = n.z),
                (a[6] = r.x),
                (a[7] = r.y),
                (a[8] = n.z),
                (a[9] = n.x),
                (a[10] = r.y),
                (a[11] = n.z),
                (a[12] = n.x),
                (a[13] = n.y),
                (a[14] = r.z),
                (a[15] = r.x),
                (a[16] = n.y),
                (a[17] = r.z),
                (a[18] = r.x),
                (a[19] = r.y),
                (a[20] = r.z),
                (a[21] = n.x),
                (a[22] = r.y),
                (a[23] = r.z),
                (i.needsUpdate = !0),
                this.geometry.computeBoundingSphere();
            }
          };
        })()),
        (Zu.prototype.setFromObject = function (e) {
          return (this.object = e), this.update(), this;
        }),
        (Zu.prototype.copy = function (e) {
          return Ua.prototype.copy.call(this, e), (this.object = e.object), this;
        }),
        (Zu.prototype.clone = function () {
          return new this.constructor().copy(this);
        }),
        (Ku.prototype = Object.create(Ua.prototype)),
        (Ku.prototype.constructor = Ku),
        (Ku.prototype.updateMatrixWorld = function (e) {
          var t = this.box;
          t.isEmpty() ||
            (t.getCenter(this.position),
            t.getSize(this.scale),
            this.scale.multiplyScalar(0.5),
            kr.prototype.updateMatrixWorld.call(this, e));
        }),
        (Qu.prototype = Object.create(Na.prototype)),
        (Qu.prototype.constructor = Qu),
        (Qu.prototype.updateMatrixWorld = function (e) {
          var t = -this.plane.constant;
          Math.abs(t) < 1e-8 && (t = 1e-8),
            this.scale.set(0.5 * this.size, 0.5 * this.size, t),
            (this.children[0].material.side = t < 0 ? L : A),
            this.lookAt(this.plane.normal),
            kr.prototype.updateMatrixWorld.call(this, e);
        }),
        ($u.prototype = Object.create(kr.prototype)),
        ($u.prototype.constructor = $u),
        ($u.prototype.setDirection =
          ((wu = new tr()),
          function (e) {
            e.y > 0.99999
              ? this.quaternion.set(0, 0, 0, 1)
              : e.y < -0.99999
              ? this.quaternion.set(1, 0, 0, 0)
              : (wu.set(e.z, 0, -e.x).normalize(),
                (bu = Math.acos(e.y)),
                this.quaternion.setFromAxisAngle(wu, bu));
          })),
        ($u.prototype.setLength = function (e, t, r) {
          void 0 === t && (t = 0.2 * e),
            void 0 === r && (r = 0.2 * t),
            this.line.scale.set(1, Math.max(0, e - t), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(r, t, r),
            (this.cone.position.y = e),
            this.cone.updateMatrix();
        }),
        ($u.prototype.setColor = function (e) {
          this.line.material.color.copy(e), this.cone.material.color.copy(e);
        }),
        ($u.prototype.copy = function (e) {
          return (
            kr.prototype.copy.call(this, e, !1),
            this.line.copy(e.line),
            this.cone.copy(e.cone),
            this
          );
        }),
        ($u.prototype.clone = function () {
          return new this.constructor().copy(this);
        }),
        (el.prototype = Object.create(Ua.prototype)),
        (el.prototype.constructor = el);
      var rl = 0,
        nl = 1;
      function il(e) {
        return console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.'), e;
      }
      function al(e) {
        return (
          void 0 === e && (e = []),
          console.warn('THREE.MultiMaterial has been removed. Use an Array instead.'),
          (e.isMultiMaterial = !0),
          (e.materials = e),
          (e.clone = function () {
            return e.slice();
          }),
          e
        );
      }
      function ol(e, t) {
        return console.warn('THREE.PointCloud has been renamed to THREE.Points.'), new za(e, t);
      }
      function sl(e) {
        return console.warn('THREE.Particle has been renamed to THREE.Sprite.'), new Ca(e);
      }
      function cl(e, t) {
        return console.warn('THREE.ParticleSystem has been renamed to THREE.Points.'), new za(e, t);
      }
      function ul(e) {
        return (
          console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.'),
          new Fa(e)
        );
      }
      function ll(e) {
        return (
          console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.'),
          new Fa(e)
        );
      }
      function hl(e) {
        return (
          console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.'),
          new Fa(e)
        );
      }
      function dl(e, t, r) {
        return (
          console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.'), new tr(e, t, r)
        );
      }
      function pl(e, t) {
        return (
          console.warn(
            'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.',
          ),
          new Xr(e, t).setDynamic(!0)
        );
      }
      function fl(e, t) {
        return (
          console.warn(
            'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.',
          ),
          new Yr(e, t)
        );
      }
      function ml(e, t) {
        return (
          console.warn(
            'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.',
          ),
          new Jr(e, t)
        );
      }
      function vl(e, t) {
        return (
          console.warn(
            'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.',
          ),
          new Zr(e, t)
        );
      }
      function gl(e, t) {
        return (
          console.warn(
            'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.',
          ),
          new Kr(e, t)
        );
      }
      function yl(e, t) {
        return (
          console.warn(
            'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.',
          ),
          new Qr(e, t)
        );
      }
      function xl(e, t) {
        return (
          console.warn(
            'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.',
          ),
          new $r(e, t)
        );
      }
      function bl(e, t) {
        return (
          console.warn(
            'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.',
          ),
          new en(e, t)
        );
      }
      function wl(e, t) {
        return (
          console.warn(
            'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.',
          ),
          new tn(e, t)
        );
      }
      function _l(e, t) {
        return (
          console.warn(
            'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.',
          ),
          new rn(e, t)
        );
      }
      function Ml(e) {
        console.warn(
          'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.',
        ),
          Zs.call(this, e),
          (this.type = 'catmullrom'),
          (this.closed = !0);
      }
      function Sl(e) {
        console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.'),
          Zs.call(this, e),
          (this.type = 'catmullrom');
      }
      function El(e) {
        console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.'),
          Zs.call(this, e),
          (this.type = 'catmullrom');
      }
      function Tl(e) {
        return console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.'), new el(e);
      }
      function Al(e, t) {
        return (
          console.warn(
            'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.',
          ),
          new Zu(e, t)
        );
      }
      function Ll(e, t) {
        return (
          console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.'),
          new Ua(new Ko(e.geometry), new Ba({ color: void 0 !== t ? t : 16777215 }))
        );
      }
      function Rl(e, t) {
        return (
          console.warn(
            'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.',
          ),
          new Ua(new Wa(e.geometry), new Ba({ color: void 0 !== t ? t : 16777215 }))
        );
      }
      function Cl(e) {
        return console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.'), new Bs(e);
      }
      function Pl(e) {
        return (
          console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.'),
          new Gs(e)
        );
      }
      (ks.create = function (e, t) {
        return (
          console.log('THREE.Curve.create() has been deprecated'),
          (e.prototype = Object.create(ks.prototype)),
          (e.prototype.constructor = e),
          (e.prototype.getPoint = t),
          e
        );
      }),
        Object.assign(cc.prototype, {
          createPointsGeometry: function (e) {
            console.warn(
              'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.',
            );
            var t = this.getPoints(e);
            return this.createGeometry(t);
          },
          createSpacedPointsGeometry: function (e) {
            console.warn(
              'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.',
            );
            var t = this.getSpacedPoints(e);
            return this.createGeometry(t);
          },
          createGeometry: function (e) {
            console.warn(
              'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.',
            );
            for (var t = new qr(), r = 0, n = e.length; r < n; r++) {
              var i = e[r];
              t.vertices.push(new tr(i.x, i.y, i.z || 0));
            }
            return t;
          },
        }),
        Object.assign(uc.prototype, {
          fromPoints: function (e) {
            console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().'),
              this.setFromPoints(e);
          },
        }),
        (Ml.prototype = Object.create(Zs.prototype)),
        (Sl.prototype = Object.create(Zs.prototype)),
        (El.prototype = Object.create(Zs.prototype)),
        Object.assign(El.prototype, {
          initFromArray: function () {
            console.error('THREE.Spline: .initFromArray() has been removed.');
          },
          getControlPointsArray: function () {
            console.error('THREE.Spline: .getControlPointsArray() has been removed.');
          },
          reparametrizeByArcLength: function () {
            console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
          },
        }),
        (Wu.prototype.setColors = function () {
          console.error(
            'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.',
          );
        }),
        (Hu.prototype.update = function () {
          console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
        }),
        Object.assign(zc.prototype, {
          extractUrlBase: function (e) {
            return (
              console.warn(
                'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.',
              ),
              Mc.extractUrlBase(e)
            );
          },
        }),
        Object.assign(Tc.prototype, {
          setTexturePath: function (e) {
            return (
              console.warn(
                'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().',
              ),
              this.setResourcePath(e)
            );
          },
        }),
        Object.assign(Nu.prototype, {
          center: function (e) {
            return (
              console.warn('THREE.Box2: .center() has been renamed to .getCenter().'),
              this.getCenter(e)
            );
          },
          empty: function () {
            return (
              console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().'), this.isEmpty()
            );
          },
          isIntersectionBox: function (e) {
            return (
              console.warn(
                'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().',
              ),
              this.intersectsBox(e)
            );
          },
          size: function (e) {
            return (
              console.warn('THREE.Box2: .size() has been renamed to .getSize().'), this.getSize(e)
            );
          },
        }),
        Object.assign(vr.prototype, {
          center: function (e) {
            return (
              console.warn('THREE.Box3: .center() has been renamed to .getCenter().'),
              this.getCenter(e)
            );
          },
          empty: function () {
            return (
              console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().'), this.isEmpty()
            );
          },
          isIntersectionBox: function (e) {
            return (
              console.warn(
                'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().',
              ),
              this.intersectsBox(e)
            );
          },
          isIntersectionSphere: function (e) {
            return (
              console.warn(
                'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().',
              ),
              this.intersectsSphere(e)
            );
          },
          size: function (e) {
            return (
              console.warn('THREE.Box3: .size() has been renamed to .getSize().'), this.getSize(e)
            );
          },
        }),
        (Uu.prototype.center = function (e) {
          return (
            console.warn('THREE.Line3: .center() has been renamed to .getCenter().'),
            this.getCenter(e)
          );
        }),
        Object.assign(Kt, {
          random16: function () {
            return (
              console.warn(
                'THREE.Math: .random16() has been deprecated. Use Math.random() instead.',
              ),
              Math.random()
            );
          },
          nearestPowerOfTwo: function (e) {
            return (
              console.warn(
                'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().',
              ),
              Kt.floorPowerOfTwo(e)
            );
          },
          nextPowerOfTwo: function (e) {
            return (
              console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().'),
              Kt.ceilPowerOfTwo(e)
            );
          },
        }),
        Object.assign(rr.prototype, {
          flattenToArrayOffset: function (e, t) {
            return (
              console.warn(
                'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
              ),
              this.toArray(e, t)
            );
          },
          multiplyVector3: function (e) {
            return (
              console.warn(
                'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.',
              ),
              e.applyMatrix3(this)
            );
          },
          multiplyVector3Array: function () {
            console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
          },
          applyToBuffer: function (e) {
            return (
              console.warn(
                'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.',
              ),
              this.applyToBufferAttribute(e)
            );
          },
          applyToVector3Array: function () {
            console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
          },
        }),
        Object.assign($t.prototype, {
          extractPosition: function (e) {
            return (
              console.warn(
                'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().',
              ),
              this.copyPosition(e)
            );
          },
          flattenToArrayOffset: function (e, t) {
            return (
              console.warn(
                'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
              ),
              this.toArray(e, t)
            );
          },
          getPosition: (function () {
            var e;
            return function () {
              return (
                void 0 === e && (e = new tr()),
                console.warn(
                  'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.',
                ),
                e.setFromMatrixColumn(this, 3)
              );
            };
          })(),
          setRotationFromQuaternion: function (e) {
            return (
              console.warn(
                'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().',
              ),
              this.makeRotationFromQuaternion(e)
            );
          },
          multiplyToArray: function () {
            console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
          },
          multiplyVector3: function (e) {
            return (
              console.warn(
                'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.',
              ),
              e.applyMatrix4(this)
            );
          },
          multiplyVector4: function (e) {
            return (
              console.warn(
                'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.',
              ),
              e.applyMatrix4(this)
            );
          },
          multiplyVector3Array: function () {
            console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
          },
          rotateAxis: function (e) {
            console.warn(
              'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.',
            ),
              e.transformDirection(this);
          },
          crossVector: function (e) {
            return (
              console.warn(
                'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.',
              ),
              e.applyMatrix4(this)
            );
          },
          translate: function () {
            console.error('THREE.Matrix4: .translate() has been removed.');
          },
          rotateX: function () {
            console.error('THREE.Matrix4: .rotateX() has been removed.');
          },
          rotateY: function () {
            console.error('THREE.Matrix4: .rotateY() has been removed.');
          },
          rotateZ: function () {
            console.error('THREE.Matrix4: .rotateZ() has been removed.');
          },
          rotateByAxis: function () {
            console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
          },
          applyToBuffer: function (e) {
            return (
              console.warn(
                'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.',
              ),
              this.applyToBufferAttribute(e)
            );
          },
          applyToVector3Array: function () {
            console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
          },
          makeFrustum: function (e, t, r, n, i, a) {
            return (
              console.warn(
                'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.',
              ),
              this.makePerspective(e, t, n, r, i, a)
            );
          },
        }),
        (yr.prototype.isIntersectionLine = function (e) {
          return (
            console.warn(
              'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().',
            ),
            this.intersectsLine(e)
          );
        }),
        (er.prototype.multiplyVector3 = function (e) {
          return (
            console.warn(
              'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.',
            ),
            e.applyQuaternion(this)
          );
        }),
        Object.assign(An.prototype, {
          isIntersectionBox: function (e) {
            return (
              console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().'),
              this.intersectsBox(e)
            );
          },
          isIntersectionPlane: function (e) {
            return (
              console.warn(
                'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().',
              ),
              this.intersectsPlane(e)
            );
          },
          isIntersectionSphere: function (e) {
            return (
              console.warn(
                'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().',
              ),
              this.intersectsSphere(e)
            );
          },
        }),
        Object.assign(Ln.prototype, {
          area: function () {
            return (
              console.warn('THREE.Triangle: .area() has been renamed to .getArea().'),
              this.getArea()
            );
          },
          barycoordFromPoint: function (e, t) {
            return (
              console.warn(
                'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',
              ),
              this.getBarycoord(e, t)
            );
          },
          midpoint: function (e) {
            return (
              console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().'),
              this.getMidpoint(e)
            );
          },
          normal: function (e) {
            return (
              console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().'),
              this.getNormal(e)
            );
          },
          plane: function (e) {
            return (
              console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().'),
              this.getPlane(e)
            );
          },
        }),
        Object.assign(Ln, {
          barycoordFromPoint: function (e, t, r, n, i) {
            return (
              console.warn(
                'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',
              ),
              Ln.getBarycoord(e, t, r, n, i)
            );
          },
          normal: function (e, t, r, n) {
            return (
              console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().'),
              Ln.getNormal(e, t, r, n)
            );
          },
        }),
        Object.assign(lc.prototype, {
          extractAllPoints: function (e) {
            return (
              console.warn(
                'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.',
              ),
              this.extractPoints(e)
            );
          },
          extrude: function (e) {
            return (
              console.warn(
                'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.',
              ),
              new No(this, e)
            );
          },
          makeGeometry: function (e) {
            return (
              console.warn(
                'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.',
              ),
              new Yo(this, e)
            );
          },
        }),
        Object.assign(Qt.prototype, {
          fromAttribute: function (e, t, r) {
            return (
              console.warn(
                'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().',
              ),
              this.fromBufferAttribute(e, t, r)
            );
          },
          distanceToManhattan: function (e) {
            return (
              console.warn(
                'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
              ),
              this.manhattanDistanceTo(e)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().',
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign(tr.prototype, {
          setEulerFromRotationMatrix: function () {
            console.error(
              'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.',
            );
          },
          setEulerFromQuaternion: function () {
            console.error(
              'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.',
            );
          },
          getPositionFromMatrix: function (e) {
            return (
              console.warn(
                'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().',
              ),
              this.setFromMatrixPosition(e)
            );
          },
          getScaleFromMatrix: function (e) {
            return (
              console.warn(
                'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().',
              ),
              this.setFromMatrixScale(e)
            );
          },
          getColumnFromMatrix: function (e, t) {
            return (
              console.warn(
                'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().',
              ),
              this.setFromMatrixColumn(t, e)
            );
          },
          applyProjection: function (e) {
            return (
              console.warn(
                'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.',
              ),
              this.applyMatrix4(e)
            );
          },
          fromAttribute: function (e, t, r) {
            return (
              console.warn(
                'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().',
              ),
              this.fromBufferAttribute(e, t, r)
            );
          },
          distanceToManhattan: function (e) {
            return (
              console.warn(
                'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
              ),
              this.manhattanDistanceTo(e)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().',
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign(hr.prototype, {
          fromAttribute: function (e, t, r) {
            return (
              console.warn(
                'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().',
              ),
              this.fromBufferAttribute(e, t, r)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().',
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign(qr.prototype, {
          computeTangents: function () {
            console.error('THREE.Geometry: .computeTangents() has been removed.');
          },
          computeLineDistances: function () {
            console.error(
              'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.',
            );
          },
        }),
        Object.assign(kr.prototype, {
          getChildByName: function (e) {
            return (
              console.warn(
                'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().',
              ),
              this.getObjectByName(e)
            );
          },
          renderDepth: function () {
            console.warn(
              'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.',
            );
          },
          translate: function (e, t) {
            return (
              console.warn(
                'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.',
              ),
              this.translateOnAxis(t, e)
            );
          },
          getWorldRotation: function () {
            console.error(
              'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.',
            );
          },
        }),
        Object.defineProperties(kr.prototype, {
          eulerOrder: {
            get: function () {
              return (
                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'),
                this.rotation.order
              );
            },
            set: function (e) {
              console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'),
                (this.rotation.order = e);
            },
          },
          useQuaternion: {
            get: function () {
              console.warn(
                'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
              );
            },
            set: function () {
              console.warn(
                'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
              );
            },
          },
        }),
        Object.defineProperties(Pa.prototype, {
          objects: {
            get: function () {
              return console.warn('THREE.LOD: .objects has been renamed to .levels.'), this.levels;
            },
          },
        }),
        Object.defineProperty(Ia.prototype, 'useVertexTexture', {
          get: function () {
            console.warn('THREE.Skeleton: useVertexTexture has been removed.');
          },
          set: function () {
            console.warn('THREE.Skeleton: useVertexTexture has been removed.');
          },
        }),
        (Oa.prototype.initBones = function () {
          console.error('THREE.SkinnedMesh: initBones() has been removed.');
        }),
        Object.defineProperty(ks.prototype, '__arcLengthDivisions', {
          get: function () {
            return (
              console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.'),
              this.arcLengthDivisions
            );
          },
          set: function (e) {
            console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.'),
              (this.arcLengthDivisions = e);
          },
        }),
        (la.prototype.setLens = function (e, t) {
          console.warn(
            'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.',
          ),
            void 0 !== t && (this.filmGauge = t),
            this.setFocalLength(e);
        }),
        Object.defineProperties(hc.prototype, {
          onlyShadow: {
            set: function () {
              console.warn('THREE.Light: .onlyShadow has been removed.');
            },
          },
          shadowCameraFov: {
            set: function (e) {
              console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.'),
                (this.shadow.camera.fov = e);
            },
          },
          shadowCameraLeft: {
            set: function (e) {
              console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.'),
                (this.shadow.camera.left = e);
            },
          },
          shadowCameraRight: {
            set: function (e) {
              console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.'),
                (this.shadow.camera.right = e);
            },
          },
          shadowCameraTop: {
            set: function (e) {
              console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.'),
                (this.shadow.camera.top = e);
            },
          },
          shadowCameraBottom: {
            set: function (e) {
              console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.'),
                (this.shadow.camera.bottom = e);
            },
          },
          shadowCameraNear: {
            set: function (e) {
              console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.'),
                (this.shadow.camera.near = e);
            },
          },
          shadowCameraFar: {
            set: function (e) {
              console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.'),
                (this.shadow.camera.far = e);
            },
          },
          shadowCameraVisible: {
            set: function () {
              console.warn(
                'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.',
              );
            },
          },
          shadowBias: {
            set: function (e) {
              console.warn('THREE.Light: .shadowBias is now .shadow.bias.'), (this.shadow.bias = e);
            },
          },
          shadowDarkness: {
            set: function () {
              console.warn('THREE.Light: .shadowDarkness has been removed.');
            },
          },
          shadowMapWidth: {
            set: function (e) {
              console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.'),
                (this.shadow.mapSize.width = e);
            },
          },
          shadowMapHeight: {
            set: function (e) {
              console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.'),
                (this.shadow.mapSize.height = e);
            },
          },
        }),
        Object.defineProperties(Xr.prototype, {
          length: {
            get: function () {
              return (
                console.warn(
                  'THREE.BufferAttribute: .length has been deprecated. Use .count instead.',
                ),
                this.array.length
              );
            },
          },
          copyIndicesArray: function () {
            console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
          },
        }),
        Object.assign(sn.prototype, {
          addIndex: function (e) {
            console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().'),
              this.setIndex(e);
          },
          addDrawCall: function (e, t, r) {
            void 0 !== r &&
              console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.'),
              console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().'),
              this.addGroup(e, t);
          },
          clearDrawCalls: function () {
            console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().'),
              this.clearGroups();
          },
          computeTangents: function () {
            console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
          },
          computeOffsets: function () {
            console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
          },
        }),
        Object.defineProperties(sn.prototype, {
          drawcalls: {
            get: function () {
              return (
                console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.'),
                this.groups
              );
            },
          },
          offsets: {
            get: function () {
              return (
                console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.'),
                this.groups
              );
            },
          },
        }),
        Object.assign(Uo.prototype, {
          getArrays: function () {
            console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');
          },
          addShapeList: function () {
            console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');
          },
          addShape: function () {
            console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');
          },
        }),
        Object.defineProperties(Au.prototype, {
          dynamic: {
            set: function () {
              console.warn(
                'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.',
              );
            },
          },
          onUpdate: {
            value: function () {
              return (
                console.warn(
                  'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.',
                ),
                this
              );
            },
          },
        }),
        Object.defineProperties(En.prototype, {
          wrapAround: {
            get: function () {
              console.warn('THREE.Material: .wrapAround has been removed.');
            },
            set: function () {
              console.warn('THREE.Material: .wrapAround has been removed.');
            },
          },
          overdraw: {
            get: function () {
              console.warn('THREE.Material: .overdraw has been removed.');
            },
            set: function () {
              console.warn('THREE.Material: .overdraw has been removed.');
            },
          },
          wrapRGB: {
            get: function () {
              return console.warn('THREE.Material: .wrapRGB has been removed.'), new Lr();
            },
          },
          shading: {
            get: function () {
              console.error(
                'THREE.' +
                  this.type +
                  ': .shading has been removed. Use the boolean .flatShading instead.',
              );
            },
            set: function (e) {
              console.warn(
                'THREE.' +
                  this.type +
                  ': .shading has been removed. Use the boolean .flatShading instead.',
              ),
                (this.flatShading = e === C);
            },
          },
        }),
        Object.defineProperties(us.prototype, {
          metal: {
            get: function () {
              return (
                console.warn(
                  'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.',
                ),
                !1
              );
            },
            set: function () {
              console.warn(
                'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead',
              );
            },
          },
        }),
        Object.defineProperties(Tn.prototype, {
          derivatives: {
            get: function () {
              return (
                console.warn(
                  'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
                ),
                this.extensions.derivatives
              );
            },
            set: function (e) {
              console.warn(
                'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
              ),
                (this.extensions.derivatives = e);
            },
          },
        }),
        Object.assign(Ma.prototype, {
          clearTarget: function (e, t, r, n) {
            console.warn(
              'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.',
            ),
              this.setRenderTarget(e),
              this.clear(t, r, n);
          },
          animate: function (e) {
            console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().'),
              this.setAnimationLoop(e);
          },
          getCurrentRenderTarget: function () {
            return (
              console.warn(
                'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().',
              ),
              this.getRenderTarget()
            );
          },
          getMaxAnisotropy: function () {
            return (
              console.warn(
                'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().',
              ),
              this.capabilities.getMaxAnisotropy()
            );
          },
          getPrecision: function () {
            return (
              console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.'),
              this.capabilities.precision
            );
          },
          resetGLState: function () {
            return (
              console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().'),
              this.state.reset()
            );
          },
          supportsFloatTextures: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).",
              ),
              this.extensions.get('OES_texture_float')
            );
          },
          supportsHalfFloatTextures: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).",
              ),
              this.extensions.get('OES_texture_half_float')
            );
          },
          supportsStandardDerivatives: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).",
              ),
              this.extensions.get('OES_standard_derivatives')
            );
          },
          supportsCompressedTextureS3TC: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).",
              ),
              this.extensions.get('WEBGL_compressed_texture_s3tc')
            );
          },
          supportsCompressedTexturePVRTC: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).",
              ),
              this.extensions.get('WEBGL_compressed_texture_pvrtc')
            );
          },
          supportsBlendMinMax: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).",
              ),
              this.extensions.get('EXT_blend_minmax')
            );
          },
          supportsVertexTextures: function () {
            return (
              console.warn(
                'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.',
              ),
              this.capabilities.vertexTextures
            );
          },
          supportsInstancedArrays: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).",
              ),
              this.extensions.get('ANGLE_instanced_arrays')
            );
          },
          enableScissorTest: function (e) {
            console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().'),
              this.setScissorTest(e);
          },
          initMaterial: function () {
            console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
          },
          addPrePlugin: function () {
            console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
          },
          addPostPlugin: function () {
            console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
          },
          updateShadowMap: function () {
            console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
          },
          setFaceCulling: function () {
            console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
          },
        }),
        Object.defineProperties(Ma.prototype, {
          shadowMapEnabled: {
            get: function () {
              return this.shadowMap.enabled;
            },
            set: function (e) {
              console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.'),
                (this.shadowMap.enabled = e);
            },
          },
          shadowMapType: {
            get: function () {
              return this.shadowMap.type;
            },
            set: function (e) {
              console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.'),
                (this.shadowMap.type = e);
            },
          },
          shadowMapCullFace: {
            get: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
              );
            },
            set: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
              );
            },
          },
        }),
        Object.defineProperties(ia.prototype, {
          cullFace: {
            get: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
              );
            },
            set: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
              );
            },
          },
          renderReverseSided: {
            get: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
              );
            },
            set: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
              );
            },
          },
          renderSingleSided: {
            get: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
              );
            },
            set: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
              );
            },
          },
        }),
        Object.defineProperties(dr.prototype, {
          wrapS: {
            get: function () {
              return (
                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'),
                this.texture.wrapS
              );
            },
            set: function (e) {
              console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'),
                (this.texture.wrapS = e);
            },
          },
          wrapT: {
            get: function () {
              return (
                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'),
                this.texture.wrapT
              );
            },
            set: function (e) {
              console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'),
                (this.texture.wrapT = e);
            },
          },
          magFilter: {
            get: function () {
              return (
                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'),
                this.texture.magFilter
              );
            },
            set: function (e) {
              console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'),
                (this.texture.magFilter = e);
            },
          },
          minFilter: {
            get: function () {
              return (
                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'),
                this.texture.minFilter
              );
            },
            set: function (e) {
              console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'),
                (this.texture.minFilter = e);
            },
          },
          anisotropy: {
            get: function () {
              return (
                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'),
                this.texture.anisotropy
              );
            },
            set: function (e) {
              console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'),
                (this.texture.anisotropy = e);
            },
          },
          offset: {
            get: function () {
              return (
                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'),
                this.texture.offset
              );
            },
            set: function (e) {
              console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'),
                (this.texture.offset = e);
            },
          },
          repeat: {
            get: function () {
              return (
                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'),
                this.texture.repeat
              );
            },
            set: function (e) {
              console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'),
                (this.texture.repeat = e);
            },
          },
          format: {
            get: function () {
              return (
                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'),
                this.texture.format
              );
            },
            set: function (e) {
              console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'),
                (this.texture.format = e);
            },
          },
          type: {
            get: function () {
              return (
                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'),
                this.texture.type
              );
            },
            set: function (e) {
              console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'),
                (this.texture.type = e);
            },
          },
          generateMipmaps: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
                ),
                this.texture.generateMipmaps
              );
            },
            set: function (e) {
              console.warn(
                'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
              ),
                (this.texture.generateMipmaps = e);
            },
          },
        }),
        Object.defineProperties(wa.prototype, {
          standing: {
            set: function () {
              console.warn('THREE.WebVRManager: .standing has been removed.');
            },
          },
          userHeight: {
            set: function () {
              console.warn('THREE.WebVRManager: .userHeight has been removed.');
            },
          },
        }),
        (nu.prototype.load = function (e) {
          console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
          var t = this;
          return (
            new Qc().load(e, function (e) {
              t.setBuffer(e);
            }),
            this
          );
        }),
        (au.prototype.getData = function () {
          return (
            console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().'),
            this.getFrequencyData()
          );
        }),
        (eu.prototype.updateCubeMap = function (e, t) {
          return (
            console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().'), this.update(e, t)
          );
        });
      var Ol = {
        merge: function (e, t, r) {
          var n;
          console.warn(
            'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.',
          ),
            t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), (n = t.matrix), (t = t.geometry)),
            e.merge(t, n, r);
        },
        center: function (e) {
          return (
            console.warn(
              'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.',
            ),
            e.center()
          );
        },
      };
      function Il() {
        console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.'),
          (this.projectVector = function (e, t) {
            console.warn('THREE.Projector: .projectVector() is now vector.project().'),
              e.project(t);
          }),
          (this.unprojectVector = function (e, t) {
            console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().'),
              e.unproject(t);
          }),
          (this.pickingRay = function () {
            console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
          });
      }
      function Dl() {
        console.error('THREE.CanvasRenderer has been removed');
      }
      function Bl() {
        console.error('THREE.JSONLoader has been removed.');
      }
      (cr.crossOrigin = void 0),
        (cr.loadTexture = function (e, t, r, n) {
          console.warn(
            'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.',
          );
          var i = new Hs();
          i.setCrossOrigin(this.crossOrigin);
          var a = i.load(e, r, void 0, n);
          return t && (a.mapping = t), a;
        }),
        (cr.loadTextureCube = function (e, t, r, n) {
          console.warn(
            'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.',
          );
          var i = new zs();
          i.setCrossOrigin(this.crossOrigin);
          var a = i.load(e, r, void 0, n);
          return t && (a.mapping = t), a;
        }),
        (cr.loadCompressedTexture = function () {
          console.error(
            'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.',
          );
        }),
        (cr.loadCompressedTextureCube = function () {
          console.error(
            'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.',
          );
        });
      var Nl = {
        createMultiMaterialObject: function () {
          console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
        },
        detach: function () {
          console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
        },
        attach: function () {
          console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
        },
      };
      function Ul() {
        console.error('THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js');
      }
    },
    function (e, t) {
      e.exports =
        '#define GLSLIFY 1\nuniform float time;\nuniform float progress;\nuniform float inside;\nuniform vec3 surfaceColor;\nuniform vec3 insideColor;\n\nvarying vec2 vUv;\nvarying vec2 vUv1;\n\n\n// matcap\nuniform samplerCube tCube;\n// uniform sampler2D matcap;\nvarying vec3 eye;\nvarying vec3 vNormal;\n// varying vec3 vPosition;\n\nvarying vec3 vReflect;\n\n// varying float vTemp;\n\n\nvoid main()\t{\n\n\t// matcap calc\n\tvec3 r = reflect( eye, vNormal );\n\tfloat m = 2. * sqrt( pow( r.x, 2. ) + pow( r.y, 2. ) + pow( r.z + 1., 2. ) );\n\tvec2 vN = r.xy / m + .5;\n\t// vec3 base = texture2D( matcap, vN ).rgb;\n\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n\t// end matcap\n\n\t// vec3 light = normalize(vec3(1200.,1000.,1000.));\n\t// vec3 light1 = normalize(vec3(-1200.,100.,100.));\n\tvec3 light = normalize(vec3(12.,10.,10.));\n\tvec3 light1 = normalize(vec3(-12.,-10.,-10.));\n\tfloat l = clamp(dot(light, vNormal),0.5,1.);\n\tl += clamp(dot(light1, vNormal),0.5,1.)/2.;\n\t l /= 2.;\n\t\n\tif(inside>0.5){\n\n\t\tgl_FragColor = vec4(1.,0.,0.,1.);\n\t\tgl_FragColor = vec4(l,l,l,1.)*vec4(surfaceColor,1.);\n\t\t// gl_FragColor = vec4(vNormal,1.);\n\n\n\n\t\t\n\t} else{\n\t\t// if(progress<0.002) discard;\n\t\tgl_FragColor = vec4(abs(vNormal),1.);\n\t\tgl_FragColor = vec4(l,l,l,1.)*vec4(1.,0.,0.,1.);\n\t\t\n\t\tgl_FragColor = reflectedColor*vec4(insideColor,1.);\n\t}\n\n\t// gl_FragColor = vec4(vNormal,1.);\n\t// gl_FragColor = vec4(-vReflect.x, vReflect.yz ,1.);\n\t// gl_FragColor = reflectedColor;\n\t// gl_FragColor = vec4(l,l,l,1.);\n\t// gl_FragColor = vec4(progress,0.,0.,1.);\n\t// gl_FragColor = vec4(1.,1.,1.,1.);\n}';
    },
    function (e, t, r) {
      'use strict';
      var n =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (e) {
                return typeof e;
              }
            : function (e) {
                return e &&
                  'function' == typeof Symbol &&
                  e.constructor === Symbol &&
                  e !== Symbol.prototype
                  ? 'symbol'
                  : typeof e;
              },
        i = (function (e) {
          if (e && e.__esModule) return e;
          var t = {};
          if (null != e)
            for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
          return (t.default = e), t;
        })(r(0));
      (i.DRACOLoader = function (e) {
        (this.timeLoaded = 0),
          (this.manager = e || i.DefaultLoadingManager),
          (this.materials = null),
          (this.verbosity = 0),
          (this.attributeOptions = {}),
          (this.drawMode = i.TrianglesDrawMode),
          (this.nativeAttributeMap = {
            position: 'POSITION',
            normal: 'NORMAL',
            color: 'COLOR',
            uv: 'TEX_COORD',
          });
      }),
        (i.DRACOLoader.prototype = {
          constructor: i.DRACOLoader,
          load: function (e, t, r, n) {
            var a = this,
              o = new i.FileLoader(a.manager);
            o.setPath(this.path),
              o.setResponseType('arraybuffer'),
              void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
              o.load(
                e,
                function (e) {
                  a.decodeDracoFile(e, t);
                },
                r,
                n,
              );
          },
          setPath: function (e) {
            this.path = e;
          },
          setCrossOrigin: function (e) {
            this.crossOrigin = e;
          },
          setVerbosity: function (e) {
            this.verbosity = e;
          },
          setDrawMode: function (e) {
            this.drawMode = e;
          },
          setSkipDequantization: function (e, t) {
            var r = !0;
            void 0 !== t && (r = t), (this.getAttributeOptions(e).skipDequantization = r);
          },
          decodeDracoFile: function (e, t, r, n) {
            var a = this;
            i.DRACOLoader.getDecoderModule().then(function (i) {
              a.decodeDracoFileInternal(e, i.decoder, t, r || {}, n || {});
            });
          },
          decodeDracoFileInternal: function (e, t, r, n, i) {
            var a = new t.DecoderBuffer();
            a.Init(new Int8Array(e), e.byteLength);
            var o = new t.Decoder(),
              s = o.GetEncodedGeometryType(a);
            if (s == t.TRIANGULAR_MESH) this.verbosity > 0 && console.log('Loaded a mesh.');
            else {
              if (s != t.POINT_CLOUD) {
                var c = 'THREE.DRACOLoader: Unknown geometry type.';
                throw (console.error(c), new Error(c));
              }
              this.verbosity > 0 && console.log('Loaded a point cloud.');
            }
            r(this.convertDracoGeometryTo3JS(t, o, s, a, n, i));
          },
          addAttributeToGeometry: function (e, t, r, n, a, o, s, c) {
            if (0 === o.ptr) {
              var u = 'THREE.DRACOLoader: No attribute ' + n;
              throw (console.error(u), new Error(u));
            }
            var l,
              h,
              d = o.num_components(),
              p = r.num_points() * d;
            switch (a) {
              case Float32Array:
                (l = new e.DracoFloat32Array()),
                  t.GetAttributeFloatForAllPoints(r, o, l),
                  (c[n] = new Float32Array(p)),
                  (h = i.Float32BufferAttribute);
                break;
              case Int8Array:
                (l = new e.DracoInt8Array()),
                  t.GetAttributeInt8ForAllPoints(r, o, l),
                  (c[n] = new Int8Array(p)),
                  (h = i.Int8BufferAttribute);
                break;
              case Int16Array:
                (l = new e.DracoInt16Array()),
                  t.GetAttributeInt16ForAllPoints(r, o, l),
                  (c[n] = new Int16Array(p)),
                  (h = i.Int16BufferAttribute);
                break;
              case Int32Array:
                (l = new e.DracoInt32Array()),
                  t.GetAttributeInt32ForAllPoints(r, o, l),
                  (c[n] = new Int32Array(p)),
                  (h = i.Int32BufferAttribute);
                break;
              case Uint8Array:
                (l = new e.DracoUInt8Array()),
                  t.GetAttributeUInt8ForAllPoints(r, o, l),
                  (c[n] = new Uint8Array(p)),
                  (h = i.Uint8BufferAttribute);
                break;
              case Uint16Array:
                (l = new e.DracoUInt16Array()),
                  t.GetAttributeUInt16ForAllPoints(r, o, l),
                  (c[n] = new Uint16Array(p)),
                  (h = i.Uint16BufferAttribute);
                break;
              case Uint32Array:
                (l = new e.DracoUInt32Array()),
                  t.GetAttributeUInt32ForAllPoints(r, o, l),
                  (c[n] = new Uint32Array(p)),
                  (h = i.Uint32BufferAttribute);
                break;
              default:
                u = 'THREE.DRACOLoader: Unexpected attribute type.';
                throw (console.error(u), new Error(u));
            }
            for (var f = 0; f < p; f++) c[n][f] = l.GetValue(f);
            s.addAttribute(n, new h(c[n], d)), e.destroy(l);
          },
          convertDracoGeometryTo3JS: function (e, t, r, n, a, o) {
            var s, c;
            !0 === this.getAttributeOptions('position').skipDequantization &&
              t.SkipAttributeTransform(e.POSITION);
            var u = performance.now();
            if (
              (r === e.TRIANGULAR_MESH
                ? ((s = new e.Mesh()), (c = t.DecodeBufferToMesh(n, s)))
                : ((s = new e.PointCloud()), (c = t.DecodeBufferToPointCloud(n, s))),
              !c.ok() || 0 == s.ptr)
            ) {
              var l = 'THREE.DRACOLoader: Decoding failed: ';
              throw (
                ((l += c.error_msg()), console.error(l), e.destroy(t), e.destroy(s), new Error(l))
              );
            }
            var h,
              d = performance.now();
            e.destroy(n),
              r == e.TRIANGULAR_MESH
                ? ((h = s.num_faces()),
                  this.verbosity > 0 && console.log('Number of faces loaded: ' + h.toString()))
                : (h = 0);
            var p = s.num_points(),
              f = s.num_attributes();
            this.verbosity > 0 &&
              (console.log('Number of points loaded: ' + p.toString()),
              console.log('Number of attributes loaded: ' + f.toString()));
            var m = t.GetAttributeId(s, e.POSITION);
            if (-1 == m) {
              l = 'THREE.DRACOLoader: No position attribute found.';
              throw (console.error(l), e.destroy(t), e.destroy(s), new Error(l));
            }
            var v = t.GetAttribute(s, m),
              g = {},
              y = new i.BufferGeometry();
            for (var x in this.nativeAttributeMap)
              if (void 0 === a[x]) {
                var b = t.GetAttributeId(s, e[this.nativeAttributeMap[x]]);
                if (-1 !== b) {
                  this.verbosity > 0 && console.log('Loaded ' + x + ' attribute.');
                  var w = t.GetAttribute(s, b);
                  this.addAttributeToGeometry(e, t, s, x, Float32Array, w, y, g);
                }
              }
            for (var x in a) {
              var _ = o[x] || Float32Array,
                M = a[x];
              w = t.GetAttributeByUniqueId(s, M);
              this.addAttributeToGeometry(e, t, s, x, _, w, y, g);
            }
            if (r == e.TRIANGULAR_MESH)
              if (this.drawMode === i.TriangleStripDrawMode) {
                var S = new e.DracoInt32Array();
                t.GetTriangleStripsFromMesh(s, S);
                g.indices = new Uint32Array(S.size());
                for (var E = 0; E < S.size(); ++E) g.indices[E] = S.GetValue(E);
                e.destroy(S);
              } else {
                var T = 3 * h;
                g.indices = new Uint32Array(T);
                var A = new e.DracoInt32Array();
                for (E = 0; E < h; ++E) {
                  t.GetFaceFromMesh(s, E, A);
                  var L = 3 * E;
                  (g.indices[L] = A.GetValue(0)),
                    (g.indices[L + 1] = A.GetValue(1)),
                    (g.indices[L + 2] = A.GetValue(2));
                }
                e.destroy(A);
              }
            (y.drawMode = this.drawMode),
              r == e.TRIANGULAR_MESH &&
                y.setIndex(
                  new (g.indices.length > 65535
                    ? i.Uint32BufferAttribute
                    : i.Uint16BufferAttribute)(g.indices, 1),
                );
            var R = new e.AttributeQuantizationTransform();
            if (R.InitFromAttribute(v)) {
              (y.attributes.position.isQuantized = !0),
                (y.attributes.position.maxRange = R.range()),
                (y.attributes.position.numQuantizationBits = R.quantization_bits()),
                (y.attributes.position.minValues = new Float32Array(3));
              for (E = 0; E < 3; ++E) y.attributes.position.minValues[E] = R.min_value(E);
            }
            return (
              e.destroy(R),
              e.destroy(t),
              e.destroy(s),
              (this.decode_time = d - u),
              (this.import_time = performance.now() - d),
              this.verbosity > 0 &&
                (console.log('Decode time: ' + this.decode_time),
                console.log('Import time: ' + this.import_time)),
              y
            );
          },
          isVersionSupported: function (e, t) {
            i.DRACOLoader.getDecoderModule().then(function (r) {
              t(r.decoder.isVersionSupported(e));
            });
          },
          getAttributeOptions: function (e) {
            return (
              void 0 === this.attributeOptions[e] && (this.attributeOptions[e] = {}),
              this.attributeOptions[e]
            );
          },
        }),
        (i.DRACOLoader.decoderPath = './'),
        (i.DRACOLoader.decoderConfig = {}),
        (i.DRACOLoader.decoderModulePromise = null),
        (i.DRACOLoader.setDecoderPath = function (e) {
          i.DRACOLoader.decoderPath = e;
        }),
        (i.DRACOLoader.setDecoderConfig = function (e) {
          var t = i.DRACOLoader.decoderConfig.wasmBinary;
          (i.DRACOLoader.decoderConfig = e || {}),
            i.DRACOLoader.releaseDecoderModule(),
            t && (i.DRACOLoader.decoderConfig.wasmBinary = t);
        }),
        (i.DRACOLoader.releaseDecoderModule = function () {
          i.DRACOLoader.decoderModulePromise = null;
        }),
        (i.DRACOLoader.getDecoderModule = function () {
          var e = this,
            t = i.DRACOLoader.decoderPath,
            r = i.DRACOLoader.decoderConfig,
            a = i.DRACOLoader.decoderModulePromise;
          return (
            a ||
            ('undefined' != typeof DracoDecoderModule
              ? (a = Promise.resolve())
              : 'object' !== ('undefined' == typeof WebAssembly ? 'undefined' : n(WebAssembly)) ||
                'js' === r.type
              ? (a = i.DRACOLoader._loadScript(t + 'draco_decoder.js'))
              : ((r.wasmBinaryFile = t + 'draco_decoder.wasm'),
                (a = i.DRACOLoader._loadScript(t + 'draco_wasm_wrapper.js')
                  .then(function () {
                    return i.DRACOLoader._loadArrayBuffer(r.wasmBinaryFile);
                  })
                  .then(function (e) {
                    r.wasmBinary = e;
                  }))),
            (a = a.then(function () {
              return new Promise(function (t) {
                (r.onModuleLoaded = function (r) {
                  (e.timeLoaded = performance.now()), t({ decoder: r });
                }),
                  DracoDecoderModule(r);
              });
            })),
            (i.DRACOLoader.decoderModulePromise = a),
            a)
          );
        }),
        (i.DRACOLoader._loadScript = function (e) {
          var t = document.getElementById('decoder_script');
          null !== t && t.parentNode.removeChild(t);
          var r = document.getElementsByTagName('head')[0],
            n = document.createElement('script');
          return (
            (n.id = 'decoder_script'),
            (n.type = 'text/javascript'),
            (n.src = e),
            new Promise(function (e) {
              (n.onload = e), r.appendChild(n);
            })
          );
        }),
        (i.DRACOLoader._loadArrayBuffer = function (e) {
          var t = new i.FileLoader();
          return (
            t.setResponseType('arraybuffer'),
            new Promise(function (r, n) {
              t.load(e, r, void 0, n);
            })
          );
        });
    },
    function (e, t, r) {
      'use strict';
      var n = (function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return (t.default = e), t;
      })(r(0));
      n.BufferGeometryUtils = {
        computeTangents: function (e) {
          var t = e.index,
            r = e.attributes;
          if (null !== t && void 0 !== r.position && void 0 !== r.normal && void 0 !== r.uv) {
            var i = t.array,
              a = r.position.array,
              o = r.normal.array,
              s = r.uv.array,
              c = a.length / 3;
            void 0 === r.tangent &&
              e.addAttribute('tangent', new n.BufferAttribute(new Float32Array(4 * c), 4));
            for (var u = r.tangent.array, l = [], h = [], d = 0; d < c; d++)
              (l[d] = new n.Vector3()), (h[d] = new n.Vector3());
            var p = new n.Vector3(),
              f = new n.Vector3(),
              m = new n.Vector3(),
              v = new n.Vector2(),
              g = new n.Vector2(),
              y = new n.Vector2(),
              x = new n.Vector3(),
              b = new n.Vector3(),
              w = e.groups;
            0 === w.length && (w = [{ start: 0, count: i.length }]);
            d = 0;
            for (var _ = w.length; d < _; ++d)
              for (var M = (I = (O = w[d]).start), S = I + O.count; M < S; M += 3)
                D(i[M + 0], i[M + 1], i[M + 2]);
            var E,
              T,
              A,
              L = new n.Vector3(),
              R = new n.Vector3(),
              C = new n.Vector3(),
              P = new n.Vector3();
            for (d = 0, _ = w.length; d < _; ++d) {
              var O, I;
              for (M = I = (O = w[d]).start, S = I + O.count; M < S; M += 3)
                B(i[M + 0]), B(i[M + 1]), B(i[M + 2]);
            }
          } else
            console.warn(
              'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()',
            );
          function D(e, t, r) {
            p.fromArray(a, 3 * e),
              f.fromArray(a, 3 * t),
              m.fromArray(a, 3 * r),
              v.fromArray(s, 2 * e),
              g.fromArray(s, 2 * t),
              y.fromArray(s, 2 * r);
            var n = f.x - p.x,
              i = m.x - p.x,
              o = f.y - p.y,
              c = m.y - p.y,
              u = f.z - p.z,
              d = m.z - p.z,
              w = g.x - v.x,
              _ = y.x - v.x,
              M = g.y - v.y,
              S = y.y - v.y,
              E = 1 / (w * S - _ * M);
            x.set((S * n - M * i) * E, (S * o - M * c) * E, (S * u - M * d) * E),
              b.set((w * i - _ * n) * E, (w * c - _ * o) * E, (w * d - _ * u) * E),
              l[e].add(x),
              l[t].add(x),
              l[r].add(x),
              h[e].add(b),
              h[t].add(b),
              h[r].add(b);
          }
          function B(e) {
            C.fromArray(o, 3 * e),
              P.copy(C),
              (T = l[e]),
              L.copy(T),
              L.sub(C.multiplyScalar(C.dot(T))).normalize(),
              R.crossVectors(P, T),
              (A = R.dot(h[e])),
              (E = A < 0 ? -1 : 1),
              (u[4 * e] = L.x),
              (u[4 * e + 1] = L.y),
              (u[4 * e + 2] = L.z),
              (u[4 * e + 3] = E);
          }
        },
        mergeBufferGeometries: function (e, t) {
          for (
            var r = null !== e[0].index,
              i = new Set(Object.keys(e[0].attributes)),
              a = new Set(Object.keys(e[0].morphAttributes)),
              o = {},
              s = {},
              c = new n.BufferGeometry(),
              u = 0,
              l = 0;
            l < e.length;
            ++l
          ) {
            var h = e[l];
            if (r !== (null !== h.index)) return null;
            for (var d in h.attributes) {
              if (!i.has(d)) return null;
              void 0 === o[d] && (o[d] = []), o[d].push(h.attributes[d]);
            }
            for (var d in h.morphAttributes) {
              if (!a.has(d)) return null;
              void 0 === s[d] && (s[d] = []), s[d].push(h.morphAttributes[d]);
            }
            if (
              ((c.userData.mergedUserData = c.userData.mergedUserData || []),
              c.userData.mergedUserData.push(h.userData),
              t)
            ) {
              var p;
              if (r) p = h.index.count;
              else {
                if (void 0 === h.attributes.position) return null;
                p = h.attributes.position.count;
              }
              c.addGroup(u, p, l), (u += p);
            }
          }
          if (r) {
            var f = 0,
              m = [];
            for (l = 0; l < e.length; ++l) {
              for (var v = e[l].index, g = 0; g < v.count; ++g) m.push(v.getX(g) + f);
              f += e[l].attributes.position.count;
            }
            c.setIndex(m);
          }
          for (var d in o) {
            var y = this.mergeBufferAttributes(o[d]);
            if (!y) return null;
            c.addAttribute(d, y);
          }
          for (var d in s) {
            var x = s[d][0].length;
            if (0 === x) break;
            (c.morphAttributes = c.morphAttributes || {}), (c.morphAttributes[d] = []);
            for (l = 0; l < x; ++l) {
              var b = [];
              for (g = 0; g < s[d].length; ++g) b.push(s[d][g][l]);
              var w = this.mergeBufferAttributes(b);
              if (!w) return null;
              c.morphAttributes[d].push(w);
            }
          }
          return c;
        },
        mergeBufferAttributes: function (e) {
          for (var t, r, i, a = 0, o = 0; o < e.length; ++o) {
            var s = e[o];
            if (s.isInterleavedBufferAttribute) return null;
            if ((void 0 === t && (t = s.array.constructor), t !== s.array.constructor)) return null;
            if ((void 0 === r && (r = s.itemSize), r !== s.itemSize)) return null;
            if ((void 0 === i && (i = s.normalized), i !== s.normalized)) return null;
            a += s.array.length;
          }
          var c = new t(a),
            u = 0;
          for (o = 0; o < e.length; ++o) c.set(e[o].array, u), (u += e[o].array.length);
          return new n.BufferAttribute(c, r, i);
        },
        interleaveAttributes: function (e) {
          for (var t, r = 0, i = 0, a = 0, o = e.length; a < o; ++a) {
            var s = e[a];
            if ((void 0 === t && (t = s.array.constructor), t !== s.array.constructor))
              return (
                console.warn('AttributeBuffers of different types cannot be interleaved'), null
              );
            (r += s.array.length), (i += s.itemSize);
          }
          var c = new n.InterleavedBuffer(new t(r), i),
            u = 0,
            l = [],
            h = ['getX', 'getY', 'getZ', 'getW'],
            d = ['setX', 'setY', 'setZ', 'setW'],
            p = 0;
          for (o = e.length; p < o; p++) {
            var f = (s = e[p]).itemSize,
              m = s.count,
              v = new n.InterleavedBufferAttribute(c, f, u, s.normalized);
            l.push(v), (u += f);
            for (var g = 0; g < m; g++) for (var y = 0; y < f; y++) v[d[y]](g, s[h[y]](g));
          }
          return l;
        },
        estimateBytesUsed: function (e) {
          var t = 0;
          for (var r in e.attributes) {
            var n = e.getAttribute(r);
            t += n.count * n.itemSize * n.array.BYTES_PER_ELEMENT;
          }
          var i = e.getIndex();
          return (t += i ? i.count * i.itemSize * i.array.BYTES_PER_ELEMENT : 0);
        },
        mergeVertices: function (e) {
          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e-4;
          t = Math.max(t, Number.EPSILON);
          var r = {},
            i = e.getIndex(),
            a = e.getAttribute('position'),
            o = i ? i.count : a.count,
            s = 0,
            c = Object.keys(e.attributes),
            u = {},
            l = {},
            h = [],
            d = ['getX', 'getY', 'getZ', 'getW'],
            p = !0,
            f = !1,
            m = void 0;
          try {
            for (var v, g = c[Symbol.iterator](); !(p = (v = g.next()).done); p = !0) {
              (u[(E = v.value)] = []),
                (R = e.morphAttributes[E]) &&
                  (l[E] = new Array(R.length).fill().map(function () {
                    return [];
                  }));
            }
          } catch (e) {
            (f = !0), (m = e);
          } finally {
            try {
              !p && g.return && g.return();
            } finally {
              if (f) throw m;
            }
          }
          for (var y = Math.log10(1 / t), x = Math.pow(10, y), b = 0; b < o; b++) {
            for (var w = i ? i.getX(b) : b, _ = '', M = 0, S = c.length; M < S; M++)
              for (var E = c[M], T = (L = e.getAttribute(E)).itemSize, A = 0; A < T; A++)
                _ += ~~(L[d[A]](w) * x) + ',';
            if (_ in r) h.push(r[_]);
            else {
              for (M = 0, S = c.length; M < S; M++) {
                E = c[M];
                var L = e.getAttribute(E),
                  R = e.morphAttributes[E],
                  C = ((T = L.itemSize), u[E]),
                  P = l[E];
                for (A = 0; A < T; A++) {
                  var O = d[A];
                  if ((C.push(L[O](w)), R))
                    for (var I = 0, D = R.length; I < D; I++) P[I].push(R[I][O](w));
                }
              }
              (r[_] = s), h.push(s), s++;
            }
          }
          var B = e.clone();
          for (b = 0, S = c.length; b < S; b++) {
            E = c[b];
            var N = e.getAttribute(E),
              U = new N.array.constructor(u[E]);
            if (
              (N.isInterleavedBufferAttribute
                ? (L = new n.BufferAttribute(U, N.itemSize, N.itemSize))
                : (L = e.getAttribute(E).clone()).setArray(U),
              B.addAttribute(E, L),
              E in l)
            )
              for (M = 0; M < l[E].length; M++) {
                var G = e.morphAttributes[E][M].clone();
                G.setArray(new G.array.constructor(l[E][M])), (B.morphAttributes[E][M] = G);
              }
          }
          var F = Uint8Array;
          h.length >= Math.pow(2, 8) && (F = Uint16Array),
            h.length >= Math.pow(2, 16) && (F = Uint32Array);
          var z = new F(h);
          h = null;
          return (
            null === i ? (h = new n.BufferAttribute(z, 1)) : (h = e.getIndex().clone()).setArray(z),
            B.setIndex(h),
            B
          );
        },
      };
    },
    function (e, t, r) {
      'use strict';
      var n =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (e) {
                return typeof e;
              }
            : function (e) {
                return e &&
                  'function' == typeof Symbol &&
                  e.constructor === Symbol &&
                  e !== Symbol.prototype
                  ? 'symbol'
                  : typeof e;
              },
        i = (function (e) {
          if (e && e.__esModule) return e;
          var t = {};
          if (null != e)
            for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
          return (t.default = e), t;
        })(r(0));
      i.GLTFLoader = (function () {
        function e(e) {
          (this.manager = void 0 !== e ? e : i.DefaultLoadingManager), (this.dracoLoader = null);
        }
        function t() {
          var e = {};
          return {
            get: function (t) {
              return e[t];
            },
            add: function (t, r) {
              e[t] = r;
            },
            remove: function (t) {
              delete e[t];
            },
            removeAll: function () {
              e = {};
            },
          };
        }
        e.prototype = {
          constructor: e,
          crossOrigin: 'anonymous',
          load: function (e, t, r, n) {
            var a,
              o = this;
            (a =
              void 0 !== this.resourcePath
                ? this.resourcePath
                : void 0 !== this.path
                ? this.path
                : i.LoaderUtils.extractUrlBase(e)),
              o.manager.itemStart(e);
            var s = function (t) {
                n ? n(t) : console.error(t), o.manager.itemError(e), o.manager.itemEnd(e);
              },
              c = new i.FileLoader(o.manager);
            c.setPath(this.path),
              c.setResponseType('arraybuffer'),
              c.load(
                e,
                function (r) {
                  try {
                    o.parse(
                      r,
                      a,
                      function (r) {
                        t(r), o.manager.itemEnd(e);
                      },
                      s,
                    );
                  } catch (e) {
                    s(e);
                  }
                },
                r,
                s,
              );
          },
          setCrossOrigin: function (e) {
            return (this.crossOrigin = e), this;
          },
          setPath: function (e) {
            return (this.path = e), this;
          },
          setResourcePath: function (e) {
            return (this.resourcePath = e), this;
          },
          setDRACOLoader: function (e) {
            return (this.dracoLoader = e), this;
          },
          parse: function (e, t, n, u) {
            var l,
              m = {};
            if ('string' == typeof e) l = e;
            else if (i.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === c) {
              try {
                m[r.KHR_BINARY_GLTF] = new h(e);
              } catch (e) {
                return void (u && u(e));
              }
              l = m[r.KHR_BINARY_GLTF].content;
            } else l = i.LoaderUtils.decodeText(new Uint8Array(e));
            var v = JSON.parse(l);
            if (void 0 === v.asset || v.asset.version[0] < 2)
              u &&
                u(
                  new Error(
                    'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.',
                  ),
                );
            else {
              if (v.extensionsUsed)
                for (var g = 0; g < v.extensionsUsed.length; ++g) {
                  var y = v.extensionsUsed[g],
                    x = v.extensionsRequired || [];
                  switch (y) {
                    case r.KHR_LIGHTS_PUNCTUAL:
                      m[y] = new o(v);
                      break;
                    case r.KHR_MATERIALS_UNLIT:
                      m[y] = new s(v);
                      break;
                    case r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                      m[y] = new f(v);
                      break;
                    case r.KHR_DRACO_MESH_COMPRESSION:
                      m[y] = new d(v, this.dracoLoader);
                      break;
                    case r.MSFT_TEXTURE_DDS:
                      m[r.MSFT_TEXTURE_DDS] = new a(v);
                      break;
                    case r.KHR_TEXTURE_TRANSFORM:
                      m[r.KHR_TEXTURE_TRANSFORM] = new p(v);
                      break;
                    default:
                      x.indexOf(y) >= 0 &&
                        console.warn('THREE.GLTFLoader: Unknown extension "' + y + '".');
                  }
                }
              var b = new k(v, m, {
                path: t || this.resourcePath || '',
                crossOrigin: this.crossOrigin,
                manager: this.manager,
              });
              b.parse(function (e, t, r, i, a) {
                var o = {
                  scene: e,
                  scenes: t,
                  cameras: r,
                  animations: i,
                  asset: a.asset,
                  parser: b,
                  userData: {},
                };
                B(m, o, a), n(o);
              }, u);
            }
          },
        };
        var r = {
          KHR_BINARY_GLTF: 'KHR_binary_glTF',
          KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
          KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
          KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
          KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
          KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
          MSFT_TEXTURE_DDS: 'MSFT_texture_dds',
        };
        function a() {
          if (!i.DDSLoader)
            throw new Error(
              'THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader',
            );
          (this.name = r.MSFT_TEXTURE_DDS), (this.ddsLoader = new i.DDSLoader());
        }
        function o(e) {
          this.name = r.KHR_LIGHTS_PUNCTUAL;
          var t = (e.extensions && e.extensions[r.KHR_LIGHTS_PUNCTUAL]) || {};
          this.lightDefs = t.lights || [];
        }
        function s(e) {
          this.name = r.KHR_MATERIALS_UNLIT;
        }
        (o.prototype.loadLight = function (e) {
          var t,
            r = this.lightDefs[e],
            n = new i.Color(16777215);
          void 0 !== r.color && n.fromArray(r.color);
          var a = void 0 !== r.range ? r.range : 0;
          switch (r.type) {
            case 'directional':
              (t = new i.DirectionalLight(n)).target.position.set(0, 0, -1), t.add(t.target);
              break;
            case 'point':
              (t = new i.PointLight(n)).distance = a;
              break;
            case 'spot':
              ((t = new i.SpotLight(n)).distance = a),
                (r.spot = r.spot || {}),
                (r.spot.innerConeAngle =
                  void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0),
                (r.spot.outerConeAngle =
                  void 0 !== r.spot.outerConeAngle ? r.spot.outerConeAngle : Math.PI / 4),
                (t.angle = r.spot.outerConeAngle),
                (t.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle),
                t.target.position.set(0, 0, -1),
                t.add(t.target);
              break;
            default:
              throw new Error('THREE.GLTFLoader: Unexpected light type, "' + r.type + '".');
          }
          return (
            (t.decay = 2),
            void 0 !== r.intensity && (t.intensity = r.intensity),
            (t.name = r.name || 'light_' + e),
            Promise.resolve(t)
          );
        }),
          (s.prototype.getMaterialType = function (e) {
            return i.MeshBasicMaterial;
          }),
          (s.prototype.extendParams = function (e, t, r) {
            var n = [];
            (e.color = new i.Color(1, 1, 1)), (e.opacity = 1);
            var a = t.pbrMetallicRoughness;
            if (a) {
              if (Array.isArray(a.baseColorFactor)) {
                var o = a.baseColorFactor;
                e.color.fromArray(o), (e.opacity = o[3]);
              }
              void 0 !== a.baseColorTexture &&
                n.push(r.assignTexture(e, 'map', a.baseColorTexture));
            }
            return Promise.all(n);
          });
        var c = 'glTF',
          u = 12,
          l = { JSON: 1313821514, BIN: 5130562 };
        function h(e) {
          (this.name = r.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
          var t = new DataView(e, 0, u);
          if (
            ((this.header = {
              magic: i.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
              version: t.getUint32(4, !0),
              length: t.getUint32(8, !0),
            }),
            this.header.magic !== c)
          )
            throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
          if (this.header.version < 2)
            throw new Error(
              'THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.',
            );
          for (var n = new DataView(e, u), a = 0; a < n.byteLength; ) {
            var o = n.getUint32(a, !0);
            a += 4;
            var s = n.getUint32(a, !0);
            if (((a += 4), s === l.JSON)) {
              var h = new Uint8Array(e, u + a, o);
              this.content = i.LoaderUtils.decodeText(h);
            } else if (s === l.BIN) {
              var d = u + a;
              this.body = e.slice(d, d + o);
            }
            a += o;
          }
          if (null === this.content) throw new Error('THREE.GLTFLoader: JSON content not found.');
        }
        function d(e, t) {
          if (!t) throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
          (this.name = r.KHR_DRACO_MESH_COMPRESSION),
            (this.json = e),
            (this.dracoLoader = t),
            i.DRACOLoader.getDecoderModule();
        }
        function p(e) {
          this.name = r.KHR_TEXTURE_TRANSFORM;
        }
        function f() {
          return {
            name: r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
            specularGlossinessParams: [
              'color',
              'map',
              'lightMap',
              'lightMapIntensity',
              'aoMap',
              'aoMapIntensity',
              'emissive',
              'emissiveIntensity',
              'emissiveMap',
              'bumpMap',
              'bumpScale',
              'normalMap',
              'displacementMap',
              'displacementScale',
              'displacementBias',
              'specularMap',
              'specular',
              'glossinessMap',
              'glossiness',
              'alphaMap',
              'envMap',
              'envMapIntensity',
              'refractionRatio',
            ],
            getMaterialType: function () {
              return i.ShaderMaterial;
            },
            extendParams: function (e, t, r) {
              var n = t.extensions[this.name],
                a = i.ShaderLib.standard,
                o = i.UniformsUtils.clone(a.uniforms),
                s = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join(
                  '\n',
                ),
                c = [
                  '#ifdef USE_GLOSSINESSMAP',
                  '\tuniform sampler2D glossinessMap;',
                  '#endif',
                ].join('\n'),
                u = [
                  'vec3 specularFactor = specular;',
                  '#ifdef USE_SPECULARMAP',
                  '\tvec4 texelSpecular = texture2D( specularMap, vUv );',
                  '\ttexelSpecular = sRGBToLinear( texelSpecular );',
                  '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
                  '\tspecularFactor *= texelSpecular.rgb;',
                  '#endif',
                ].join('\n'),
                l = [
                  'float glossinessFactor = glossiness;',
                  '#ifdef USE_GLOSSINESSMAP',
                  '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',
                  '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
                  '\tglossinessFactor *= texelGlossiness.a;',
                  '#endif',
                ].join('\n'),
                h = [
                  'PhysicalMaterial material;',
                  'material.diffuseColor = diffuseColor.rgb;',
                  'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );',
                  'material.specularColor = specularFactor.rgb;',
                ].join('\n'),
                d = a.fragmentShader
                  .replace('uniform float roughness;', 'uniform vec3 specular;')
                  .replace('uniform float metalness;', 'uniform float glossiness;')
                  .replace('#include <roughnessmap_pars_fragment>', s)
                  .replace('#include <metalnessmap_pars_fragment>', c)
                  .replace('#include <roughnessmap_fragment>', u)
                  .replace('#include <metalnessmap_fragment>', l)
                  .replace('#include <lights_physical_fragment>', h);
              delete o.roughness,
                delete o.metalness,
                delete o.roughnessMap,
                delete o.metalnessMap,
                (o.specular = { value: new i.Color().setHex(1118481) }),
                (o.glossiness = { value: 0.5 }),
                (o.specularMap = { value: null }),
                (o.glossinessMap = { value: null }),
                (e.vertexShader = a.vertexShader),
                (e.fragmentShader = d),
                (e.uniforms = o),
                (e.defines = { STANDARD: '' }),
                (e.color = new i.Color(1, 1, 1)),
                (e.opacity = 1);
              var p = [];
              if (Array.isArray(n.diffuseFactor)) {
                var f = n.diffuseFactor;
                e.color.fromArray(f), (e.opacity = f[3]);
              }
              if (
                (void 0 !== n.diffuseTexture && p.push(r.assignTexture(e, 'map', n.diffuseTexture)),
                (e.emissive = new i.Color(0, 0, 0)),
                (e.glossiness = void 0 !== n.glossinessFactor ? n.glossinessFactor : 1),
                (e.specular = new i.Color(1, 1, 1)),
                Array.isArray(n.specularFactor) && e.specular.fromArray(n.specularFactor),
                void 0 !== n.specularGlossinessTexture)
              ) {
                var m = n.specularGlossinessTexture;
                p.push(r.assignTexture(e, 'glossinessMap', m)),
                  p.push(r.assignTexture(e, 'specularMap', m));
              }
              return Promise.all(p);
            },
            createMaterial: function (e) {
              var t = new i.ShaderMaterial({
                defines: e.defines,
                vertexShader: e.vertexShader,
                fragmentShader: e.fragmentShader,
                uniforms: e.uniforms,
                fog: !0,
                lights: !0,
                opacity: e.opacity,
                transparent: e.transparent,
              });
              return (
                (t.isGLTFSpecularGlossinessMaterial = !0),
                (t.color = e.color),
                (t.map = void 0 === e.map ? null : e.map),
                (t.lightMap = null),
                (t.lightMapIntensity = 1),
                (t.aoMap = void 0 === e.aoMap ? null : e.aoMap),
                (t.aoMapIntensity = 1),
                (t.emissive = e.emissive),
                (t.emissiveIntensity = 1),
                (t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap),
                (t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap),
                (t.bumpScale = 1),
                (t.normalMap = void 0 === e.normalMap ? null : e.normalMap),
                e.normalScale && (t.normalScale = e.normalScale),
                (t.displacementMap = null),
                (t.displacementScale = 1),
                (t.displacementBias = 0),
                (t.specularMap = void 0 === e.specularMap ? null : e.specularMap),
                (t.specular = e.specular),
                (t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap),
                (t.glossiness = e.glossiness),
                (t.alphaMap = null),
                (t.envMap = void 0 === e.envMap ? null : e.envMap),
                (t.envMapIntensity = 1),
                (t.refractionRatio = 0.98),
                (t.extensions.derivatives = !0),
                t
              );
            },
            cloneMaterial: function (e) {
              var t = e.clone();
              t.isGLTFSpecularGlossinessMaterial = !0;
              for (var r = this.specularGlossinessParams, n = 0, i = r.length; n < i; n++)
                t[r[n]] = e[r[n]];
              return t;
            },
            refreshUniforms: function (e, t, r, n, i, a) {
              if (!0 === i.isGLTFSpecularGlossinessMaterial) {
                var o,
                  s = i.uniforms,
                  c = i.defines;
                (s.opacity.value = i.opacity),
                  s.diffuse.value.copy(i.color),
                  s.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
                  (s.map.value = i.map),
                  (s.specularMap.value = i.specularMap),
                  (s.alphaMap.value = i.alphaMap),
                  (s.lightMap.value = i.lightMap),
                  (s.lightMapIntensity.value = i.lightMapIntensity),
                  (s.aoMap.value = i.aoMap),
                  (s.aoMapIntensity.value = i.aoMapIntensity),
                  i.map
                    ? (o = i.map)
                    : i.specularMap
                    ? (o = i.specularMap)
                    : i.displacementMap
                    ? (o = i.displacementMap)
                    : i.normalMap
                    ? (o = i.normalMap)
                    : i.bumpMap
                    ? (o = i.bumpMap)
                    : i.glossinessMap
                    ? (o = i.glossinessMap)
                    : i.alphaMap
                    ? (o = i.alphaMap)
                    : i.emissiveMap && (o = i.emissiveMap),
                  void 0 !== o &&
                    (o.isWebGLRenderTarget && (o = o.texture),
                    !0 === o.matrixAutoUpdate && o.updateMatrix(),
                    s.uvTransform.value.copy(o.matrix)),
                  i.envMap &&
                    ((s.envMap.value = i.envMap),
                    (s.envMapIntensity.value = i.envMapIntensity),
                    (s.flipEnvMap.value = i.envMap.isCubeTexture ? -1 : 1),
                    (s.reflectivity.value = i.reflectivity),
                    (s.refractionRatio.value = i.refractionRatio),
                    (s.maxMipLevel.value = e.properties.get(i.envMap).__maxMipLevel)),
                  s.specular.value.copy(i.specular),
                  (s.glossiness.value = i.glossiness),
                  (s.glossinessMap.value = i.glossinessMap),
                  (s.emissiveMap.value = i.emissiveMap),
                  (s.bumpMap.value = i.bumpMap),
                  (s.normalMap.value = i.normalMap),
                  (s.displacementMap.value = i.displacementMap),
                  (s.displacementScale.value = i.displacementScale),
                  (s.displacementBias.value = i.displacementBias),
                  null !== s.glossinessMap.value &&
                    void 0 === c.USE_GLOSSINESSMAP &&
                    ((c.USE_GLOSSINESSMAP = ''), (c.USE_ROUGHNESSMAP = '')),
                  null === s.glossinessMap.value &&
                    void 0 !== c.USE_GLOSSINESSMAP &&
                    (delete c.USE_GLOSSINESSMAP, delete c.USE_ROUGHNESSMAP);
              }
            },
          };
        }
        function m(e, t, r, n) {
          i.Interpolant.call(this, e, t, r, n);
        }
        (d.prototype.decodePrimitive = function (e, t) {
          var r = this.json,
            n = this.dracoLoader,
            i = e.extensions[this.name].bufferView,
            a = e.extensions[this.name].attributes,
            o = {},
            s = {},
            c = {};
          for (var u in a) u in A && (o[A[u]] = a[u]);
          for (u in e.attributes)
            if (void 0 !== A[u] && void 0 !== a[u]) {
              var l = r.accessors[e.attributes[u]],
                h = M[l.componentType];
              (c[A[u]] = h), (s[A[u]] = !0 === l.normalized);
            }
          return t.getDependency('bufferView', i).then(function (e) {
            return new Promise(function (t) {
              n.decodeDracoFile(
                e,
                function (e) {
                  for (var r in e.attributes) {
                    var n = e.attributes[r],
                      i = s[r];
                    void 0 !== i && (n.normalized = i);
                  }
                  t(e);
                },
                o,
                c,
              );
            });
          });
        }),
          (p.prototype.extendTexture = function (e, t) {
            return (
              (e = e.clone()),
              void 0 !== t.offset && e.offset.fromArray(t.offset),
              void 0 !== t.rotation && (e.rotation = t.rotation),
              void 0 !== t.scale && e.repeat.fromArray(t.scale),
              void 0 !== t.texCoord &&
                console.warn(
                  'THREE.GLTFLoader: Custom UV sets in "' +
                    this.name +
                    '" extension not yet supported.',
                ),
              (e.needsUpdate = !0),
              e
            );
          }),
          (m.prototype = Object.create(i.Interpolant.prototype)),
          (m.prototype.constructor = m),
          (m.prototype.copySampleValue_ = function (e) {
            for (
              var t = this.resultBuffer,
                r = this.sampleValues,
                n = this.valueSize,
                i = e * n * 3 + n,
                a = 0;
              a !== n;
              a++
            )
              t[a] = r[i + a];
            return t;
          }),
          (m.prototype.beforeStart_ = m.prototype.copySampleValue_),
          (m.prototype.afterEnd_ = m.prototype.copySampleValue_),
          (m.prototype.interpolate_ = function (e, t, r, n) {
            for (
              var i = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = 2 * o,
                c = 3 * o,
                u = n - t,
                l = (r - t) / u,
                h = l * l,
                d = h * l,
                p = e * c,
                f = p - c,
                m = -2 * d + 3 * h,
                v = d - h,
                g = 1 - m,
                y = v - h + l,
                x = 0;
              x !== o;
              x++
            ) {
              var b = a[f + x + o],
                w = a[f + x + s] * u,
                _ = a[p + x + o],
                M = a[p + x] * u;
              i[x] = g * b + y * w + m * _ + v * M;
            }
            return i;
          });
        var v = 0,
          g = 1,
          y = 2,
          x = 3,
          b = 4,
          w = 5,
          _ = 6,
          M =
            (Number,
            i.Matrix3,
            i.Matrix4,
            i.Vector2,
            i.Vector3,
            i.Vector4,
            i.Texture,
            {
              5120: Int8Array,
              5121: Uint8Array,
              5122: Int16Array,
              5123: Uint16Array,
              5125: Uint32Array,
              5126: Float32Array,
            }),
          S = {
            9728: i.NearestFilter,
            9729: i.LinearFilter,
            9984: i.NearestMipMapNearestFilter,
            9985: i.LinearMipMapNearestFilter,
            9986: i.NearestMipMapLinearFilter,
            9987: i.LinearMipMapLinearFilter,
          },
          E = {
            33071: i.ClampToEdgeWrapping,
            33648: i.MirroredRepeatWrapping,
            10497: i.RepeatWrapping,
          },
          T =
            (i.BackSide,
            i.FrontSide,
            i.NeverDepth,
            i.LessDepth,
            i.EqualDepth,
            i.LessEqualDepth,
            i.GreaterEqualDepth,
            i.NotEqualDepth,
            i.GreaterEqualDepth,
            i.AlwaysDepth,
            i.AddEquation,
            i.SubtractEquation,
            i.ReverseSubtractEquation,
            i.ZeroFactor,
            i.OneFactor,
            i.SrcColorFactor,
            i.OneMinusSrcColorFactor,
            i.SrcAlphaFactor,
            i.OneMinusSrcAlphaFactor,
            i.DstAlphaFactor,
            i.OneMinusDstAlphaFactor,
            i.DstColorFactor,
            i.OneMinusDstColorFactor,
            i.SrcAlphaSaturateFactor,
            { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }),
          A = {
            POSITION: 'position',
            NORMAL: 'normal',
            TEXCOORD_0: 'uv',
            TEXCOORD_1: 'uv2',
            COLOR_0: 'color',
            WEIGHTS_0: 'skinWeight',
            JOINTS_0: 'skinIndex',
          },
          L = {
            scale: 'scale',
            translation: 'position',
            rotation: 'quaternion',
            weights: 'morphTargetInfluences',
          },
          R = {
            CUBICSPLINE: i.InterpolateSmooth,
            LINEAR: i.InterpolateLinear,
            STEP: i.InterpolateDiscrete,
          },
          C = 'OPAQUE',
          P = 'MASK',
          O = 'BLEND',
          I = { 'image/png': i.RGBAFormat, 'image/jpeg': i.RGBFormat };
        function D(e, t) {
          return 'string' != typeof e || '' === e
            ? ''
            : /^(https?:)?\/\//i.test(e)
            ? e
            : /^data:.*,.*$/i.test(e)
            ? e
            : /^blob:.*$/i.test(e)
            ? e
            : t + e;
        }
        function B(e, t, r) {
          for (var n in r.extensions)
            void 0 === e[n] &&
              ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
              (t.userData.gltfExtensions[n] = r.extensions[n]));
        }
        function N(e, t) {
          void 0 !== t.extras &&
            ('object' === n(t.extras)
              ? (e.userData = t.extras)
              : console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + t.extras));
        }
        function U(e, t) {
          if ((e.updateMorphTargets(), void 0 !== t.weights))
            for (var r = 0, n = t.weights.length; r < n; r++)
              e.morphTargetInfluences[r] = t.weights[r];
          if (t.extras && Array.isArray(t.extras.targetNames)) {
            var i = t.extras.targetNames;
            if (e.morphTargetInfluences.length === i.length) {
              e.morphTargetDictionary = {};
              for (r = 0, n = i.length; r < n; r++) e.morphTargetDictionary[i[r]] = r;
            } else
              console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
          }
        }
        function G(e, t) {
          if (Object.keys(e).length !== Object.keys(t).length) return !1;
          for (var r in e) if (e[r] !== t[r]) return !1;
          return !0;
        }
        function F(e, t) {
          if (e.length !== t.length) return !1;
          for (var r = 0, n = e.length; r < n; r++) if (e[r] !== t[r]) return !1;
          return !0;
        }
        function z(e, t) {
          for (var n = 0, i = e.length; n < i; n++) {
            var a = e[n];
            if (
              ((o = a.primitive),
              (s = t),
              (c = void 0),
              (u = void 0),
              (c = o.extensions ? o.extensions[r.KHR_DRACO_MESH_COMPRESSION] : void 0),
              (u = s.extensions ? s.extensions[r.KHR_DRACO_MESH_COMPRESSION] : void 0),
              c && u
                ? c.bufferView === u.bufferView && G(c.attributes, u.attributes)
                : o.indices === s.indices && G(o.attributes, s.attributes))
            )
              return a.promise;
          }
          var o, s, c, u;
          return null;
        }
        function H(e) {
          if (e.isInterleavedBufferAttribute) {
            for (var t = e.count, r = e.itemSize, n = e.array.slice(0, t * r), a = 0; a < t; ++a)
              (n[a] = e.getX(a)),
                r >= 2 && (n[a + 1] = e.getY(a)),
                r >= 3 && (n[a + 2] = e.getZ(a)),
                r >= 4 && (n[a + 3] = e.getW(a));
            return new i.BufferAttribute(n, r, e.normalized);
          }
          return e.clone();
        }
        function k(e, r, n) {
          (this.json = e || {}),
            (this.extensions = r || {}),
            (this.options = n || {}),
            (this.cache = new t()),
            (this.primitiveCache = []),
            (this.multiplePrimitivesCache = []),
            (this.multiPassGeometryCache = []),
            (this.textureLoader = new i.TextureLoader(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            (this.fileLoader = new i.FileLoader(this.options.manager)),
            this.fileLoader.setResponseType('arraybuffer');
        }
        function V(e, t, r) {
          var n = t.attributes,
            i = [];
          function a(t, n) {
            return r.getDependency('accessor', t).then(function (t) {
              e.addAttribute(n, t);
            });
          }
          for (var o in n) {
            var s = A[o];
            s && (s in e.attributes || i.push(a(n[o], s)));
          }
          if (void 0 !== t.indices && !e.index) {
            var c = r.getDependency('accessor', t.indices).then(function (t) {
              e.setIndex(t);
            });
            i.push(c);
          }
          return (
            N(e, t),
            Promise.all(i).then(function () {
              return void 0 !== t.targets
                ? (function (e, t, r) {
                    for (
                      var n = !1, i = !1, a = 0, o = t.length;
                      a < o &&
                      (void 0 !== (u = t[a]).POSITION && (n = !0),
                      void 0 !== u.NORMAL && (i = !0),
                      !n || !i);
                      a++
                    );
                    if (!n && !i) return Promise.resolve(e);
                    var s = [],
                      c = [];
                    for (a = 0, o = t.length; a < o; a++) {
                      var u = t[a];
                      if (n) {
                        var l =
                          void 0 !== u.POSITION
                            ? r.getDependency('accessor', u.POSITION).then(function (e) {
                                return H(e);
                              })
                            : e.attributes.position;
                        s.push(l);
                      }
                      i &&
                        ((l =
                          void 0 !== u.NORMAL
                            ? r.getDependency('accessor', u.NORMAL).then(function (e) {
                                return H(e);
                              })
                            : e.attributes.normal),
                        c.push(l));
                    }
                    return Promise.all([Promise.all(s), Promise.all(c)]).then(function (r) {
                      for (var a = r[0], o = r[1], s = 0, c = t.length; s < c; s++) {
                        var u = t[s],
                          l = 'morphTarget' + s;
                        if (n && void 0 !== u.POSITION) {
                          var h = a[s];
                          h.name = l;
                          for (var d = e.attributes.position, p = 0, f = h.count; p < f; p++)
                            h.setXYZ(
                              p,
                              h.getX(p) + d.getX(p),
                              h.getY(p) + d.getY(p),
                              h.getZ(p) + d.getZ(p),
                            );
                        }
                        if (i && void 0 !== u.NORMAL) {
                          var m = o[s];
                          m.name = l;
                          var v = e.attributes.normal;
                          for (p = 0, f = m.count; p < f; p++)
                            m.setXYZ(
                              p,
                              m.getX(p) + v.getX(p),
                              m.getY(p) + v.getY(p),
                              m.getZ(p) + v.getZ(p),
                            );
                        }
                      }
                      return (
                        n && (e.morphAttributes.position = a),
                        i && (e.morphAttributes.normal = o),
                        e
                      );
                    });
                  })(e, t.targets, r)
                : e;
            })
          );
        }
        return (
          (k.prototype.parse = function (e, t) {
            var r = this.json;
            this.cache.removeAll(),
              this.markDefs(),
              this.getMultiDependencies(['scene', 'animation', 'camera'])
                .then(function (t) {
                  var n = t.scenes || [],
                    i = n[r.scene || 0],
                    a = t.animations || [],
                    o = t.cameras || [];
                  e(i, n, o, a, r);
                })
                .catch(t);
          }),
          (k.prototype.markDefs = function () {
            for (
              var e = this.json.nodes || [],
                t = this.json.skins || [],
                r = this.json.meshes || [],
                n = {},
                i = {},
                a = 0,
                o = t.length;
              a < o;
              a++
            )
              for (var s = t[a].joints, c = 0, u = s.length; c < u; c++) e[s[c]].isBone = !0;
            for (var l = 0, h = e.length; l < h; l++) {
              var d = e[l];
              void 0 !== d.mesh &&
                (void 0 === n[d.mesh] && (n[d.mesh] = i[d.mesh] = 0),
                n[d.mesh]++,
                void 0 !== d.skin && (r[d.mesh].isSkinnedMesh = !0));
            }
            (this.json.meshReferences = n), (this.json.meshUses = i);
          }),
          (k.prototype.getDependency = function (e, t) {
            var n = e + ':' + t,
              i = this.cache.get(n);
            if (!i) {
              switch (e) {
                case 'scene':
                  i = this.loadScene(t);
                  break;
                case 'node':
                  i = this.loadNode(t);
                  break;
                case 'mesh':
                  i = this.loadMesh(t);
                  break;
                case 'accessor':
                  i = this.loadAccessor(t);
                  break;
                case 'bufferView':
                  i = this.loadBufferView(t);
                  break;
                case 'buffer':
                  i = this.loadBuffer(t);
                  break;
                case 'material':
                  i = this.loadMaterial(t);
                  break;
                case 'texture':
                  i = this.loadTexture(t);
                  break;
                case 'skin':
                  i = this.loadSkin(t);
                  break;
                case 'animation':
                  i = this.loadAnimation(t);
                  break;
                case 'camera':
                  i = this.loadCamera(t);
                  break;
                case 'light':
                  i = this.extensions[r.KHR_LIGHTS_PUNCTUAL].loadLight(t);
                  break;
                default:
                  throw new Error('Unknown type: ' + e);
              }
              this.cache.add(n, i);
            }
            return i;
          }),
          (k.prototype.getDependencies = function (e) {
            var t = this.cache.get(e);
            if (!t) {
              var r = this,
                n = this.json[e + ('mesh' === e ? 'es' : 's')] || [];
              (t = Promise.all(
                n.map(function (t, n) {
                  return r.getDependency(e, n);
                }),
              )),
                this.cache.add(e, t);
            }
            return t;
          }),
          (k.prototype.getMultiDependencies = function (e) {
            for (var t = {}, r = [], n = 0, i = e.length; n < i; n++) {
              var a = e[n],
                o = this.getDependencies(a);
              (o = o.then(
                function (e, r) {
                  t[e] = r;
                }.bind(this, a + ('mesh' === a ? 'es' : 's')),
              )),
                r.push(o);
            }
            return Promise.all(r).then(function () {
              return t;
            });
          }),
          (k.prototype.loadBuffer = function (e) {
            var t = this.json.buffers[e],
              n = this.fileLoader;
            if (t.type && 'arraybuffer' !== t.type)
              throw new Error('THREE.GLTFLoader: ' + t.type + ' buffer type is not supported.');
            if (void 0 === t.uri && 0 === e)
              return Promise.resolve(this.extensions[r.KHR_BINARY_GLTF].body);
            var i = this.options;
            return new Promise(function (e, r) {
              n.load(D(t.uri, i.path), e, void 0, function () {
                r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
              });
            });
          }),
          (k.prototype.loadBufferView = function (e) {
            var t = this.json.bufferViews[e];
            return this.getDependency('buffer', t.buffer).then(function (e) {
              var r = t.byteLength || 0,
                n = t.byteOffset || 0;
              return e.slice(n, n + r);
            });
          }),
          (k.prototype.loadAccessor = function (e) {
            var t = this,
              r = this.json,
              n = this.json.accessors[e];
            if (void 0 === n.bufferView && void 0 === n.sparse) return Promise.resolve(null);
            var a = [];
            return (
              void 0 !== n.bufferView
                ? a.push(this.getDependency('bufferView', n.bufferView))
                : a.push(null),
              void 0 !== n.sparse &&
                (a.push(this.getDependency('bufferView', n.sparse.indices.bufferView)),
                a.push(this.getDependency('bufferView', n.sparse.values.bufferView))),
              Promise.all(a).then(function (e) {
                var a,
                  o,
                  s = e[0],
                  c = T[n.type],
                  u = M[n.componentType],
                  l = u.BYTES_PER_ELEMENT,
                  h = l * c,
                  d = n.byteOffset || 0,
                  p = void 0 !== n.bufferView ? r.bufferViews[n.bufferView].byteStride : void 0,
                  f = !0 === n.normalized;
                if (p && p !== h) {
                  var m = 'InterleavedBuffer:' + n.bufferView + ':' + n.componentType,
                    v = t.cache.get(m);
                  v || ((a = new u(s)), (v = new i.InterleavedBuffer(a, p / l)), t.cache.add(m, v)),
                    (o = new i.InterleavedBufferAttribute(v, c, d / l, f));
                } else (a = null === s ? new u(n.count * c) : new u(s, d, n.count * c)), (o = new i.BufferAttribute(a, c, f));
                if (void 0 !== n.sparse) {
                  var g = T.SCALAR,
                    y = M[n.sparse.indices.componentType],
                    x = n.sparse.indices.byteOffset || 0,
                    b = n.sparse.values.byteOffset || 0,
                    w = new y(e[1], x, n.sparse.count * g),
                    _ = new u(e[2], b, n.sparse.count * c);
                  null !== s && o.setArray(o.array.slice());
                  for (var S = 0, E = w.length; S < E; S++) {
                    var A = w[S];
                    if (
                      (o.setX(A, _[S * c]),
                      c >= 2 && o.setY(A, _[S * c + 1]),
                      c >= 3 && o.setZ(A, _[S * c + 2]),
                      c >= 4 && o.setW(A, _[S * c + 3]),
                      c >= 5)
                    )
                      throw new Error(
                        'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.',
                      );
                  }
                }
                return o;
              })
            );
          }),
          (k.prototype.loadTexture = function (e) {
            var t,
              n = this,
              a = this.json,
              o = this.options,
              s = this.textureLoader,
              c = window.URL || window.webkitURL,
              u = a.textures[e],
              l = u.extensions || {},
              h = (t = l[r.MSFT_TEXTURE_DDS]
                ? a.images[l[r.MSFT_TEXTURE_DDS].source]
                : a.images[u.source]).uri,
              d = !1;
            return (
              void 0 !== t.bufferView &&
                (h = n.getDependency('bufferView', t.bufferView).then(function (e) {
                  d = !0;
                  var r = new Blob([e], { type: t.mimeType });
                  return (h = c.createObjectURL(r));
                })),
              Promise.resolve(h)
                .then(function (e) {
                  var t = i.Loader.Handlers.get(e);
                  return (
                    t ||
                      (t = l[r.MSFT_TEXTURE_DDS] ? n.extensions[r.MSFT_TEXTURE_DDS].ddsLoader : s),
                    new Promise(function (r, n) {
                      t.load(D(e, o.path), r, void 0, n);
                    })
                  );
                })
                .then(function (e) {
                  !0 === d && c.revokeObjectURL(h),
                    (e.flipY = !1),
                    void 0 !== u.name && (e.name = u.name),
                    t.mimeType in I && (e.format = I[t.mimeType]);
                  var r = (a.samplers || {})[u.sampler] || {};
                  return (
                    (e.magFilter = S[r.magFilter] || i.LinearFilter),
                    (e.minFilter = S[r.minFilter] || i.LinearMipMapLinearFilter),
                    (e.wrapS = E[r.wrapS] || i.RepeatWrapping),
                    (e.wrapT = E[r.wrapT] || i.RepeatWrapping),
                    e
                  );
                })
            );
          }),
          (k.prototype.assignTexture = function (e, t, n) {
            var i = this;
            return this.getDependency('texture', n.index).then(function (a) {
              if (i.extensions[r.KHR_TEXTURE_TRANSFORM]) {
                var o = void 0 !== n.extensions ? n.extensions[r.KHR_TEXTURE_TRANSFORM] : void 0;
                o && (a = i.extensions[r.KHR_TEXTURE_TRANSFORM].extendTexture(a, o));
              }
              e[t] = a;
            });
          }),
          (k.prototype.loadMaterial = function (e) {
            var t,
              n = this.json,
              a = this.extensions,
              o = n.materials[e],
              s = {},
              c = o.extensions || {},
              u = [];
            if (c[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
              var l = a[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
              (t = l.getMaterialType(o)), u.push(l.extendParams(s, o, this));
            } else if (c[r.KHR_MATERIALS_UNLIT]) {
              var h = a[r.KHR_MATERIALS_UNLIT];
              (t = h.getMaterialType(o)), u.push(h.extendParams(s, o, this));
            } else {
              t = i.MeshStandardMaterial;
              var d = o.pbrMetallicRoughness || {};
              if (
                ((s.color = new i.Color(1, 1, 1)),
                (s.opacity = 1),
                Array.isArray(d.baseColorFactor))
              ) {
                var p = d.baseColorFactor;
                s.color.fromArray(p), (s.opacity = p[3]);
              }
              void 0 !== d.baseColorTexture &&
                u.push(this.assignTexture(s, 'map', d.baseColorTexture)),
                (s.metalness = void 0 !== d.metallicFactor ? d.metallicFactor : 1),
                (s.roughness = void 0 !== d.roughnessFactor ? d.roughnessFactor : 1),
                void 0 !== d.metallicRoughnessTexture &&
                  (u.push(this.assignTexture(s, 'metalnessMap', d.metallicRoughnessTexture)),
                  u.push(this.assignTexture(s, 'roughnessMap', d.metallicRoughnessTexture)));
            }
            !0 === o.doubleSided && (s.side = i.DoubleSide);
            var f = o.alphaMode || C;
            return (
              f === O
                ? (s.transparent = !0)
                : ((s.transparent = !1),
                  f === P && (s.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : 0.5)),
              void 0 !== o.normalTexture &&
                t !== i.MeshBasicMaterial &&
                (u.push(this.assignTexture(s, 'normalMap', o.normalTexture)),
                (s.normalScale = new i.Vector2(1, 1)),
                void 0 !== o.normalTexture.scale &&
                  s.normalScale.set(o.normalTexture.scale, o.normalTexture.scale)),
              void 0 !== o.occlusionTexture &&
                t !== i.MeshBasicMaterial &&
                (u.push(this.assignTexture(s, 'aoMap', o.occlusionTexture)),
                void 0 !== o.occlusionTexture.strength &&
                  (s.aoMapIntensity = o.occlusionTexture.strength)),
              void 0 !== o.emissiveFactor &&
                t !== i.MeshBasicMaterial &&
                (s.emissive = new i.Color().fromArray(o.emissiveFactor)),
              void 0 !== o.emissiveTexture &&
                t !== i.MeshBasicMaterial &&
                u.push(this.assignTexture(s, 'emissiveMap', o.emissiveTexture)),
              Promise.all(u).then(function () {
                var e;
                return (
                  (e =
                    t === i.ShaderMaterial
                      ? a[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s)
                      : new t(s)),
                  void 0 !== o.name && (e.name = o.name),
                  e.normalScale && (e.normalScale.y = -e.normalScale.y),
                  e.map && (e.map.encoding = i.sRGBEncoding),
                  e.emissiveMap && (e.emissiveMap.encoding = i.sRGBEncoding),
                  e.specularMap && (e.specularMap.encoding = i.sRGBEncoding),
                  N(e, o),
                  o.extensions && B(a, e, o),
                  e
                );
              })
            );
          }),
          (k.prototype.loadGeometries = function (e) {
            var t,
              n = this,
              a = this.extensions,
              o = this.primitiveCache,
              s = (function (e) {
                if (e.length < 2) return !1;
                var t = e[0],
                  n = t.targets || [];
                if (void 0 === t.indices) return !1;
                for (var i = 1, a = e.length; i < a; i++) {
                  var o = e[i];
                  if (t.mode !== o.mode) return !1;
                  if (void 0 === o.indices) return !1;
                  if (o.extensions && o.extensions[r.KHR_DRACO_MESH_COMPRESSION]) return !1;
                  if (!G(t.attributes, o.attributes)) return !1;
                  var s = o.targets || [];
                  if (n.length !== s.length) return !1;
                  for (var c = 0, u = n.length; c < u; c++) if (!G(n[c], s[c])) return !1;
                }
                return !0;
              })(e);
            function c(e) {
              return a[r.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, n).then(function (t) {
                return V(t, e, n);
              });
            }
            s && ((t = e), (e = [e[0]]));
            for (var u = [], l = 0, h = e.length; l < h; l++) {
              var d,
                p = e[l],
                f = z(o, p);
              if (f) u.push(f);
              else
                (d =
                  p.extensions && p.extensions[r.KHR_DRACO_MESH_COMPRESSION]
                    ? c(p)
                    : V(new i.BufferGeometry(), p, n)),
                  o.push({ primitive: p, promise: d }),
                  u.push(d);
            }
            return Promise.all(u).then(function (e) {
              if (s) {
                var r = e[0];
                if (
                  null !==
                  (d = (function (e, t, r) {
                    for (var n = 0, i = e.length; n < i; n++) {
                      var a = e[n];
                      if (t === a.baseGeometry && F(r, a.primitives)) return a.geometry;
                    }
                    return null;
                  })((h = n.multiPassGeometryCache), r, t))
                )
                  return [d.geometry];
                var a = new i.BufferGeometry();
                for (var o in ((a.name = r.name), (a.userData = r.userData), r.attributes))
                  a.addAttribute(o, r.attributes[o]);
                for (var o in r.morphAttributes) a.morphAttributes[o] = r.morphAttributes[o];
                for (var c = [], u = 0, l = t.length; u < l; u++)
                  c.push(n.getDependency('accessor', t[u].indices));
                return Promise.all(c).then(function (e) {
                  for (var n = [], i = 0, o = 0, s = t.length; o < s; o++) {
                    for (var c = e[o], u = 0, l = c.count; u < l; u++) n.push(c.array[u]);
                    a.addGroup(i, c.count, o), (i += c.count);
                  }
                  return (
                    a.setIndex(n), h.push({ geometry: a, baseGeometry: r, primitives: t }), [a]
                  );
                });
              }
              var h, d;
              return e.length > 1 && i.BufferGeometryUtils, e;
            });
          }),
          (k.prototype.loadMesh = function (e) {
            for (
              var t = this,
                n = this.json,
                a = this.extensions,
                o = n.meshes[e],
                s = o.primitives,
                c = [],
                u = 0,
                l = s.length;
              u < l;
              u++
            ) {
              var h =
                void 0 === s[u].material
                  ? new i.MeshStandardMaterial({
                      color: 16777215,
                      emissive: 0,
                      metalness: 1,
                      roughness: 1,
                      transparent: !1,
                      depthTest: !0,
                      side: i.FrontSide,
                    })
                  : this.getDependency('material', s[u].material);
              c.push(h);
            }
            return Promise.all(c).then(function (n) {
              return t.loadGeometries(s).then(function (c) {
                for (
                  var u = 1 === c.length && c[0].groups.length > 0, l = [], h = 0, d = c.length;
                  h < d;
                  h++
                ) {
                  var p,
                    f = c[h],
                    m = s[h],
                    M = u ? n : n[h];
                  if (m.mode === b || m.mode === w || m.mode === _ || void 0 === m.mode)
                    !0 ===
                      (p = !0 === o.isSkinnedMesh ? new i.SkinnedMesh(f, M) : new i.Mesh(f, M))
                        .isSkinnedMesh && p.normalizeSkinWeights(),
                      m.mode === w
                        ? (p.drawMode = i.TriangleStripDrawMode)
                        : m.mode === _ && (p.drawMode = i.TriangleFanDrawMode);
                  else if (m.mode === g) p = new i.LineSegments(f, M);
                  else if (m.mode === x) p = new i.Line(f, M);
                  else if (m.mode === y) p = new i.LineLoop(f, M);
                  else {
                    if (m.mode !== v)
                      throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + m.mode);
                    p = new i.Points(f, M);
                  }
                  Object.keys(p.geometry.morphAttributes).length > 0 && U(p, o),
                    (p.name = o.name || 'mesh_' + e),
                    c.length > 1 && (p.name += '_' + h),
                    N(p, o),
                    l.push(p);
                  for (
                    var S = u ? p.material : [p.material],
                      E = void 0 !== f.attributes.color,
                      T = void 0 === f.attributes.normal,
                      A = !0 === p.isSkinnedMesh,
                      L = Object.keys(f.morphAttributes).length > 0,
                      R = L && void 0 !== f.morphAttributes.normal,
                      C = 0,
                      P = S.length;
                    C < P;
                    C++
                  ) {
                    M = S[C];
                    if (p.isPoints) {
                      var O = 'PointsMaterial:' + M.uuid,
                        I = t.cache.get(O);
                      I ||
                        ((I = new i.PointsMaterial()),
                        i.Material.prototype.copy.call(I, M),
                        I.color.copy(M.color),
                        (I.map = M.map),
                        (I.lights = !1),
                        t.cache.add(O, I)),
                        (M = I);
                    } else if (p.isLine) {
                      O = 'LineBasicMaterial:' + M.uuid;
                      var D = t.cache.get(O);
                      D ||
                        ((D = new i.LineBasicMaterial()),
                        i.Material.prototype.copy.call(D, M),
                        D.color.copy(M.color),
                        (D.lights = !1),
                        t.cache.add(O, D)),
                        (M = D);
                    }
                    if (E || T || A || L) {
                      O = 'ClonedMaterial:' + M.uuid + ':';
                      M.isGLTFSpecularGlossinessMaterial && (O += 'specular-glossiness:'),
                        A && (O += 'skinning:'),
                        E && (O += 'vertex-colors:'),
                        T && (O += 'flat-shading:'),
                        L && (O += 'morph-targets:'),
                        R && (O += 'morph-normals:');
                      var B = t.cache.get(O);
                      B ||
                        ((B = M.isGLTFSpecularGlossinessMaterial
                          ? a[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(M)
                          : M.clone()),
                        A && (B.skinning = !0),
                        E && (B.vertexColors = i.VertexColors),
                        T && (B.flatShading = !0),
                        L && (B.morphTargets = !0),
                        R && (B.morphNormals = !0),
                        t.cache.add(O, B)),
                        (M = B);
                    }
                    (S[C] = M),
                      M.aoMap &&
                        void 0 === f.attributes.uv2 &&
                        void 0 !== f.attributes.uv &&
                        (console.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.'),
                        f.addAttribute('uv2', new i.BufferAttribute(f.attributes.uv.array, 2))),
                      M.isGLTFSpecularGlossinessMaterial &&
                        (p.onBeforeRender =
                          a[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms);
                  }
                  p.material = u ? S : S[0];
                }
                if (1 === l.length) return l[0];
                var G = new i.Group();
                for (h = 0, d = l.length; h < d; h++) G.add(l[h]);
                return G;
              });
            });
          }),
          (k.prototype.loadCamera = function (e) {
            var t,
              r = this.json.cameras[e],
              n = r[r.type];
            if (n)
              return (
                'perspective' === r.type
                  ? (t = new i.PerspectiveCamera(
                      i.Math.radToDeg(n.yfov),
                      n.aspectRatio || 1,
                      n.znear || 1,
                      n.zfar || 2e6,
                    ))
                  : 'orthographic' === r.type &&
                    (t = new i.OrthographicCamera(
                      n.xmag / -2,
                      n.xmag / 2,
                      n.ymag / 2,
                      n.ymag / -2,
                      n.znear,
                      n.zfar,
                    )),
                void 0 !== r.name && (t.name = r.name),
                N(t, r),
                Promise.resolve(t)
              );
            console.warn('THREE.GLTFLoader: Missing camera parameters.');
          }),
          (k.prototype.loadSkin = function (e) {
            var t = this.json.skins[e],
              r = { joints: t.joints };
            return void 0 === t.inverseBindMatrices
              ? Promise.resolve(r)
              : this.getDependency('accessor', t.inverseBindMatrices).then(function (e) {
                  return (r.inverseBindMatrices = e), r;
                });
          }),
          (k.prototype.loadAnimation = function (e) {
            for (
              var t = this.json.animations[e],
                r = [],
                n = [],
                a = [],
                o = [],
                s = [],
                c = 0,
                u = t.channels.length;
              c < u;
              c++
            ) {
              var l = t.channels[c],
                h = t.samplers[l.sampler],
                d = l.target,
                p = void 0 !== d.node ? d.node : d.id,
                f = void 0 !== t.parameters ? t.parameters[h.input] : h.input,
                v = void 0 !== t.parameters ? t.parameters[h.output] : h.output;
              r.push(this.getDependency('node', p)),
                n.push(this.getDependency('accessor', f)),
                a.push(this.getDependency('accessor', v)),
                o.push(h),
                s.push(d);
            }
            return Promise.all([
              Promise.all(r),
              Promise.all(n),
              Promise.all(a),
              Promise.all(o),
              Promise.all(s),
            ]).then(function (r) {
              for (
                var n = r[0], a = r[1], o = r[2], s = r[3], c = r[4], u = [], l = 0, h = n.length;
                l < h;
                l++
              ) {
                var d = n[l],
                  p = a[l],
                  f = o[l],
                  v = s[l],
                  g = c[l];
                if (void 0 !== d) {
                  var y;
                  switch ((d.updateMatrix(), (d.matrixAutoUpdate = !0), L[g.path])) {
                    case L.weights:
                      y = i.NumberKeyframeTrack;
                      break;
                    case L.rotation:
                      y = i.QuaternionKeyframeTrack;
                      break;
                    case L.position:
                    case L.scale:
                    default:
                      y = i.VectorKeyframeTrack;
                  }
                  var x = d.name ? d.name : d.uuid,
                    b = void 0 !== v.interpolation ? R[v.interpolation] : i.InterpolateLinear,
                    w = [];
                  L[g.path] === L.weights
                    ? d.traverse(function (e) {
                        !0 === e.isMesh &&
                          e.morphTargetInfluences &&
                          w.push(e.name ? e.name : e.uuid);
                      })
                    : w.push(x);
                  for (var _ = 0, M = w.length; _ < M; _++) {
                    var S = new y(
                      w[_] + '.' + L[g.path],
                      i.AnimationUtils.arraySlice(p.array, 0),
                      i.AnimationUtils.arraySlice(f.array, 0),
                      b,
                    );
                    'CUBICSPLINE' === v.interpolation &&
                      ((S.createInterpolant = function (e) {
                        return new m(this.times, this.values, this.getValueSize() / 3, e);
                      }),
                      (S.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0)),
                      u.push(S);
                  }
                }
              }
              var E = void 0 !== t.name ? t.name : 'animation_' + e;
              return new i.AnimationClip(E, void 0, u);
            });
          }),
          (k.prototype.loadNode = function (e) {
            var t = this.json,
              n = this.extensions,
              a = this,
              o = t.meshReferences,
              s = t.meshUses,
              c = t.nodes[e];
            return new Promise(function (e) {
              !0 === c.isBone
                ? e(new i.Bone())
                : void 0 !== c.mesh
                ? a.getDependency('mesh', c.mesh).then(function (t) {
                    var r;
                    if (o[c.mesh] > 1) {
                      var n = s[c.mesh]++;
                      ((r = t.clone()).name += '_instance_' + n),
                        (r.onBeforeRender = t.onBeforeRender);
                      for (var i = 0, a = r.children.length; i < a; i++)
                        (r.children[i].name += '_instance_' + n),
                          (r.children[i].onBeforeRender = t.children[i].onBeforeRender);
                    } else r = t;
                    e(r);
                  })
                : void 0 !== c.camera
                ? a.getDependency('camera', c.camera).then(e)
                : c.extensions &&
                  c.extensions[r.KHR_LIGHTS_PUNCTUAL] &&
                  void 0 !== c.extensions[r.KHR_LIGHTS_PUNCTUAL].light
                ? a.getDependency('light', c.extensions[r.KHR_LIGHTS_PUNCTUAL].light).then(e)
                : e(new i.Object3D());
            }).then(function (e) {
              if (
                (void 0 !== c.name && (e.name = i.PropertyBinding.sanitizeNodeName(c.name)),
                N(e, c),
                c.extensions && B(n, e, c),
                void 0 !== c.matrix)
              ) {
                var t = new i.Matrix4();
                t.fromArray(c.matrix), e.applyMatrix(t);
              } else void 0 !== c.translation && e.position.fromArray(c.translation), void 0 !== c.rotation && e.quaternion.fromArray(c.rotation), void 0 !== c.scale && e.scale.fromArray(c.scale);
              return e;
            });
          }),
          (k.prototype.loadScene = (function () {
            function e(t, r, n, a) {
              var o = n.nodes[t];
              return a
                .getDependency('node', t)
                .then(function (e) {
                  return void 0 === o.skin
                    ? e
                    : a
                        .getDependency('skin', o.skin)
                        .then(function (e) {
                          for (var r = [], n = 0, i = (t = e).joints.length; n < i; n++)
                            r.push(a.getDependency('node', t.joints[n]));
                          return Promise.all(r);
                        })
                        .then(function (r) {
                          for (
                            var n = !0 === e.isGroup ? e.children : [e], a = 0, o = n.length;
                            a < o;
                            a++
                          ) {
                            for (var s = n[a], c = [], u = [], l = 0, h = r.length; l < h; l++) {
                              var d = r[l];
                              if (d) {
                                c.push(d);
                                var p = new i.Matrix4();
                                void 0 !== t.inverseBindMatrices &&
                                  p.fromArray(t.inverseBindMatrices.array, 16 * l),
                                  u.push(p);
                              } else
                                console.warn(
                                  'THREE.GLTFLoader: Joint "%s" could not be found.',
                                  t.joints[l],
                                );
                            }
                            s.bind(new i.Skeleton(c, u), s.matrixWorld);
                          }
                          return e;
                        });
                  var t;
                })
                .then(function (t) {
                  r.add(t);
                  var i = [];
                  if (o.children)
                    for (var s = o.children, c = 0, u = s.length; c < u; c++) {
                      var l = s[c];
                      i.push(e(l, t, n, a));
                    }
                  return Promise.all(i);
                });
            }
            return function (t) {
              var r = this.json,
                n = this.extensions,
                a = this.json.scenes[t],
                o = new i.Scene();
              void 0 !== a.name && (o.name = a.name), N(o, a), a.extensions && B(n, o, a);
              for (var s = a.nodes || [], c = [], u = 0, l = s.length; u < l; u++)
                c.push(e(s[u], o, r, this));
              return Promise.all(c).then(function () {
                return o;
              });
            };
          })()),
          e
        );
      })();
    },
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: !0 });
      var n = (function () {
          function e(e, t) {
            for (var r = 0; r < t.length; r++) {
              var n = t[r];
              (n.enumerable = n.enumerable || !1),
                (n.configurable = !0),
                'value' in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n);
            }
          }
          return function (t, r, n) {
            return r && e(t.prototype, r), n && e(t, n), t;
          };
        })(),
        i = (function (e) {
          if (e && e.__esModule) return e;
          var t = {};
          if (null != e)
            for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
          return (t.default = e), t;
        })(r(0)),
        a = s(r(1)),
        o = s(r(13));
      function s(e) {
        return e && e.__esModule ? e : { default: e };
      }
      r(2), r(3), r(4);
      var c = (function () {
        function e(t, r, n) {
          !(function (e, t) {
            if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
          })(this, e),
            (this.scene = new i.Scene()),
            (this.inverted = n || !1),
            (this.container = document.getElementById(t)),
            (this.onLoad = r.onLoad),
            (this.onClick = r.onClick),
            (this.surfaceColor = r.surface),
            (this.insideColor = r.inside),
            (this.backgroundColor = r.background),
            (this.surfaceColor = new i.Color(parseInt('0x' + this.surfaceColor))),
            (this.insideColor = new i.Color(parseInt('0x' + this.insideColor))),
            (this.raycaster = new i.Raycaster()),
            (this.renderer = new i.WebGLRenderer({
              antialias: !0,
              alpha: 'transparent' === this.backgroundColor,
            })),
            'transparent' === this.backgroundColor
              ? this.renderer.setClearColor(0, 0)
              : ((this.backgroundColor = parseInt('0x' + this.backgroundColor, 16)),
                this.renderer.setClearColor(this.backgroundColor, 1)),
            this.renderer.setPixelRatio(window.devicePixelRatio),
            (this.width = window.innerWidth),
            (this.height = window.innerHeight),
            (this.mouseX = 0),
            (this.mouseY = 0),
            (this.targetmouseX = 0),
            (this.targetmouseY = 0),
            this.renderer.setSize(this.width, this.height),
            this.container.appendChild(this.renderer.domElement),
            (this.camera = new i.PerspectiveCamera(
              70,
              window.innerWidth / window.innerHeight,
              0.001,
              1e3,
            )),
            this.camera.position.set(0, 0, 7),
            (this.time = 0),
            (this.loader = new i.GLTFLoader().setPath('js/')),
            i.DRACOLoader.setDecoderPath('js/lib/draco/'),
            this.loader.setDRACOLoader(new i.DRACOLoader()),
            this.setupResize(),
            this.setupcubeTexture(),
            this.resize(),
            this.addObjects(),
            this.animate(),
            this.load(),
            this.settings();
        }
        return (
          n(e, [
            {
              key: 'settings',
              value: function () {
                this.settings = { progress: 0 };
              },
            },
            {
              key: 'load',
              value: function () {
                var e = this;
                new i.Vector3(0, 0, 0);
                (this.voron = []),
                  this.loader.load(
                    'ico-more.glb',
                    function (t) {
                      t.scene.traverse(function (t) {
                        t.isMesh,
                          'Voronoi_Fracture' === t.name &&
                            ((e.obj = t),
                            t.children[0].children.length > 2
                              ? t.children.forEach(function (t) {
                                  t.children.forEach(function (t) {
                                    e.voron.push(t.clone());
                                  });
                                })
                              : t.children.forEach(function (t) {
                                  e.voron.push(t.clone());
                                }));
                      }),
                        (e.geoms = []),
                        (e.geoms1 = []);
                      var r = 0;
                      e.voron = e.voron.filter(function (t) {
                        if (t.isMesh) return !1;
                        r++;
                        var n = e.processSurface(t, r);
                        return (
                          e.inverted
                            ? (e.geoms1.push(n.surface), e.geoms.push(n.volume))
                            : (e.geoms.push(n.surface), e.geoms1.push(n.volume)),
                          !0
                        );
                      });
                      var n = i.BufferGeometryUtils.mergeBufferGeometries(e.geoms, !1);
                      (e.mesh = new i.Mesh(n, e.material)), e.scene.add(e.mesh);
                      var a = i.BufferGeometryUtils.mergeBufferGeometries(e.geoms1, !1);
                      (e.mesh1 = new i.Mesh(a, e.material1)), e.scene.add(e.mesh1), e.onLoad();
                    },
                    void 0,
                    function (e) {
                      console.error(e);
                    },
                  );
              },
            },
            {
              key: 'processSurface',
              value: function (e, t) {
                var r = e.position,
                  n = void 0,
                  a = void 0;
                (n = (n = e.children[0].geometry.clone()).applyMatrix(
                  new i.Matrix4().makeTranslation(r.x, r.y, r.z),
                )),
                  (a = (a = e.children[1].geometry)
                    .clone()
                    .applyMatrix(new i.Matrix4().makeTranslation(r.x, r.y, r.z)));
                var o = e.children[0].geometry.attributes.position.array.length / 3,
                  s = e.children[1].geometry.attributes.position.array.length / 3,
                  c = new Array(o).fill(t / 100);
                n.addAttribute('offset', new i.BufferAttribute(new Float32Array(c), 1));
                var u = new Array(s).fill(t / 100);
                a.addAttribute('offset', new i.BufferAttribute(new Float32Array(u), 1));
                for (
                  var l = new i.Vector3(
                      Math.random() - 0.5,
                      Math.random() - 0.5,
                      Math.random() - 0.5,
                    ).normalize(),
                    h = new Array(3 * o).fill(0),
                    d = new Array(3 * s).fill(0),
                    p = 0;
                  p < 3 * o;
                  p += 3
                )
                  (h[p] = l.x), (h[p + 1] = l.y), (h[p + 2] = l.z);
                n.addAttribute('axis', new i.BufferAttribute(new Float32Array(h), 3));
                for (var f = 0; f < 3 * s; f += 3) (d[f] = l.x), (d[f + 1] = l.y), (d[f + 2] = l.z);
                a.addAttribute('axis', new i.BufferAttribute(new Float32Array(d), 3));
                for (
                  var m = (function (e) {
                      for (
                        var t = e.attributes.position.array,
                          r = t.length,
                          n = 0,
                          i = 0,
                          a = 0,
                          o = 0;
                        o < r;
                        o += 3
                      )
                        (n += t[o]), (i += t[o + 1]), (a += t[o + 2]);
                      return { x: (3 * n) / r, y: (3 * i) / r, z: (3 * a) / r };
                    })(n),
                    v = new Array(3 * o).fill(0),
                    g = new Array(3 * s).fill(0),
                    y = 0;
                  y < 3 * o;
                  y += 3
                )
                  (v[y] = m.x), (v[y + 1] = m.y), (v[y + 2] = m.z);
                for (var x = 0; x < 3 * s; x += 3) (g[x] = m.x), (g[x + 1] = m.y), (g[x + 2] = m.z);
                return (
                  n.addAttribute('centroid', new i.BufferAttribute(new Float32Array(v), 3)),
                  a.addAttribute('centroid', new i.BufferAttribute(new Float32Array(g), 3)),
                  { surface: n, volume: a }
                );
              },
            },
            {
              key: 'setupResize',
              value: function () {
                window.addEventListener('resize', this.resize.bind(this));
              },
            },
            {
              key: 'resize',
              value: function () {
                (this.width = window.innerWidth),
                  (this.height = window.innerHeight),
                  this.renderer.setSize(this.width, this.height),
                  (this.camera.aspect = this.width / this.height),
                  this.camera.updateProjectionMatrix();
              },
            },
            {
              key: 'render',
              value: function () {
                this.renderer.render(this.scene, this.camera);
              },
            },
            {
              key: 'setupcubeTexture',
              value: function () {
                var e = 'js/newsky/',
                  t = [
                    e + 'px.jpg',
                    e + 'nx.jpg',
                    e + 'py.jpg',
                    e + 'ny.jpg',
                    e + 'pz.jpg',
                    e + 'nz.jpg',
                  ];
                this.textureCube = new i.CubeTextureLoader().load(t);
              },
            },
            {
              key: 'addObjects',
              value: function () {
                (this.material = new i.ShaderMaterial({
                  extensions: { derivatives: '#extension GL_OES_standard_derivatives : enable' },
                  side: i.DoubleSide,
                  uniforms: {
                    time: { type: 'f', value: 0 },
                    progress: { type: 'f', value: 0 },
                    inside: { type: 'f', value: 0 },
                    surfaceColor: { type: 'v3', value: this.surfaceColor },
                    insideColor: { type: 'v3', value: this.insideColor },
                    tCube: { value: this.textureCube },
                    pixels: {
                      type: 'v2',
                      value: new i.Vector2(window.innerWidth, window.innerHeight),
                    },
                    uvRate1: { value: new i.Vector2(1, 1) },
                  },
                  vertexShader: o.default,
                  fragmentShader: a.default,
                })),
                  (this.material1 = this.material.clone()),
                  (this.material1.uniforms.inside.value = 1);
              },
            },
            {
              key: 'mouse',
              value: function () {
                var e = this;
                document.addEventListener('mousemove', function (t) {
                  (e.targetmouseX = (2 * (t.clientX - e.width / 2)) / e.width),
                    (e.targetmouseY = (2 * (t.clientY - e.height / 2)) / e.height);
                  var r = Math.sqrt(
                    e.targetmouseX * e.targetmouseX + e.targetmouseY * e.targetmouseY,
                  );
                  (r = e.targetmouseX), (e.settings.progress = r * r);
                }),
                  document.addEventListener('touchmove', function (t) {
                    (e.targetmouseX = (t.touches[0].clientX / e.width) * 2 - 1),
                      (e.targetmouseY = (-t.touches[0].clientY / e.height) * 2 + 1);
                    var r = Math.sqrt(
                      e.targetmouseX * e.targetmouseX + e.targetmouseY * e.targetmouseY,
                    );
                    (r = e.targetmouseX), (e.settings.progress = r * r);
                  });
              },
            },
            {
              key: 'animate',
              value: function () {
                (this.time += 0.05),
                  (this.mouseX += 0.05 * (this.targetmouseX - this.mouseX)),
                  (this.material.uniforms.progress.value = Math.abs(this.settings.progress)),
                  (this.material1.uniforms.progress.value = Math.abs(this.settings.progress)),
                  requestAnimationFrame(this.animate.bind(this)),
                  this.render();
              },
            },
          ]),
          e
        );
      })();
      t.default = c;
    },
    function (e, t) {
      e.exports =
        '#define GLSLIFY 1\nuniform float time;\nuniform float progress;\nuniform float inside;\n\n\n\nattribute vec3 centroid;\nattribute vec3 axis;\nattribute float offset;\n\n// varying vec2 vUv;\n// varying vec3 vPosition;\nvarying vec3 eye;\nvarying vec3 vNormal;\nvarying vec3 vReflect;\n// varying float vTemp;\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n  mat4 m = rotationMatrix(axis, angle);\n  return (m * vec4(v, 1.0)).xyz;\n}\n\nvec3 bezier4(vec3 a, vec3 b, vec3 c, vec3 d, float t) {\n  return mix(mix(mix(a, b, t), mix(b, c, t), t), mix(mix(b, c, t), mix(c, d, t), t), t);\n}\n\nfloat easeInOutQuint(float t){\n  return t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * (--t) * t * t * t * t;\n}\nfloat easeOutQuint(float t){\n  return 1. + (--t) * t * t * t * t;\n}\nfloat easeOut(float t){\n  return  t * t * t;\n}\n\n\nvoid main() {\n  // vUv = uv;\n\n  float tProgress = easeOutQuint(min(1.0, max(0.0, (progress - offset*0.8) /0.2)));\n  tProgress = easeInOutQuint(progress);\n\n  vec3 newposition = position;\n\n  float vTemp = 1. - (position.y*10. + 1.)/2.;\n  vTemp =  (centroid.x*0.4 + 1.)/2.;\n  vTemp =  1. - ((centroid.x + centroid.y)*0.5 + 1.)/2.;\n\n  tProgress = easeOutQuint(min(1.0, max(0.0, (progress - vTemp*0.4) /0.6)));\n  tProgress = min(1.0, max(0.0, (progress - vTemp*0.4) /0.6));\n  tProgress = max(0.0, (progress - vTemp*0.4) /0.6);\n  // tProgress = progress;\n\n  // moving animation\n  // vec3 newposition = (position - centroid)*(1. - progress) + centroid;\n  vec3 newnormal = rotate(normal,axis,tProgress*(3. + offset*10.));\n  vNormal = newnormal;\n\n  // newposition = rotate(newposition - centroid,axis,(1. - vTemp)*tProgress*(3. + offset*10.)) + centroid;\n  newposition += newposition + centroid*(tProgress)*(3. + offset*7.);\n  // newposition = position - centroid;\n\n  // matcap\n  eye = normalize( vec3( modelViewMatrix * vec4( newposition, 1.0 ) ) );\n  vec4 worldPosition = modelMatrix * vec4( newposition, 1.0 );\n  vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * newnormal );\n  vec3 I = worldPosition.xyz - cameraPosition;\n  vReflect = reflect( I, worldNormal );\n  // vPosition = newposition;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( newposition, 1.0 );\n}';
    },
  ]);
});
//# sourceMappingURL=ico.js.map
